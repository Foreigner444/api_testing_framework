# 4.11 Combining Faker with Pydantic

## A. Concept Overview

### What & Why
This is where the magic happens! **Combining Faker with Pydantic** creates a powerful system: Faker generates realistic fake data, and Pydantic validates it's correct. This combination gives you type-safe, validated, realistic test data automatically â€“ the foundation of robust API testing frameworks.

### Analogy
Think of Faker + Pydantic like **a chef with a quality inspector**.

- **Faker** is the chef creating dishes (generating data)
- **Pydantic** is the quality inspector ensuring dishes meet standards (validating data)
- Together, they guarantee **realistic AND correct** data every time

You get variety (Faker) with safety (Pydantic)!

---

## B. Code Implementation

### File Path: `models/user_models.py`

```python
"""Pydantic models for user data."""
from datetime import datetime, date
from typing import Optional, List
from decimal import Decimal
from pydantic import BaseModel, EmailStr, Field, HttpUrl


class Address(BaseModel):
    """User address model."""
    street: str = Field(min_length=1)
    city: str = Field(min_length=1)
    state: str = Field(min_length=2, max_length=2)
    zipcode: str = Field(pattern=r'^\d{5}(-\d{4})?$')
    country: str = Field(default="USA")


class Company(BaseModel):
    """Company information model."""
    name: str = Field(min_length=1)
    industry: Optional[str] = None
    website: Optional[HttpUrl] = None


class User(BaseModel):
    """Complete user model."""
    id: int = Field(gt=0)
    username: str = Field(min_length=3, max_length=20)
    email: EmailStr
    first_name: str = Field(min_length=1)
    last_name: str = Field(min_length=1)
    phone: str
    date_of_birth: date
    address: Address
    company: Optional[Company] = None
    bio: Optional[str] = Field(None, max_length=500)
    website: Optional[HttpUrl] = None
    is_active: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.now)


class Product(BaseModel):
    """Product model."""
    id: int = Field(gt=0)
    sku: str = Field(min_length=5, max_length=20)
    name: str = Field(min_length=1, max_length=200)
    description: str = Field(max_length=1000)
    price: Decimal = Field(gt=0, decimal_places=2)
    category: str
    stock_quantity: int = Field(ge=0)
    is_available: bool = Field(default=True)
    tags: List[str] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.now)


class Order(BaseModel):
    """Order model."""
    id: str = Field(min_length=1)
    customer_id: int = Field(gt=0)
    status: str
    payment_method: str
    total: Decimal = Field(gt=0, decimal_places=2)
    currency: str = Field(min_length=3, max_length=3)
    created_at: datetime
    updated_at: datetime
```

---

### File Path: `factories/faker_pydantic_factories.py`

```python
"""Factories combining Faker with Pydantic models."""
from datetime import datetime
from decimal import Decimal
from faker import Faker
from models.user_models import User, Address, Company, Product, Order

fake = Faker()


# ==================== Basic Integration ====================

def create_fake_address() -> Address:
    """Create a fake Address using Faker + Pydantic."""
    return Address(
        street=fake.street_address(),
        city=fake.city(),
        state=fake.state_abbr(),
        zipcode=fake.zipcode(),
        country="USA"
    )


def create_fake_company() -> Company:
    """Create a fake Company using Faker + Pydantic."""
    return Company(
        name=fake.company(),
        industry=fake.random_element([
            "Technology", "Finance", "Healthcare",
            "Education", "Manufacturing", "Retail"
        ]),
        website=fake.url() if fake.boolean() else None
    )


def create_fake_user(**overrides) -> User:
    """Create a fake User using Faker + Pydantic.
    
    Args:
        **overrides: Override any field with custom value
    
    Returns:
        Validated User model instance
    """
    # Generate data with Faker
    user_data = {
        "id": fake.random_int(1, 10000),
        "username": fake.user_name(),
        "email": fake.email(),
        "first_name": fake.first_name(),
        "last_name": fake.last_name(),
        "phone": fake.phone_number(),
        "date_of_birth": fake.date_of_birth(minimum_age=18, maximum_age=80),
        "address": create_fake_address(),
        "company": create_fake_company() if fake.boolean(chance_of_getting_true=70) else None,
        "bio": fake.text(max_nb_chars=200) if fake.boolean() else None,
        "website": fake.url() if fake.boolean(chance_of_getting_true=30) else None,
        "is_active": fake.boolean(chance_of_getting_true=90),
        "created_at": fake.date_time_this_year()
    }
    
    # Override with any provided values
    user_data.update(overrides)
    
    # Validate with Pydantic
    return User.model_validate(user_data)


def create_fake_product(**overrides) -> Product:
    """Create a fake Product using Faker + Pydantic."""
    product_data = {
        "id": fake.random_int(1, 10000),
        "sku": f"PROD-{fake.random_int(10000, 99999)}",
        "name": fake.sentence(nb_words=3).replace(".", "").title(),
        "description": fake.text(max_nb_chars=500),
        "price": Decimal(str(fake.pyfloat(min_value=1, max_value=1000, right_digits=2))),
        "category": fake.random_element([
            "Electronics", "Clothing", "Home & Garden",
            "Books", "Sports", "Toys"
        ]),
        "stock_quantity": fake.random_int(0, 1000),
        "is_available": fake.boolean(chance_of_getting_true=85),
        "tags": fake.words(fake.random_int(2, 5)),
        "created_at": fake.date_time_this_year()
    }
    
    product_data.update(overrides)
    
    return Product.model_validate(product_data)


def create_fake_order(**overrides) -> Order:
    """Create a fake Order using Faker + Pydantic."""
    created = fake.date_time_this_year()
    
    order_data = {
        "id": f"ORD-{fake.random_int(100000, 999999)}",
        "customer_id": fake.random_int(1, 10000),
        "status": fake.random_element([
            "pending", "confirmed", "processing",
            "shipped", "delivered", "cancelled"
        ]),
        "payment_method": fake.random_element([
            "credit_card", "debit_card", "paypal", "bank_transfer"
        ]),
        "total": Decimal(str(fake.pyfloat(min_value=10, max_value=5000, right_digits=2))),
        "currency": fake.random_element(["USD", "EUR", "GBP"]),
        "created_at": created,
        "updated_at": fake.date_time_between(start_date=created, end_date=datetime.now())
    }
    
    order_data.update(overrides)
    
    return Order.model_validate(order_data)


# ==================== Batch Creation ====================

def create_fake_users(count: int, **overrides) -> List[User]:
    """Create multiple fake users."""
    return [create_fake_user(**overrides) for _ in range(count)]


def create_fake_products(count: int, **overrides) -> List[Product]:
    """Create multiple fake products."""
    return [create_fake_product(**overrides) for _ in range(count)]


def create_fake_orders(count: int, **overrides) -> List[Order]:
    """Create multiple fake orders."""
    return [create_fake_order(**overrides) for _ in range(count)]


# ==================== Preset Factories ====================

def create_admin_user() -> User:
    """Create an admin user with preset values."""
    return create_fake_user(
        username="admin",
        email="admin@example.com",
        is_active=True
    )


def create_inactive_user() -> User:
    """Create an inactive user."""
    return create_fake_user(is_active=False)


def create_premium_product() -> Product:
    """Create a premium product."""
    return create_fake_product(
        price=Decimal("999.99"),
        category="Electronics",
        is_available=True
    )


def create_out_of_stock_product() -> Product:
    """Create an out-of-stock product."""
    return create_fake_product(
        stock_quantity=0,
        is_available=False
    )
```

---

### File Path: `tests/test_faker_pydantic.py`

```python
"""Tests for Faker + Pydantic integration."""
import pytest
from pydantic import ValidationError
from factories.faker_pydantic_factories import (
    create_fake_user,
    create_fake_product,
    create_fake_order,
    create_fake_users,
    create_fake_products,
    create_admin_user,
    create_out_of_stock_product
)
from models.user_models import User, Product, Order


def test_create_fake_user():
    """Test creating a fake user with Pydantic validation."""
    user = create_fake_user()
    
    # Should be a valid User instance
    assert isinstance(user, User)
    
    # All required fields should be present and valid
    assert user.id > 0
    assert len(user.username) >= 3
    assert "@" in user.email
    assert len(user.first_name) > 0
    assert len(user.last_name) > 0
    assert user.address.state == user.address.state.upper()
    
    print(f"âœ… Fake user created!")
    print(f"   {user.first_name} {user.last_name} ({user.username})")
    print(f"   Email: {user.email}")
    print(f"   City: {user.address.city}, {user.address.state}")


def test_fake_user_with_overrides():
    """Test creating fake user with custom values."""
    user = create_fake_user(
        username="customuser",
        email="custom@example.com",
        is_active=False
    )
    
    # Custom values should be used
    assert user.username == "customuser"
    assert user.email == "custom@example.com"
    assert user.is_active is False
    
    # Other fields still generated by Faker
    assert len(user.first_name) > 0
    assert len(user.phone) > 0
    
    print(f"âœ… Fake user with overrides!")
    print(f"   Username: {user.username}")
    print(f"   Active: {user.is_active}")


def test_create_multiple_fake_users():
    """Test creating multiple fake users."""
    users = create_fake_users(10)
    
    # Should have 10 users
    assert len(users) == 10
    
    # All should be valid User instances
    assert all(isinstance(u, User) for u in users)
    
    # All should have valid emails
    assert all("@" in u.email for u in users)
    
    # Most should be unique
    usernames = [u.username for u in users]
    assert len(set(usernames)) >= 9
    
    print(f"âœ… Created {len(users)} fake users!")
    for i, user in enumerate(users[:3], 1):
        print(f"   {i}. {user.first_name} {user.last_name}")


def test_fake_user_validation():
    """Test that Pydantic validates Faker-generated data."""
    # Faker generates valid data
    user = create_fake_user()
    
    # Should pass all Pydantic validations
    assert user.id > 0  # gt=0 constraint
    assert 3 <= len(user.username) <= 20  # length constraints
    assert len(user.address.state) == 2  # state abbreviation
    
    print(f"âœ… Faker data passes Pydantic validation!")


def test_create_fake_product():
    """Test creating a fake product."""
    product = create_fake_product()
    
    # Should be valid Product instance
    assert isinstance(product, Product)
    
    # Validations
    assert product.id > 0
    assert len(product.sku) >= 5
    assert product.price > 0
    assert product.stock_quantity >= 0
    assert len(product.tags) >= 2
    
    print(f"âœ… Fake product created!")
    print(f"   {product.name} (SKU: {product.sku})")
    print(f"   Price: ${product.price}")
    print(f"   Stock: {product.stock_quantity}")


def test_create_fake_order():
    """Test creating a fake order."""
    order = create_fake_order()
    
    # Should be valid Order instance
    assert isinstance(order, Order)
    
    # Validations
    assert order.id.startswith("ORD-")
    assert order.customer_id > 0
    assert order.total > 0
    assert len(order.currency) == 3
    assert order.updated_at >= order.created_at
    
    print(f"âœ… Fake order created!")
    print(f"   {order.id}: ${order.total} {order.currency}")
    print(f"   Status: {order.status}")


def test_preset_factories():
    """Test preset factory functions."""
    # Admin user
    admin = create_admin_user()
    assert admin.username == "admin"
    assert admin.email == "admin@example.com"
    assert admin.is_active is True
    
    # Out of stock product
    product = create_out_of_stock_product()
    assert product.stock_quantity == 0
    assert product.is_available is False
    
    print(f"âœ… Preset factories work!")
    print(f"   Admin: {admin.username}")
    print(f"   Out of stock product: {product.name}")


def test_faker_pydantic_catches_invalid_data():
    """Test that Pydantic catches invalid Faker data if constraints change."""
    from factories.faker_pydantic_factories import fake
    
    # If we try to create user with invalid data, Pydantic catches it
    with pytest.raises(ValidationError):
        User.model_validate({
            "id": -1,  # Invalid! Must be > 0
            "username": fake.user_name(),
            "email": fake.email(),
            "first_name": fake.first_name(),
            "last_name": fake.last_name(),
            "phone": fake.phone_number(),
            "date_of_birth": fake.date_of_birth(),
            "address": create_fake_address(),
            "created_at": fake.date_time()
        })
    
    print(f"âœ… Pydantic catches invalid data!")


# ==================== Advanced Patterns ====================

def test_nested_faker_pydantic():
    """Test nested models with Faker."""
    from factories.faker_pydantic_factories import create_fake_address, create_fake_company
    
    # Create nested models
    address = create_fake_address()
    company = create_fake_company()
    
    # Both should be valid
    assert isinstance(address, Address)
    assert isinstance(company, Company)
    
    # Use in parent model
    user = create_fake_user(address=address, company=company)
    
    assert user.address == address
    assert user.company == company
    
    print(f"âœ… Nested Faker + Pydantic works!")


def test_optional_fields_with_faker():
    """Test optional fields generated conditionally."""
    # Generate 20 users
    users = create_fake_users(20)
    
    # Some should have company, some shouldn't
    with_company = [u for u in users if u.company is not None]
    without_company = [u for u in users if u.company is None]
    
    # Should have mix (not all or none)
    assert len(with_company) > 0
    assert len(without_company) > 0
    
    print(f"âœ… Optional fields randomized!")
    print(f"   With company: {len(with_company)}")
    print(f"   Without company: {len(without_company)}")


def test_list_fields_with_faker():
    """Test list fields with Faker."""
    products = create_fake_products(10)
    
    # All should have tags (list field)
    assert all(len(p.tags) >= 2 for p in products)
    
    # Tags should be realistic words
    all_tags = [tag for p in products for tag in p.tags]
    assert all(isinstance(tag, str) for tag in all_tags)
    
    print(f"âœ… List fields with Faker!")
    print(f"   Product tags sample: {products[0].tags}")


def test_date_relationships_with_faker():
    """Test maintaining date relationships."""
    orders = create_fake_orders(10)
    
    # updated_at should always be >= created_at
    assert all(o.updated_at >= o.created_at for o in orders)
    
    print(f"âœ… Date relationships maintained!")


# ==================== Type Safety Benefits ====================

def test_type_safety_with_ide():
    """Test that Faker + Pydantic provides full type safety."""
    user = create_fake_user()
    
    # IDE knows exact type of user
    # Autocomplete works for all fields
    full_name = f"{user.first_name} {user.last_name}"
    city = user.address.city
    
    # Type checking works
    assert isinstance(full_name, str)
    assert isinstance(city, str)
    
    print(f"âœ… Full type safety!")
    print(f"   {full_name} from {city}")


def test_validation_on_generated_data():
    """Test that all generated data is validated."""
    # Generate 100 users
    users = create_fake_users(100)
    
    # ALL should pass Pydantic validation
    for user in users:
        # If we get here, validation passed
        assert isinstance(user, User)
        assert user.id > 0
        assert "@" in user.email
        assert len(user.username) >= 3
    
    print(f"âœ… All {len(users)} users passed validation!")


# ==================== Reusability ====================

def test_reusable_across_tests():
    """Test that factories are reusable across different tests."""
    # Test 1: Create user
    user1 = create_fake_user()
    assert user1.is_active
    
    # Test 2: Create inactive user
    user2 = create_fake_user(is_active=False)
    assert not user2.is_active
    
    # Test 3: Create user with specific email
    user3 = create_fake_user(email="specific@example.com")
    assert user3.email == "specific@example.com"
    
    print(f"âœ… Factories reusable across tests!")


def test_complex_nested_structure():
    """Test complex nested structure with Faker + Pydantic."""
    # Create user with all nested structures
    user = create_fake_user()
    
    # Access nested fields
    assert user.address.city
    assert user.address.state
    
    if user.company:
        assert user.company.name
    
    # Everything is type-safe and validated
    print(f"âœ… Complex nested structures work!")
    print(f"   User: {user.first_name} {user.last_name}")
    print(f"   Address: {user.address.city}, {user.address.state}")
    if user.company:
        print(f"   Company: {user.company.name}")


# ==================== Performance ====================

def test_generation_performance():
    """Test that generation is fast."""
    import time
    
    start = time.time()
    users = create_fake_users(1000)
    end = time.time()
    
    generation_time = end - start
    
    assert len(users) == 1000
    assert generation_time < 5.0  # Should be fast
    
    print(f"âœ… Generated 1000 users in {generation_time:.2f}s")
    print(f"   Rate: {1000/generation_time:.0f} users/second")


# ==================== Edge Cases ====================

def test_boundary_values():
    """Test that Faker can generate boundary values."""
    # Create user with minimum age
    young_user = create_fake_user()
    
    # Create product with zero stock
    product = create_fake_product(stock_quantity=0)
    assert product.stock_quantity == 0
    
    # Create product with maximum stock
    product2 = create_fake_product(stock_quantity=1000)
    assert product2.stock_quantity == 1000
    
    print(f"âœ… Boundary values work!")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run tests
pytest tests/test_faker_pydantic.py -v -s
```

### Expected Result

```
tests/test_faker_pydantic.py::test_create_fake_user PASSED
âœ… Fake user created!
   Emily Johnson (emily_johnson)
   Email: emily.johnson@gmail.com
   City: Boston, MA

tests/test_faker_pydantic.py::test_create_multiple_fake_users PASSED
âœ… Created 10 fake users!
   1. Jennifer Martinez
   2. Michael Chen
   3. Sarah Anderson

tests/test_faker_pydantic.py::test_generation_performance PASSED
âœ… Generated 1000 users in 0.87s
   Rate: 1149 users/second

======================== 20 passed in 1.45s =========================
```

---

## D. Best Practices

### 1. **Always Validate**
```python
# âœ… Always use Pydantic validation
user = User.model_validate(faker_data)

# âŒ Don't skip validation
user_dict = faker_data  # No validation!
```

### 2. **Provide Overrides**
```python
def create_fake_user(**overrides):
    data = {/* faker data */}
    data.update(overrides)  # Allow customization
    return User.model_validate(data)
```

### 3. **Separate Factory Functions**
```python
# âœ… One function per model
def create_fake_user(): ...
def create_fake_product(): ...

# âŒ Don't mix concerns
def create_fake_data(type): ...  # Too generic
```

---

## E. What You've Learned

âœ… Combining Faker with Pydantic models  
âœ… Creating factory functions  
âœ… Type-safe fake data generation  
âœ… Automatic validation of generated data  
âœ… Nested model factories  
âœ… Override patterns for customization  
âœ… Batch creation methods  
âœ… Preset factories for common scenarios  
âœ… Performance considerations  
âœ… Edge case generation  

---

## F. What's Next?

In **Lesson 4.12 (Faker Data in httpx Requests)** ğŸŒŸ, we'll learn:
- Using Faker-generated data in API requests
- Testing POST/PUT/PATCH with fake data
- Integration testing with realistic data
- **The complete Faker + Pydantic + httpx workflow!**

This is the big integration lesson! ğŸ‰

---

**Ready for the next lesson?**
