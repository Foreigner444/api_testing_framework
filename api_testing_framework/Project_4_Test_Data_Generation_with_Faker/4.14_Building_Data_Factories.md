# 4.14 Building Data Factories

## A. Concept Overview

### What & Why
Building **production-ready data factories** means creating a complete, organized system for test data generation. This includes factories for all your models, helper functions, proper organization, and integration with your test framework. Professional test frameworks have well-structured factory systems that make testing effortless.

### Analogy
Think of building data factories like **setting up a complete manufacturing facility**.

Not just one assembly line (one factory), but:
- **Multiple production lines** (factories for each model type)
- **Quality control** (Pydantic validation at every step)
- **Customization stations** (override capabilities)
- **Batch production** (create multiple items)
- **Inventory system** (organize and find factories easily)

A complete system, not just individual pieces!

---

## B. Code Implementation

### File Path: `factories/__init__.py`

```python
"""Centralized factory exports."""
from factories.user_factory import UserFactory, create_user
from factories.product_factory import ProductFactory, create_product
from factories.order_factory import OrderFactory, create_order

__all__ = [
    "UserFactory",
    "create_user",
    "ProductFactory",
    "create_product",
    "OrderFactory",
    "create_order",
]
```

---

### File Path: `factories/base_factory.py`

```python
"""Base factory with common functionality."""
from faker import Faker
from typing import TypeVar, Generic, Type, List
from pydantic import BaseModel

T = TypeVar('T', bound=BaseModel)

fake = Faker()


class BaseFactory(Generic[T]):
    """Base factory class with common functionality."""
    
    model_class: Type[T] = None
    
    @classmethod
    def create(cls, **overrides) -> T:
        """Create a single instance. Must be implemented by subclass."""
        raise NotImplementedError("Subclass must implement create()")
    
    @classmethod
    def create_batch(cls, count: int, **overrides) -> List[T]:
        """Create multiple instances."""
        return [cls.create(**overrides) for _ in range(count)]
    
    @classmethod
    def build_dict(cls, **overrides) -> dict:
        """Build dictionary without validating. Must be implemented by subclass."""
        raise NotImplementedError("Subclass must implement build_dict()")
    
    @classmethod
    def create_from_dict(cls, data: dict) -> T:
        """Create instance from dictionary."""
        return cls.model_class.model_validate(data)
```

---

### File Path: `factories/product_factory.py`

```python
"""Product factory."""
from decimal import Decimal
from faker import Faker
from models.user_models import Product
from factories.base_factory import BaseFactory

fake = Faker()


class ProductFactory(BaseFactory[Product]):
    """Factory for creating Product instances."""
    
    model_class = Product
    
    @classmethod
    def build_dict(cls, **overrides) -> dict:
        """Build product dictionary."""
        data = {
            "id": fake.random_int(1, 100000),
            "sku": f"PROD-{fake.random_int(10000, 99999)}",
            "name": fake.sentence(nb_words=3).replace(".", "").title(),
            "description": fake.text(max_nb_chars=500),
            "price": Decimal(str(fake.pyfloat(min_value=1, max_value=1000, right_digits=2))),
            "category": fake.random_element([
                "Electronics", "Clothing", "Home & Garden",
                "Books", "Sports", "Toys", "Health & Beauty"
            ]),
            "stock_quantity": fake.random_int(0, 500),
            "is_available": fake.boolean(chance_of_getting_true=85),
            "tags": fake.words(fake.random_int(2, 5)),
            "created_at": fake.date_time_this_year()
        }
        data.update(overrides)
        return data
    
    @classmethod
    def create(cls, **overrides) -> Product:
        """Create a Product instance."""
        return cls.create_from_dict(cls.build_dict(**overrides))
    
    @classmethod
    def create_electronics(cls, **overrides) -> Product:
        """Create electronics product."""
        return cls.create(category="Electronics", **overrides)
    
    @classmethod
    def create_book(cls, **overrides) -> Product:
        """Create book product."""
        return cls.create(category="Books", **overrides)
    
    @classmethod
    def create_out_of_stock(cls, **overrides) -> Product:
        """Create out-of-stock product."""
        return cls.create(
            stock_quantity=0,
            is_available=False,
            **overrides
        )
    
    @classmethod
    def create_expensive(cls, **overrides) -> Product:
        """Create expensive product."""
        return cls.create(
            price=Decimal("999.99"),
            **overrides
        )


def create_product(**overrides) -> Product:
    """Convenience function for creating products."""
    return ProductFactory.create(**overrides)
```

---

### File Path: `factories/order_factory.py`

```python
"""Order factory."""
from decimal import Decimal
from datetime import datetime
from faker import Faker
from models.user_models import Order
from factories.base_factory import BaseFactory

fake = Faker()


class OrderFactory(BaseFactory[Order]):
    """Factory for creating Order instances."""
    
    model_class = Order
    
    @classmethod
    def build_dict(cls, **overrides) -> dict:
        """Build order dictionary."""
        created = fake.date_time_this_year()
        
        data = {
            "id": f"ORD-{fake.random_int(100000, 999999)}",
            "customer_id": fake.random_int(1, 10000),
            "status": fake.random_element([
                "pending", "confirmed", "processing",
                "shipped", "delivered"
            ]),
            "payment_method": fake.random_element([
                "credit_card", "debit_card", "paypal", "bank_transfer"
            ]),
            "total": Decimal(str(fake.pyfloat(min_value=10, max_value=5000, right_digits=2))),
            "currency": fake.random_element(["USD", "EUR", "GBP"]),
            "created_at": created,
            "updated_at": fake.date_time_between(start_date=created, end_date=datetime.now())
        }
        data.update(overrides)
        return data
    
    @classmethod
    def create(cls, **overrides) -> Order:
        """Create an Order instance."""
        return cls.create_from_dict(cls.build_dict(**overrides))
    
    @classmethod
    def create_pending(cls, **overrides) -> Order:
        """Create pending order."""
        return cls.create(status="pending", **overrides)
    
    @classmethod
    def create_delivered(cls, **overrides) -> Order:
        """Create delivered order."""
        return cls.create(status="delivered", **overrides)
    
    @classmethod
    def create_for_customer(cls, customer_id: int, **overrides) -> Order:
        """Create order for specific customer."""
        return cls.create(customer_id=customer_id, **overrides)


def create_order(**overrides) -> Order:
    """Convenience function for creating orders."""
    return OrderFactory.create(**overrides)
```

---

### File Path: `tests/test_data_factories.py`

```python
"""Tests for production-ready data factories."""
import pytest
from decimal import Decimal
from factories import (
    UserFactory,
    ProductFactory,
    OrderFactory
)


def test_product_factory():
    """Test ProductFactory."""
    product = ProductFactory.create()
    
    assert product.id > 0
    assert product.sku.startswith("PROD-")
    assert product.price > 0
    
    print(f"âœ… ProductFactory: {product.name} - ${product.price}")


def test_product_factory_presets():
    """Test product factory presets."""
    electronics = ProductFactory.create_electronics()
    assert electronics.category == "Electronics"
    
    book = ProductFactory.create_book()
    assert book.category == "Books"
    
    expensive = ProductFactory.create_expensive()
    assert expensive.price == Decimal("999.99")
    
    out_of_stock = ProductFactory.create_out_of_stock()
    assert out_of_stock.stock_quantity == 0
    
    print(f"âœ… All product presets work!")


def test_order_factory():
    """Test OrderFactory."""
    order = OrderFactory.create()
    
    assert order.id.startswith("ORD-")
    assert order.total > 0
    assert len(order.currency) == 3
    
    print(f"âœ… OrderFactory: {order.id} - ${order.total}")


def test_order_factory_presets():
    """Test order factory presets."""
    pending = OrderFactory.create_pending()
    assert pending.status == "pending"
    
    delivered = OrderFactory.create_delivered()
    assert delivered.status == "delivered"
    
    customer_order = OrderFactory.create_for_customer(customer_id=123)
    assert customer_order.customer_id == 123
    
    print(f"âœ… All order presets work!")


def test_batch_creation_all_factories():
    """Test batch creation across all factories."""
    users = UserFactory.create_batch(5)
    products = ProductFactory.create_batch(5)
    orders = OrderFactory.create_batch(5)
    
    assert len(users) == 5
    assert len(products) == 5
    assert len(orders) == 5
    
    print(f"âœ… Batch creation across all factories!")


def test_factory_composition():
    """Test composing factories together."""
    # Create user
    user = UserFactory.create()
    
    # Create order for that user
    order = OrderFactory.create_for_customer(user.id)
    
    # User ID matches
    assert order.customer_id == user.id
    
    print(f"âœ… Factory composition!")
    print(f"   User: {user.username}")
    print(f"   Order: {order.id} for customer {order.customer_id}")


def test_factories_with_httpx():
    """Test using factories in httpx requests."""
    import httpx
    from factories import create_user
    
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Create request data with factory
    user = create_user()
    
    # Extract fields for API request
    request_data = {
        "name": user.first_name + " " + user.last_name,
        "email": user.email,
        "username": user.username
    }
    
    # Send request
    response = client.post("/users", json=request_data)
    assert response.status_code == 201
    
    print(f"âœ… Factories with httpx: Created {user.username}")


def test_factory_organization():
    """Test that factories are well-organized."""
    # Import all factories
    from factories import (
        UserFactory,
        ProductFactory,
        OrderFactory
    )
    
    # All should be available
    assert UserFactory is not None
    assert ProductFactory is not None
    assert OrderFactory is not None
    
    # All should have create method
    assert hasattr(UserFactory, 'create')
    assert hasattr(ProductFactory, 'create')
    assert hasattr(OrderFactory, 'create')
    
    print(f"âœ… Factories well-organized and importable!")
```

---

## C. Factory Organization Structure

```
factories/
â”œâ”€â”€ __init__.py              # Central exports
â”œâ”€â”€ base_factory.py          # Base factory class
â”œâ”€â”€ user_factory.py          # User factories
â”œâ”€â”€ product_factory.py       # Product factories
â”œâ”€â”€ order_factory.py         # Order factories
â””â”€â”€ helpers.py              # Helper functions
```

---

## D. What You've Learned

âœ… Building production-ready factories  
âœ… Base factory class pattern  
âœ… Factory inheritance  
âœ… Multiple preset methods  
âœ… Factory composition  
âœ… Batch creation  
âœ… Factory organization  
âœ… Integration with httpx  

---

## E. What's Next?

In **Lesson 4.15 (Factory Boy Integration)**, we'll learn:
- Installing Factory Boy library
- Advanced factory features
- Lazy attributes and sequences

Professional factories complete! ðŸŽ‰

---

**Ready for the next lesson?**
