# 4.3 Generating Names and Addresses

## A. Concept Overview

### What & Why
Names and addresses are fundamental test data for most APIs. Faker provides extensive methods to generate realistic personal and location data, from simple first names to complete international addresses with proper formatting. Understanding these methods enables you to create diverse, realistic user profiles for testing.

### Analogy
Think of Faker's name and address methods like **a character generator in a video game**.

Just like creating a game character:
- Choose gender â†’ `name_male()` or `name_female()`
- Select title â†’ `prefix()` like "Dr." or "Mrs."
- Pick location â†’ `city()`, `state()`, `country()`
- Add details â†’ `building_number()`, `street_name()`

Each piece combines to create a complete, believable identity!

---

## B. Code Implementation

### File Path: `examples/names_and_addresses.py`

```python
"""Comprehensive examples for generating names and addresses."""
from faker import Faker

fake = Faker()

print("=" * 70)
print("NAMES AND ADDRESSES - COMPREHENSIVE GUIDE")
print("=" * 70)

# ==================== BASIC NAMES ====================
print("\nğŸ“ BASIC NAMES:")
print(f"Full name: {fake.name()}")
print(f"First name: {fake.first_name()}")
print(f"Last name: {fake.last_name()}")
print(f"Middle name: {fake.first_name()}")  # Can be used as middle name

# ==================== GENDER-SPECIFIC NAMES ====================
print("\nğŸ‘¨ğŸ‘© GENDER-SPECIFIC NAMES:")
print(f"Male name: {fake.name_male()}")
print(f"Female name: {fake.name_female()}")
print(f"Male first name: {fake.first_name_male()}")
print(f"Female first name: {fake.first_name_female()}")
print(f"Male last name: {fake.last_name_male()}")
print(f"Female last name: {fake.last_name_female()}")

# ==================== NAME PREFIXES AND SUFFIXES ====================
print("\nğŸ“ PREFIXES & SUFFIXES:")
print(f"Prefix: {fake.prefix()}")  # Dr., Mr., Mrs., etc.
print(f"Suffix: {fake.suffix()}")  # Jr., Sr., PhD, etc.
print(f"Male prefix: {fake.prefix_male()}")
print(f"Female prefix: {fake.prefix_female()}")

# Build complete formal name
prefix = fake.prefix()
first = fake.first_name()
middle = fake.first_name()
last = fake.last_name()
suffix = fake.suffix()
formal_name = f"{prefix} {first} {middle} {last}, {suffix}"
print(f"\nFormal name: {formal_name}")

# ==================== BASIC ADDRESS COMPONENTS ====================
print("\nğŸ  BASIC ADDRESS COMPONENTS:")
print(f"Building number: {fake.building_number()}")
print(f"Street name: {fake.street_name()}")
print(f"Street address: {fake.street_address()}")
print(f"Secondary address: {fake.secondary_address()}")  # Apt, Suite, etc.

# ==================== CITY, STATE, COUNTRY ====================
print("\nğŸŒ† LOCATION:")
print(f"City: {fake.city()}")
print(f"State: {fake.state()}")
print(f"State abbreviation: {fake.state_abbr()}")
print(f"Zipcode: {fake.zipcode()}")
print(f"Postcode: {fake.postcode()}")
print(f"Country: {fake.country()}")
print(f"Country code: {fake.country_code()}")

# ==================== COMPLETE ADDRESSES ====================
print("\nğŸ“® COMPLETE ADDRESSES:")
print(f"Address:\n{fake.address()}")
print(f"\nMilitary APO: {fake.military_apo()}")
print(f"Military DPO: {fake.military_dpo()}")

# ==================== COORDINATES ====================
print("\nğŸ—ºï¸ COORDINATES:")
print(f"Latitude: {fake.latitude()}")
print(f"Longitude: {fake.longitude()}")
print(f"Coordinates: {fake.latlng()}")  # Returns tuple
print(f"Local latlng: {fake.local_latlng()}")

# ==================== STRUCTURED ADDRESS ====================
print("\nğŸ¢ BUILDING STRUCTURED ADDRESS:")
street_num = fake.building_number()
street_name = fake.street_name()
street_suffix = fake.street_suffix()
city = fake.city()
state_abbr = fake.state_abbr()
zipcode = fake.zipcode()

address_line1 = f"{street_num} {street_name} {street_suffix}"
address_line2 = f"{city}, {state_abbr} {zipcode}"
print(f"Address Line 1: {address_line1}")
print(f"Address Line 2: {address_line2}")

# ==================== ADDRESS WITH SECONDARY ====================
print("\nğŸ¢ ADDRESS WITH APARTMENT:")
street = fake.street_address()
secondary = fake.secondary_address()
city = fake.city()
state = fake.state_abbr()
zipcode = fake.zipcode()

full_address = f"{street}, {secondary}\n{city}, {state} {zipcode}"
print(full_address)

print("\n" + "=" * 70)
```

---

### File Path: `tests/test_names_addresses.py`

```python
"""Tests for name and address generation."""
import pytest
from faker import Faker


# ==================== NAME TESTS ====================

def test_basic_names():
    """Test basic name generation."""
    fake = Faker()
    
    name = fake.name()
    first_name = fake.first_name()
    last_name = fake.last_name()
    
    # All should be non-empty strings
    assert isinstance(name, str) and len(name) > 0
    assert isinstance(first_name, str) and len(first_name) > 0
    assert isinstance(last_name, str) and len(last_name) > 0
    
    # Full name should contain spaces (first + last)
    assert " " in name
    
    print(f"âœ… Basic names generated!")
    print(f"   Full: {name}")
    print(f"   First: {first_name}")
    print(f"   Last: {last_name}")


def test_gender_specific_names():
    """Test gender-specific name generation."""
    fake = Faker()
    
    male_name = fake.name_male()
    female_name = fake.name_female()
    male_first = fake.first_name_male()
    female_first = fake.first_name_female()
    
    # All should be valid strings
    assert all(isinstance(n, str) and len(n) > 0 
               for n in [male_name, female_name, male_first, female_first])
    
    print(f"âœ… Gender-specific names generated!")
    print(f"   Male: {male_name}")
    print(f"   Female: {female_name}")


def test_name_prefixes_suffixes():
    """Test name prefixes and suffixes."""
    fake = Faker()
    
    prefix = fake.prefix()
    suffix = fake.suffix()
    prefix_male = fake.prefix_male()
    prefix_female = fake.prefix_female()
    
    # All should be non-empty
    assert all(isinstance(x, str) and len(x) > 0 
               for x in [prefix, suffix, prefix_male, prefix_female])
    
    # Common prefixes
    common_prefixes = ["Mr.", "Mrs.", "Ms.", "Dr.", "Prof."]
    assert prefix in common_prefixes or len(prefix) > 0
    
    print(f"âœ… Prefixes and suffixes generated!")
    print(f"   Prefix: {prefix}")
    print(f"   Suffix: {suffix}")


def test_build_formal_name():
    """Test building a complete formal name."""
    fake = Faker()
    
    prefix = fake.prefix()
    first = fake.first_name()
    middle = fake.first_name()
    last = fake.last_name()
    suffix = fake.suffix()
    
    # Build formal name
    formal_name = f"{prefix} {first} {middle} {last}, {suffix}"
    
    # Should contain all components
    assert prefix in formal_name
    assert first in formal_name
    assert last in formal_name
    
    print(f"âœ… Formal name built: {formal_name}")


# ==================== ADDRESS TESTS ====================

def test_address_components():
    """Test individual address components."""
    fake = Faker()
    
    building_num = fake.building_number()
    street_name = fake.street_name()
    street_addr = fake.street_address()
    secondary = fake.secondary_address()
    
    # All should be non-empty strings
    assert all(isinstance(x, str) and len(x) > 0 
               for x in [building_num, street_name, street_addr, secondary])
    
    # Street address should contain a number
    assert any(char.isdigit() for char in street_addr)
    
    print(f"âœ… Address components generated!")
    print(f"   Building: {building_num}")
    print(f"   Street: {street_name}")
    print(f"   Full: {street_addr}")


def test_location_components():
    """Test city, state, country generation."""
    fake = Faker()
    
    city = fake.city()
    state = fake.state()
    state_abbr = fake.state_abbr()
    zipcode = fake.zipcode()
    country = fake.country()
    country_code = fake.country_code()
    
    # All should be non-empty
    assert all(isinstance(x, str) and len(x) > 0 
               for x in [city, state, state_abbr, zipcode, country, country_code])
    
    # State abbreviation should be 2 characters
    assert len(state_abbr) == 2
    assert state_abbr.isupper()
    
    # Country code should be 2 characters
    assert len(country_code) == 2
    assert country_code.isupper()
    
    # Zipcode should contain digits
    assert any(char.isdigit() for char in zipcode)
    
    print(f"âœ… Location components generated!")
    print(f"   {city}, {state_abbr} {zipcode}")
    print(f"   {country} ({country_code})")


def test_complete_address():
    """Test complete address generation."""
    fake = Faker()
    
    address = fake.address()
    
    # Should be a multi-line string
    assert isinstance(address, str)
    assert len(address) > 10
    
    # Should contain newline (multi-line address)
    assert "\n" in address
    
    print(f"âœ… Complete address generated!")
    print(f"{address}")


def test_coordinates():
    """Test coordinate generation."""
    fake = Faker()
    
    lat = fake.latitude()
    lng = fake.longitude()
    coords = fake.latlng()
    
    # Latitude and longitude should be numeric strings or floats
    lat_float = float(lat)
    lng_float = float(lng)
    
    # Latitude: -90 to 90
    assert -90 <= lat_float <= 90
    
    # Longitude: -180 to 180
    assert -180 <= lng_float <= 180
    
    # latlng returns tuple
    assert isinstance(coords, tuple)
    assert len(coords) == 2
    
    print(f"âœ… Coordinates generated!")
    print(f"   Lat: {lat}, Lng: {lng}")
    print(f"   Tuple: {coords}")


def test_build_structured_address():
    """Test building a structured address manually."""
    fake = Faker()
    
    # Build address line by line
    street_num = fake.building_number()
    street_name = fake.street_name()
    street_suffix = fake.street_suffix()
    secondary = fake.secondary_address()
    city = fake.city()
    state = fake.state_abbr()
    zipcode = fake.zipcode()
    
    address_line1 = f"{street_num} {street_name} {street_suffix}"
    address_line2 = f"{secondary}"
    address_line3 = f"{city}, {state} {zipcode}"
    
    full_address = f"{address_line1}\n{address_line2}\n{address_line3}"
    
    # Should be well-formed
    assert len(full_address) > 20
    assert "\n" in full_address
    assert state in full_address
    
    print(f"âœ… Structured address built!")
    print(full_address)


def test_generate_multiple_addresses():
    """Test generating multiple unique addresses."""
    fake = Faker()
    
    addresses = [fake.address() for _ in range(10)]
    
    # All should be non-empty
    assert all(len(addr) > 0 for addr in addresses)
    
    # Most should be unique
    unique_addresses = set(addresses)
    assert len(unique_addresses) >= 9  # At least 9 out of 10 unique
    
    print(f"âœ… Generated {len(addresses)} addresses!")
    print(f"   Unique: {len(unique_addresses)}")


def test_street_suffix():
    """Test street suffix generation."""
    fake = Faker()
    
    suffix = fake.street_suffix()
    
    # Should be a valid street suffix
    common_suffixes = ["St", "Ave", "Blvd", "Dr", "Rd", "Ln", "Way", "Ct"]
    
    # May contain period or not
    suffix_clean = suffix.replace(".", "")
    
    assert isinstance(suffix, str)
    assert len(suffix) > 0
    
    print(f"âœ… Street suffix: {suffix}")


# ==================== PRACTICAL USE CASES ====================

def test_user_profile_with_faker():
    """Test creating a complete user profile."""
    fake = Faker()
    
    user_profile = {
        "full_name": fake.name(),
        "first_name": fake.first_name(),
        "last_name": fake.last_name(),
        "address_line1": fake.street_address(),
        "address_line2": fake.secondary_address(),
        "city": fake.city(),
        "state": fake.state_abbr(),
        "zipcode": fake.zipcode(),
        "country": fake.country_code(),
        "latitude": fake.latitude(),
        "longitude": fake.longitude()
    }
    
    # Validate all fields present
    assert all(value is not None for value in user_profile.values())
    assert all(len(str(value)) > 0 for value in user_profile.values())
    
    print(f"âœ… Complete user profile created!")
    print(f"   Name: {user_profile['full_name']}")
    print(f"   Address: {user_profile['address_line1']}")
    print(f"   City: {user_profile['city']}, {user_profile['state']}")


def test_international_addresses():
    """Test that addresses work for different locales."""
    # US Faker (default)
    fake_us = Faker('en_US')
    us_address = fake_us.address()
    us_state = fake_us.state()
    
    assert isinstance(us_address, str)
    assert isinstance(us_state, str)
    
    print(f"âœ… International addresses work!")
    print(f"   US: {us_address.split(chr(10))[0]}")


def test_generate_test_data_set():
    """Test generating a complete test data set."""
    fake = Faker()
    
    # Generate 5 complete user addresses
    test_users = []
    for i in range(5):
        user = {
            "id": i + 1,
            "name": fake.name(),
            "street": fake.street_address(),
            "city": fake.city(),
            "state": fake.state_abbr(),
            "zip": fake.zipcode()
        }
        test_users.append(user)
    
    assert len(test_users) == 5
    
    # All users should have unique names (probably)
    names = [u["name"] for u in test_users]
    assert len(set(names)) >= 4
    
    print(f"âœ… Generated {len(test_users)} test users!")
    for user in test_users[:3]:
        print(f"   {user['name']} - {user['city']}, {user['state']}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run example
python examples/names_and_addresses.py

# Run tests
pytest tests/test_names_addresses.py -v -s
```

### Expected Result

```
ğŸ“ BASIC NAMES:
Full name: Jennifer Martinez
First name: Michael
Last name: Johnson

tests/test_names_addresses.py::test_basic_names PASSED
âœ… Basic names generated!
   Full: Emily Chen
   First: Sarah
   Last: Anderson

======================== 15 passed in 0.89s =========================
```

---

## D. Common Patterns

### Pattern 1: Complete User Profile
```python
fake = Faker()

user = {
    "name": fake.name(),
    "address": fake.street_address(),
    "city": fake.city(),
    "state": fake.state_abbr(),
    "zipcode": fake.zipcode()
}
```

### Pattern 2: Formatted Address
```python
address = f"{fake.street_address()}\n{fake.city()}, {fake.state_abbr()} {fake.zipcode()}"
```

### Pattern 3: International Name
```python
fake_fr = Faker('fr_FR')
french_name = fake_fr.name()
```

---

## E. What You've Learned

âœ… Generating basic names (first, last, full)  
âœ… Gender-specific names  
âœ… Name prefixes and suffixes  
âœ… Address components (street, city, state)  
âœ… Complete addresses  
âœ… Geographic coordinates  
âœ… Building structured addresses  
âœ… Generating test data sets  

---

## F. What's Next?

In **Lesson 4.4 (Generating Emails and Phone Numbers)**, we'll explore:
- Different email formats
- Safe vs free emails
- Phone number formats
- International phone numbers

Your test data is getting more realistic! ğŸ‰

---

**Ready for the next lesson?**
