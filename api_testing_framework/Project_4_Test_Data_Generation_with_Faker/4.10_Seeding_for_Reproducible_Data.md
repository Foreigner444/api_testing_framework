# 4.10 Seeding for Reproducible Data

## A. Concept Overview

### What & Why
By default, Faker generates random data that's different every time. But sometimes you need **reproducible data** â€“ the same fake values on every test run for debugging, snapshot testing, or consistent test environments. **Seeding** lets you control Faker's randomness, making it predictable when needed.

### Analogy
Think of seeding like **using a specific shuffle for a deck of cards**.

**Without seeding** (random):
- Shuffle cards â†’ get random order every time
- Useful for variety, but can't reproduce results

**With seeding** (reproducible):
- Use shuffle algorithm #12345 â†’ always get same card order
- Same results every time â†’ perfect for debugging

Same deck, but predictable when you need it!

---

## B. Code Implementation

### File Path: `examples/seeding_demo.py`

```python
"""Demonstration of Faker seeding for reproducible data."""
from faker import Faker

print("=" * 70)
print("SEEDING FOR REPRODUCIBLE DATA")
print("=" * 70)

# ==================== WITHOUT SEEDING ====================
print("\nğŸ² WITHOUT SEEDING (Random every time):")

fake1 = Faker()
print(f"Run 1: {fake1.name()}")

fake2 = Faker()
print(f"Run 2: {fake2.name()}")

fake3 = Faker()
print(f"Run 3: {fake3.name()}")

print("â˜ï¸ Each run produces different names")

# ==================== WITH SEEDING ====================
print("\nğŸ¯ WITH SEEDING (Same every time):")

Faker.seed(12345)
fake_a = Faker()
print(f"Seed 12345, Run 1: {fake_a.name()}")

Faker.seed(12345)
fake_b = Faker()
print(f"Seed 12345, Run 2: {fake_b.name()}")

Faker.seed(12345)
fake_c = Faker()
print(f"Seed 12345, Run 3: {fake_c.name()}")

print("â˜ï¸ All runs produce the SAME name with same seed!")

# ==================== DIFFERENT SEEDS ====================
print("\nğŸ”¢ DIFFERENT SEEDS:")

Faker.seed(11111)
fake_seed1 = Faker()
print(f"Seed 11111: {fake_seed1.name()}")

Faker.seed(22222)
fake_seed2 = Faker()
print(f"Seed 22222: {fake_seed2.name()}")

Faker.seed(33333)
fake_seed3 = Faker()
print(f"Seed 33333: {fake_seed3.name()}")

print("â˜ï¸ Different seeds produce different (but reproducible) data")

# ==================== INSTANCE SEEDING ====================
print("\nğŸ¯ INSTANCE-SPECIFIC SEEDING:")

fake_instance1 = Faker()
fake_instance1.seed_instance(99999)
print(f"Instance 1 (seed 99999): {fake_instance1.name()}")
print(f"Instance 1 again: {fake_instance1.name()}")  # Different from first

fake_instance2 = Faker()
fake_instance2.seed_instance(99999)
print(f"Instance 2 (seed 99999): {fake_instance2.name()}")  # Same as instance1 first call

print("â˜ï¸ seed_instance() only affects that specific instance")

# ==================== GLOBAL VS INSTANCE ====================
print("\nğŸŒ GLOBAL SEED VS INSTANCE SEED:")

# Global seed affects all instances
Faker.seed(0)
global1 = Faker()
global2 = Faker()
print(f"Global seed 0, Instance 1: {global1.name()}")
print(f"Global seed 0, Instance 2: {global2.name()}")

# Reset
Faker.seed(0)
global3 = Faker()
global4 = Faker()
print(f"Reset seed 0, Instance 1: {global3.name()}")  # Same as global1
print(f"Reset seed 0, Instance 2: {global4.name()}")  # Same as global2

print("\n" + "=" * 70)
```

---

### File Path: `tests/test_seeding.py`

```python
"""Tests for Faker seeding functionality."""
import pytest
from faker import Faker


def test_seeding_produces_same_data():
    """Test that seeding produces reproducible data."""
    # First run with seed
    Faker.seed(12345)
    fake1 = Faker()
    name1 = fake1.name()
    email1 = fake1.email()
    
    # Second run with same seed
    Faker.seed(12345)
    fake2 = Faker()
    name2 = fake2.name()
    email2 = fake2.email()
    
    # Should produce identical data
    assert name1 == name2
    assert email1 == email2
    
    print(f"âœ… Seeding produces same data!")
    print(f"   Both runs: {name1} ({email1})")


def test_different_seeds_different_data():
    """Test that different seeds produce different data."""
    # Seed 1
    Faker.seed(11111)
    fake1 = Faker()
    name1 = fake1.name()
    
    # Seed 2
    Faker.seed(22222)
    fake2 = Faker()
    name2 = fake2.name()
    
    # Should be different
    assert name1 != name2
    
    print(f"âœ… Different seeds, different data!")
    print(f"   Seed 11111: {name1}")
    print(f"   Seed 22222: {name2}")


def test_seed_zero():
    """Test that seed 0 is valid."""
    Faker.seed(0)
    fake = Faker()
    
    name = fake.name()
    
    # Should work fine
    assert isinstance(name, str)
    assert len(name) > 0
    
    print(f"âœ… Seed 0 works: {name}")


def test_instance_seeding():
    """Test instance-specific seeding."""
    # Create two instances with same seed
    fake1 = Faker()
    fake1.seed_instance(99999)
    
    fake2 = Faker()
    fake2.seed_instance(99999)
    
    # First call should be same
    assert fake1.name() == fake2.name()
    
    # But they continue independently
    name1_second = fake1.name()
    name2_second = fake2.name()
    
    # Second calls might differ
    print(f"âœ… Instance seeding works!")
    print(f"   Instance 1: {name1_second}")
    print(f"   Instance 2: {name2_second}")


def test_global_seed_affects_all():
    """Test that global seed affects all instances."""
    # Set global seed
    Faker.seed(11111)
    
    fake1 = Faker()
    fake2 = Faker()
    
    name1 = fake1.name()
    
    # Reset global seed
    Faker.seed(11111)
    
    fake3 = Faker()
    name3 = fake3.name()
    
    # Should be same
    assert name1 == name3
    
    print(f"âœ… Global seed affects all: {name1}")


def test_reproducible_test_data_set():
    """Test creating reproducible test data set."""
    def generate_users(seed: int, count: int):
        """Generate users with specific seed."""
        Faker.seed(seed)
        fake = Faker()
        
        return [
            {
                "name": fake.name(),
                "email": fake.email(),
                "phone": fake.phone_number()
            }
            for _ in range(count)
        ]
    
    # Generate with seed 100
    users1 = generate_users(seed=100, count=5)
    
    # Generate again with same seed
    users2 = generate_users(seed=100, count=5)
    
    # Should be identical
    assert users1 == users2
    
    # Generate with different seed
    users3 = generate_users(seed=200, count=5)
    
    # Should be different
    assert users1 != users3
    
    print(f"âœ… Reproducible data sets!")
    print(f"   Seed 100: {users1[0]['name']}")
    print(f"   Seed 200: {users3[0]['name']}")


# ==================== PRACTICAL USE CASES ====================

def test_debugging_with_seed():
    """Test using seed for debugging failing tests."""
    # When a test fails with random data, use seed to reproduce
    
    def test_with_random_data(seed=None):
        """Simulate a test that might fail."""
        if seed is not None:
            Faker.seed(seed)
        
        fake = Faker()
        
        name = fake.name()
        age = fake.random_int(18, 80)
        
        # Simulate business logic
        is_valid = len(name) > 0 and 18 <= age <= 80
        
        return is_valid, name, age
    
    # First run - random
    result1, name1, age1 = test_with_random_data()
    
    # If test failed, use seed to reproduce
    if not result1:
        # Reproduce with same seed
        result2, name2, age2 = test_with_random_data(seed=12345)
        assert name1 != name2  # Different because different seeds
    
    # Run with specific seed
    result_seeded, name_seeded, age_seeded = test_with_random_data(seed=12345)
    
    print(f"âœ… Debugging with seed!")
    print(f"   Random: {name1} (age {age1})")
    print(f"   Seeded: {name_seeded} (age {age_seeded})")


def test_snapshot_testing_with_seed():
    """Test snapshot testing with seeded data."""
    def generate_api_response(seed: int):
        """Generate consistent API response for snapshot."""
        Faker.seed(seed)
        fake = Faker()
        
        return {
            "users": [
                {
                    "id": i,
                    "name": fake.name(),
                    "email": fake.email()
                }
                for i in range(1, 4)
            ]
        }
    
    # Generate snapshot
    snapshot = generate_api_response(seed=100)
    
    # Regenerate with same seed
    regenerated = generate_api_response(seed=100)
    
    # Should match exactly
    assert snapshot == regenerated
    
    print(f"âœ… Snapshot testing works with seed!")


def test_consistent_fixtures_with_seed():
    """Test creating consistent test fixtures."""
    @pytest.fixture
    def test_users():
        """Fixture that returns same users every time."""
        Faker.seed(42)
        fake = Faker()
        
        return [
            {
                "name": fake.name(),
                "email": fake.email()
            }
            for _ in range(3)
        ]
    
    # Use fixture
    users1 = test_users()
    users2 = test_users()
    
    # Should be identical
    assert users1 == users2
    
    print(f"âœ… Consistent fixtures: {users1[0]['name']}")


def test_seed_in_ci_environment():
    """Test using seed in CI for consistent builds."""
    import os
    
    # In CI, you might set a seed via environment variable
    ci_seed = int(os.getenv("FAKER_SEED", "12345"))
    
    Faker.seed(ci_seed)
    fake = Faker()
    
    name = fake.name()
    
    # With same seed in CI, you get same data every build
    assert isinstance(name, str)
    
    print(f"âœ… CI seed ({ci_seed}): {name}")


# ==================== SEED STRATEGIES ====================

def test_daily_seed():
    """Test using daily seed for variety but reproducibility within day."""
    from datetime import date
    
    # Use today's date as seed
    today = date.today()
    daily_seed = int(today.strftime("%Y%m%d"))
    
    Faker.seed(daily_seed)
    fake = Faker()
    
    name = fake.name()
    
    # Same name all day, different name tomorrow
    print(f"âœ… Daily seed ({daily_seed}): {name}")


def test_test_specific_seed():
    """Test using test-specific seeds."""
    def test_with_seed(test_name: str):
        """Each test gets its own seed based on name."""
        # Hash test name to get consistent seed
        seed = hash(test_name) % (2**32)
        
        Faker.seed(seed)
        fake = Faker()
        
        return fake.name()
    
    # Same test name = same data
    name1 = test_with_seed("test_user_registration")
    name2 = test_with_seed("test_user_registration")
    assert name1 == name2
    
    # Different test name = different data
    name3 = test_with_seed("test_user_login")
    assert name1 != name3
    
    print(f"âœ… Test-specific seeds!")
    print(f"   Registration test: {name1}")
    print(f"   Login test: {name3}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run example
python examples/seeding_demo.py

# Run tests
pytest tests/test_seeding.py -v -s

# Set seed via environment
FAKER_SEED=12345 pytest tests/test_seeding.py -v -s
```

### Expected Result

```
ğŸ² WITHOUT SEEDING:
Run 1: Jennifer Martinez
Run 2: Michael Johnson
Run 3: Sarah Anderson

ğŸ¯ WITH SEEDING:
Seed 12345, Run 1: Ashley Martinez
Seed 12345, Run 2: Ashley Martinez
Seed 12345, Run 3: Ashley Martinez

tests/test_seeding.py::test_seeding_produces_same_data PASSED
âœ… Seeding produces same data!

======================== 11 passed in 0.65s =========================
```

---

## D. When to Use Seeding

| Use Case | Seed? | Why |
|----------|-------|-----|
| **Unit tests** | âœ… Yes | Reproducible failures |
| **Snapshot tests** | âœ… Yes | Consistent snapshots |
| **Debugging** | âœ… Yes | Reproduce exact failure |
| **CI/CD** | âœ… Yes | Consistent builds |
| **Load testing** | âŒ No | Need variety |
| **Exploratory testing** | âŒ No | Find edge cases |
| **Local development** | âŒ Usually No | Want variety |

---

## E. Seeding Strategies

### Strategy 1: Global Seed
```python
# Seed once for entire test suite
Faker.seed(12345)
```

### Strategy 2: Per-Test Seed
```python
@pytest.fixture(autouse=True)
def seed_faker():
    """Seed Faker before each test."""
    Faker.seed(42)
```

### Strategy 3: Environment-Based Seed
```python
import os
seed = int(os.getenv("FAKER_SEED", "0"))
if seed:
    Faker.seed(seed)
```

### Strategy 4: Date-Based Seed
```python
from datetime import date
daily_seed = int(date.today().strftime("%Y%m%d"))
Faker.seed(daily_seed)
```

---

## F. What You've Learned

âœ… Seeding Faker for reproducible data  
âœ… Global vs instance seeding  
âœ… `Faker.seed()` for all instances  
âœ… `seed_instance()` for specific instance  
âœ… When to seed vs when to randomize  
âœ… Debugging with consistent data  
âœ… Snapshot testing with seeds  
âœ… CI/CD seeding strategies  
âœ… Daily and test-specific seeds  

---

## G. What's Next?

In **Lesson 4.11 (Combining Faker with Pydantic)** ğŸŒŸ, we'll learn:
- Generating Pydantic model instances with Faker
- Type-safe fake data
- Validation with generated data
- **This is where everything comes together!**

You control randomness now! ğŸ‰

---

**Ready for the next lesson?**
