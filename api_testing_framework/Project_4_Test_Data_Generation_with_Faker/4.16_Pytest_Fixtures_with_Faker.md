# 4.16 Pytest Fixtures with Faker

## A. Concept Overview

### What & Why
**Pytest fixtures** combined with Faker create reusable test data that's automatically available to your tests. Instead of generating data in every test, fixtures provide it automatically, making tests cleaner and more focused on the actual testing logic.

### Analogy
Think of pytest fixtures with Faker like **a catering service for your tests**.

**Without fixtures**:
- Each test prepares its own food (generates data)
- Repetitive, time-consuming
- Inconsistent preparation

**With fixtures**:
- Catering service prepares food (fixture generates data)
- Tests just consume it
- Consistent, professional, effortless

Fixtures serve your tests exactly what they need!

---

## B. Code Implementation

### File Path: `conftest.py`

```python
"""Pytest fixtures with Faker for test data generation."""
import pytest
import httpx
from faker import Faker
from typing import List
from factories.user_factory import UserFactory
from factories.product_factory import ProductFactory
from factories.order_factory import OrderFactory


# ==================== Faker Instance Fixture ====================

@pytest.fixture
def fake():
    """Provide a Faker instance to tests."""
    return Faker()


@pytest.fixture
def fake_seeded():
    """Provide a seeded Faker instance for reproducible tests."""
    Faker.seed(12345)
    return Faker()


# ==================== Simple Data Fixtures ====================

@pytest.fixture
def fake_name(fake):
    """Provide a fake name."""
    return fake.name()


@pytest.fixture
def fake_email(fake):
    """Provide a fake email."""
    return fake.email()


@pytest.fixture
def fake_address(fake):
    """Provide a fake address."""
    return {
        "street": fake.street_address(),
        "city": fake.city(),
        "state": fake.state_abbr(),
        "zipcode": fake.zipcode()
    }


# ==================== Model Instance Fixtures ====================

@pytest.fixture
def user(fake):
    """Provide a fake User instance."""
    return UserFactory.create()


@pytest.fixture
def admin_user():
    """Provide an admin user."""
    return UserFactory.create_admin()


@pytest.fixture
def inactive_user():
    """Provide an inactive user."""
    return UserFactory.create_inactive()


@pytest.fixture
def product():
    """Provide a fake Product instance."""
    return ProductFactory.create()


@pytest.fixture
def order():
    """Provide a fake Order instance."""
    return OrderFactory.create()


# ==================== Collection Fixtures ====================

@pytest.fixture
def users(fake):
    """Provide a list of fake users."""
    return UserFactory.create_batch(5)


@pytest.fixture
def products():
    """Provide a list of fake products."""
    return ProductFactory.create_batch(10)


@pytest.fixture
def orders():
    """Provide a list of fake orders."""
    return OrderFactory.create_batch(5)


# ==================== Parametrized Fixture ====================

@pytest.fixture(params=[1, 5, 10])
def users_variable_count(request):
    """Provide variable number of users."""
    count = request.param
    return UserFactory.create_batch(count)


# ==================== httpx Client Fixtures ====================

@pytest.fixture
def http_client():
    """Provide httpx client."""
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        yield client


@pytest.fixture
async def async_http_client():
    """Provide async httpx client."""
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        yield client


# ==================== Combined Fixtures ====================

@pytest.fixture
def user_with_posts(user, fake):
    """Provide a user with fake posts."""
    posts = [
        {
            "title": fake.sentence(),
            "body": fake.text(),
            "userId": user.id
        }
        for _ in range(3)
    ]
    
    return {
        "user": user,
        "posts": posts
    }


@pytest.fixture
def complete_test_data():
    """Provide complete test dataset."""
    return {
        "users": UserFactory.create_batch(3),
        "products": ProductFactory.create_batch(5),
        "orders": OrderFactory.create_batch(2)
    }


# ==================== Session-Scoped Fixtures ====================

@pytest.fixture(scope="session")
def faker_session():
    """Session-scoped Faker instance (created once per test session)."""
    return Faker()


@pytest.fixture(scope="session")
def test_users_session():
    """Session-scoped test users (created once, used by all tests)."""
    Faker.seed(99999)  # Reproducible across sessions
    return UserFactory.create_batch(10)


# ==================== Function-Scoped (Default) ====================

@pytest.fixture(scope="function")  # Default scope
def fresh_user():
    """Function-scoped user (new user for each test)."""
    return UserFactory.create()


# ==================== Module-Scoped ====================

@pytest.fixture(scope="module")
def shared_user():
    """Module-scoped user (shared across module tests)."""
    return UserFactory.create()


# ==================== Cleanup Fixtures ====================

@pytest.fixture
def user_with_cleanup(http_client):
    """Provide user and cleanup after test."""
    # Setup: Create user
    user = UserFactory.create()
    
    # Provide to test
    yield user
    
    # Teardown: Cleanup (if needed)
    # In real scenario, you might delete the user from DB or API
    print(f"\nğŸ§¹ Cleanup: User {user.username} test completed")


# ==================== Auto-Use Fixtures ====================

@pytest.fixture(autouse=True)
def reset_faker_seed():
    """Auto-reset Faker seed before each test (optional)."""
    # This runs before every test automatically
    # Uncomment to enable:
    # Faker.seed(0)
    pass


# ==================== Request-Based Fixtures ====================

@pytest.fixture
def user_by_status(request):
    """Provide user based on test parameter."""
    status = getattr(request, 'param', 'active')
    
    if status == 'active':
        return UserFactory.create_active()
    elif status == 'inactive':
        return UserFactory.create_inactive()
    else:
        return UserFactory.create()
```

---

### File Path: `tests/test_fixtures_with_faker.py`

```python
"""Tests using Faker-based pytest fixtures."""
import pytest
import httpx


# ==================== Using Simple Fixtures ====================

def test_with_fake_fixture(fake):
    """Test using the fake fixture."""
    name = fake.name()
    email = fake.email()
    
    assert len(name) > 0
    assert "@" in email
    
    print(f"âœ… Used fake fixture: {name}")


def test_with_fake_name_fixture(fake_name):
    """Test using pre-generated fake name."""
    assert isinstance(fake_name, str)
    assert len(fake_name) > 0
    
    print(f"âœ… Used fake_name fixture: {fake_name}")


def test_with_fake_email_fixture(fake_email):
    """Test using pre-generated fake email."""
    assert "@" in fake_email
    
    print(f"âœ… Used fake_email fixture: {fake_email}")


# ==================== Using Model Fixtures ====================

def test_with_user_fixture(user):
    """Test using user fixture."""
    # User automatically provided by fixture
    assert user.id > 0
    assert "@" in user.email
    
    print(f"âœ… Used user fixture: {user.username}")


def test_with_admin_fixture(admin_user):
    """Test using admin_user fixture."""
    assert admin_user.username == "admin"
    assert admin_user.email == "admin@example.com"
    
    print(f"âœ… Used admin fixture: {admin_user.username}")


def test_with_product_fixture(product):
    """Test using product fixture."""
    assert product.id > 0
    assert product.price > 0
    
    print(f"âœ… Used product fixture: {product.name}")


# ==================== Using Collection Fixtures ====================

def test_with_users_fixture(users):
    """Test using users collection fixture."""
    # 5 users automatically provided
    assert len(users) == 5
    assert all(u.id > 0 for u in users)
    
    print(f"âœ… Used users fixture: {len(users)} users")


def test_with_products_fixture(products):
    """Test using products collection fixture."""
    # 10 products automatically provided
    assert len(products) == 10
    
    print(f"âœ… Used products fixture: {len(products)} products")


# ==================== Parametrized Fixtures ====================

def test_with_variable_users(users_variable_count):
    """Test runs multiple times with different counts."""
    # This test runs 3 times: with 1, 5, and 10 users
    assert len(users_variable_count) in [1, 5, 10]
    
    print(f"âœ… Variable count: {len(users_variable_count)} users")


# ==================== Combined Fixtures ====================

def test_with_user_and_posts(user_with_posts):
    """Test using combined fixture."""
    assert "user" in user_with_posts
    assert "posts" in user_with_posts
    
    user = user_with_posts["user"]
    posts = user_with_posts["posts"]
    
    assert len(posts) == 3
    assert all(p["userId"] == user.id for p in posts)
    
    print(f"âœ… Combined fixture: {user.username} with {len(posts)} posts")


def test_with_complete_data(complete_test_data):
    """Test using complete test data fixture."""
    assert len(complete_test_data["users"]) == 3
    assert len(complete_test_data["products"]) == 5
    assert len(complete_test_data["orders"]) == 2
    
    print(f"âœ… Complete test data fixture!")


# ==================== httpx Client Fixtures ====================

def test_with_http_client(http_client, user):
    """Test using httpx client fixture with user fixture."""
    # Both fixtures automatically provided
    
    request_data = {
        "name": f"{user.first_name} {user.last_name}",
        "email": user.email,
        "username": user.username
    }
    
    response = http_client.post("/users", json=request_data)
    assert response.status_code == 201
    
    print(f"âœ… Used http_client + user fixtures")


@pytest.mark.asyncio
async def test_with_async_client(async_http_client, user):
    """Test using async httpx client fixture."""
    request_data = {
        "name": f"{user.first_name} {user.last_name}",
        "email": user.email
    }
    
    response = await async_http_client.post("/users", json=request_data)
    assert response.status_code == 201
    
    print(f"âœ… Used async_http_client + user fixtures")


# ==================== Scoped Fixtures ====================

def test_session_fixture_1(test_users_session):
    """Test using session-scoped fixture (run 1)."""
    # Same users used across all tests in session
    assert len(test_users_session) == 10
    print(f"âœ… Session fixture (test 1): {len(test_users_session)} users")


def test_session_fixture_2(test_users_session):
    """Test using session-scoped fixture (run 2)."""
    # SAME users as test_session_fixture_1
    assert len(test_users_session) == 10
    print(f"âœ… Session fixture (test 2): {len(test_users_session)} users")


def test_function_fixture_1(fresh_user):
    """Test using function-scoped fixture (run 1)."""
    assert fresh_user.id > 0
    print(f"âœ… Fresh user (test 1): {fresh_user.username}")


def test_function_fixture_2(fresh_user):
    """Test using function-scoped fixture (run 2)."""
    # DIFFERENT user than test_function_fixture_1
    assert fresh_user.id > 0
    print(f"âœ… Fresh user (test 2): {fresh_user.username}")


# ==================== Fixture Composition ====================

def test_multiple_fixtures(user, product, order):
    """Test using multiple fixtures together."""
    # All fixtures automatically provided
    assert user.id > 0
    assert product.id > 0
    assert order.id is not None
    
    print(f"âœ… Multiple fixtures!")
    print(f"   User: {user.username}")
    print(f"   Product: {product.name}")
    print(f"   Order: {order.id}")


def test_fixture_dependencies(user_with_cleanup):
    """Test fixture with cleanup."""
    # Use the user
    assert user_with_cleanup.id > 0
    
    print(f"âœ… User with cleanup: {user_with_cleanup.username}")
    
    # Cleanup happens automatically after test


# ==================== Practical Examples ====================

def test_realistic_api_test_with_fixtures(http_client, user, product):
    """Test realistic API scenario using fixtures."""
    # Create order for user with product
    order_data = {
        "customer_id": user.id,
        "product_id": product.id,
        "quantity": 1,
        "total": float(product.price)
    }
    
    # Fixtures provided everything we need!
    assert user.id > 0
    assert product.id > 0
    
    print(f"âœ… Realistic test with fixtures!")
    print(f"   Customer: {user.username}")
    print(f"   Product: {product.name}")


def test_batch_operations_with_fixtures(http_client, users):
    """Test batch operations using collection fixture."""
    # 5 users automatically provided
    assert len(users) == 5
    
    # Use them in batch API call
    for user in users[:3]:  # Use first 3
        request_data = {
            "name": f"{user.first_name} {user.last_name}",
            "email": user.email
        }
        
        response = http_client.post("/users", json=request_data)
        assert response.status_code == 201
    
    print(f"âœ… Batch with fixtures: processed {3} users")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run tests with fixtures
pytest tests/test_fixtures_with_faker.py -v -s

# Run specific test
pytest tests/test_fixtures_with_faker.py::test_with_user_fixture -v -s

# Show fixture setup
pytest tests/test_fixtures_with_faker.py --setup-show
```

### Expected Result

```
tests/test_fixtures_with_faker.py::test_with_user_fixture PASSED
âœ… Used user fixture: jennifer_martinez

tests/test_fixtures_with_faker.py::test_with_users_fixture PASSED
âœ… Used users fixture: 5 users

tests/test_fixtures_with_faker.py::test_session_fixture_1 PASSED
âœ… Session fixture (test 1): 10 users

tests/test_fixtures_with_faker.py::test_session_fixture_2 PASSED
âœ… Session fixture (test 2): 10 users

======================== 18 passed in 2.34s =========================
```

---

## D. Fixture Scopes

| Scope | Created | Destroyed | Use Case |
|-------|---------|-----------|----------|
| `function` | Before each test | After each test | Fresh data per test (default) |
| `class` | Before class | After class | Shared within test class |
| `module` | Before module | After module | Shared within module |
| `session` | Once per session | End of session | Expensive setup, read-only data |

---

## E. Best Practices

### 1. **Descriptive Fixture Names**
```python
# âœ… Clear
@pytest.fixture
def active_user(): ...

# âŒ Unclear  
@pytest.fixture
def u(): ...
```

### 2. **Use Appropriate Scope**
```python
# Fresh data per test
@pytest.fixture(scope="function")
def user(): ...

# Expensive setup, share across session
@pytest.fixture(scope="session")
def database_connection(): ...
```

### 3. **Compose Fixtures**
```python
@pytest.fixture
def user_with_order(user, order):
    """Combine existing fixtures."""
    return {"user": user, "order": order}
```

---

## F. What You've Learned

âœ… Creating pytest fixtures with Faker  
âœ… Simple data fixtures  
âœ… Model instance fixtures  
âœ… Collection fixtures  
âœ… Fixture scopes (function, module, session)  
âœ… Parametrized fixtures  
âœ… httpx client fixtures  
âœ… Fixture composition  
âœ… Cleanup with yield  
âœ… Auto-use fixtures  

---

## G. What's Next?

In **Lesson 4.17 (Data Builders with Faker)**, we'll learn:
- Builder pattern for test data
- Fluent interfaces
- Complex object construction

Fixtures mastered! ğŸ‰

---

**Ready for the next lesson?**
