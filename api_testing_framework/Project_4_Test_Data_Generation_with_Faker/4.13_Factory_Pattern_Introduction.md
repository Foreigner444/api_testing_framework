# 4.13 Factory Pattern Introduction

## A. Concept Overview

### What & Why
The **Factory Pattern** is a design pattern that provides an interface for creating objects without specifying their exact class. In API testing, factories centralize test data creation, making tests cleaner, more maintainable, and easier to update. Instead of scattering data generation logic throughout tests, you centralize it in reusable factory functions.

### Analogy
Think of the Factory Pattern like **a car factory vs. handcrafting each car**.

**Without Factory Pattern** (scattered creation):
- Test 1: Manually assemble car parts
- Test 2: Manually assemble car parts again
- Test 3: Manually assemble car parts yet again
- Change wheel size? Update 50 tests!

**With Factory Pattern** (centralized):
- Factory knows how to build cars
- Test 1: `car = CarFactory.create()`
- Test 2: `car = CarFactory.create()`
- Test 3: `car = CarFactory.create()`
- Change wheel size? Update factory once!

---

## B. The Problem Without Factories

### File Path: `tests/test_without_factory.py`

```python
"""Tests without factory pattern - repetitive and unmaintainable."""
import httpx
from pydantic import BaseModel, EmailStr
from faker import Faker

fake = Faker()


class User(BaseModel):
    name: str
    email: EmailStr
    age: int


def test_create_user_1():
    """Test 1 - manually creating user data."""
    # Manually create user data
    user_data = {
        "name": fake.name(),
        "email": fake.email(),
        "age": fake.random_int(18, 80)
    }
    user = User.model_validate(user_data)
    assert user.age >= 18
    

def test_create_user_2():
    """Test 2 - duplicating the same creation logic."""
    # Copy-paste from test_create_user_1
    user_data = {
        "name": fake.name(),
        "email": fake.email(),
        "age": fake.random_int(18, 80)
    }
    user = User.model_validate(user_data)
    assert "@" in user.email


def test_create_user_3():
    """Test 3 - more duplication."""
    # Copy-paste again!
    user_data = {
        "name": fake.name(),
        "email": fake.email(),
        "age": fake.random_int(18, 80)
    }
    user = User.model_validate(user_data)
    assert len(user.name) > 0


# Problem: If we need to add a new field (e.g., "phone"),
# we have to update ALL tests!
# This doesn't scale!
```

---

## C. The Solution: Factory Pattern

### File Path: `factories/user_factory.py`

```python
"""User factory using Factory Pattern."""
from faker import Faker
from typing import Optional
from models.user_models import User, Address, Company

fake = Faker()


# ==================== Simple Factory Function ====================

def create_user(**overrides) -> User:
    """Factory function to create a User.
    
    Args:
        **overrides: Override any field with custom value
    
    Returns:
        Validated User instance
    """
    # Default data using Faker
    user_data = {
        "id": fake.random_int(1, 10000),
        "username": fake.user_name(),
        "email": fake.email(),
        "first_name": fake.first_name(),
        "last_name": fake.last_name(),
        "phone": fake.phone_number(),
        "date_of_birth": fake.date_of_birth(minimum_age=18),
        "address": Address(
            street=fake.street_address(),
            city=fake.city(),
            state=fake.state_abbr(),
            zipcode=fake.zipcode(),
            country="USA"
        ),
        "company": None,
        "bio": None,
        "website": None,
        "is_active": True,
        "created_at": fake.date_time_this_year()
    }
    
    # Apply overrides
    user_data.update(overrides)
    
    # Validate and return
    return User.model_validate(user_data)


# ==================== Class-Based Factory ====================

class UserFactory:
    """Class-based factory for creating Users."""
    
    @staticmethod
    def create(**overrides) -> User:
        """Create a single user."""
        return create_user(**overrides)
    
    @staticmethod
    def create_batch(count: int, **overrides) -> list[User]:
        """Create multiple users."""
        return [create_user(**overrides) for _ in range(count)]
    
    @staticmethod
    def create_active(**overrides) -> User:
        """Create an active user."""
        return create_user(is_active=True, **overrides)
    
    @staticmethod
    def create_inactive(**overrides) -> User:
        """Create an inactive user."""
        return create_user(is_active=False, **overrides)
    
    @staticmethod
    def create_admin(**overrides) -> User:
        """Create an admin user."""
        return create_user(
            username="admin",
            email="admin@example.com",
            **overrides
        )
    
    @staticmethod
    def create_with_company(**overrides) -> User:
        """Create a user with company."""
        company = Company(
            name=fake.company(),
            industry=fake.random_element(["Technology", "Finance", "Healthcare"]),
            website=fake.url()
        )
        return create_user(company=company, **overrides)


# ==================== Sequence Factory ====================

class SequenceUserFactory:
    """Factory with sequential IDs."""
    
    _counter = 0
    
    @classmethod
    def reset(cls):
        """Reset counter to 0."""
        cls._counter = 0
    
    @classmethod
    def create(cls, **overrides) -> User:
        """Create user with sequential ID."""
        cls._counter += 1
        return create_user(id=cls._counter, **overrides)
    
    @classmethod
    def create_batch(cls, count: int, **overrides) -> list[User]:
        """Create batch with sequential IDs."""
        return [cls.create(**overrides) for _ in range(count)]


# ==================== Trait-Based Factory ====================

class TraitUserFactory:
    """Factory with traits (preset configurations)."""
    
    TRAITS = {
        "admin": {
            "username": "admin",
            "email": "admin@example.com",
            "is_active": True
        },
        "inactive": {
            "is_active": False
        },
        "verified": {
            "is_active": True
        },
        "unverified": {
            "is_active": False
        }
    }
    
    @classmethod
    def create(cls, trait: Optional[str] = None, **overrides):
        """Create user with optional trait."""
        trait_data = cls.TRAITS.get(trait, {}) if trait else {}
        
        # Merge: trait_data < overrides (overrides win)
        final_data = {**trait_data, **overrides}
        
        return create_user(**final_data)
```

---

### File Path: `tests/test_factory_pattern.py`

```python
"""Tests demonstrating the Factory Pattern."""
import pytest
from factories.user_factory import (
    create_user,
    UserFactory,
    SequenceUserFactory,
    TraitUserFactory
)
from models.user_models import User


# ==================== Simple Factory Tests ====================

def test_create_user_factory():
    """Test basic factory function."""
    user = create_user()
    
    # Should create valid user
    assert isinstance(user, User)
    assert user.id > 0
    assert "@" in user.email
    
    print(f"‚úÖ Factory created user: {user.username}")


def test_factory_with_overrides():
    """Test factory with custom values."""
    user = create_user(
        username="testuser",
        email="test@example.com",
        age=25
    )
    
    # Custom values used
    assert user.username == "testuser"
    assert user.email == "test@example.com"
    
    # Other fields still generated
    assert len(user.first_name) > 0
    
    print(f"‚úÖ Factory with overrides: {user.username}")


# ==================== Class Factory Tests ====================

def test_user_factory_create():
    """Test UserFactory.create()."""
    user = UserFactory.create()
    
    assert isinstance(user, User)
    print(f"‚úÖ UserFactory.create(): {user.username}")


def test_user_factory_batch():
    """Test creating batch of users."""
    users = UserFactory.create_batch(10)
    
    assert len(users) == 10
    assert all(isinstance(u, User) for u in users)
    
    # All should be valid
    assert all(u.id > 0 for u in users)
    
    print(f"‚úÖ Created batch of {len(users)} users!")


def test_user_factory_presets():
    """Test preset factory methods."""
    # Active user
    active = UserFactory.create_active()
    assert active.is_active is True
    
    # Inactive user
    inactive = UserFactory.create_inactive()
    assert inactive.is_active is False
    
    # Admin user
    admin = UserFactory.create_admin()
    assert admin.username == "admin"
    assert admin.email == "admin@example.com"
    
    # User with company
    with_company = UserFactory.create_with_company()
    assert with_company.company is not None
    assert len(with_company.company.name) > 0
    
    print(f"‚úÖ All presets work!")
    print(f"   Admin: {admin.username}")
    print(f"   With company: {with_company.company.name}")


# ==================== Sequence Factory Tests ====================

def test_sequence_factory():
    """Test sequential ID generation."""
    SequenceUserFactory.reset()
    
    user1 = SequenceUserFactory.create()
    user2 = SequenceUserFactory.create()
    user3 = SequenceUserFactory.create()
    
    # IDs should be sequential
    assert user1.id == 1
    assert user2.id == 2
    assert user3.id == 3
    
    print(f"‚úÖ Sequential IDs: {user1.id}, {user2.id}, {user3.id}")


def test_sequence_factory_batch():
    """Test sequential batch creation."""
    SequenceUserFactory.reset()
    
    users = SequenceUserFactory.create_batch(5)
    
    # IDs should be 1-5
    assert [u.id for u in users] == [1, 2, 3, 4, 5]
    
    print(f"‚úÖ Sequential batch: IDs 1-5")


# ==================== Trait Factory Tests ====================

def test_trait_factory_admin():
    """Test creating user with admin trait."""
    user = TraitUserFactory.create(trait="admin")
    
    assert user.username == "admin"
    assert user.email == "admin@example.com"
    assert user.is_active is True
    
    print(f"‚úÖ Admin trait: {user.username}")


def test_trait_factory_inactive():
    """Test creating user with inactive trait."""
    user = TraitUserFactory.create(trait="inactive")
    
    assert user.is_active is False
    
    print(f"‚úÖ Inactive trait: {user.username} (active={user.is_active})")


def test_trait_with_overrides():
    """Test trait + overrides combination."""
    user = TraitUserFactory.create(
        trait="admin",
        email="custom@example.com"  # Override admin email
    )
    
    # Trait applied
    assert user.username == "admin"
    
    # Override applied (takes precedence)
    assert user.email == "custom@example.com"
    
    print(f"‚úÖ Trait + override: {user.username} ({user.email})")


# ==================== Benefits Demonstration ====================

def test_maintainability():
    """Demonstrate maintainability benefit."""
    # If User model adds a new required field,
    # we only update the factory, not every test!
    
    users = [UserFactory.create() for _ in range(5)]
    
    assert len(users) == 5
    print(f"‚úÖ Maintainability: 5 users created from one factory")


def test_consistency():
    """Demonstrate consistency benefit."""
    # All users created with same pattern
    users = UserFactory.create_batch(10)
    
    # All follow same rules
    assert all(u.id > 0 for u in users)
    assert all(len(u.username) >= 3 for u in users)
    
    print(f"‚úÖ Consistency: All users follow same rules")


def test_reusability():
    """Demonstrate reusability benefit."""
    # Same factory used in different test scenarios
    
    # Scenario 1: Test user creation
    user1 = UserFactory.create()
    assert user1 is not None
    
    # Scenario 2: Test user update
    user2 = UserFactory.create()
    assert user2 is not None
    
    # Scenario 3: Test user deletion
    user3 = UserFactory.create()
    assert user3 is not None
    
    print(f"‚úÖ Reusability: Same factory, multiple scenarios")
```

---

## D. Connect & Apply

### How to Test It

```bash
pytest tests/test_factory_pattern.py -v -s
```

### Expected Result

```
tests/test_factory_pattern.py::test_create_user_factory PASSED
‚úÖ Factory created user: jennifer_martinez

tests/test_factory_pattern.py::test_sequence_factory PASSED
‚úÖ Sequential IDs: 1, 2, 3

tests/test_factory_pattern.py::test_trait_factory_admin PASSED
‚úÖ Admin trait: admin

======================== 15 passed in 0.92s =========================
```

---

## E. Factory Pattern Benefits

| Benefit | Description |
|---------|-------------|
| **DRY** | Don't Repeat Yourself - define once, use everywhere |
| **Maintainable** | Update factory, all tests updated |
| **Consistent** | Same creation logic everywhere |
| **Flexible** | Easy to customize with overrides |
| **Readable** | `UserFactory.create()` is clear |
| **Testable** | Factory itself can be tested |

---

## F. When to Use Factories

### ‚úÖ Use Factories When:
- Creating test data in multiple tests
- Need consistent data structure
- Want easy customization
- Building test fixtures
- Creating complex nested objects

### ‚ö†Ô∏è Don't Need Factories When:
- One-off data creation
- Extremely simple objects
- Test-specific unique data

---

## G. What You've Learned

‚úÖ Factory Pattern fundamentals  
‚úÖ Simple function factories  
‚úÖ Class-based factories  
‚úÖ Sequence factories for IDs  
‚úÖ Trait-based factories  
‚úÖ Factory benefits (DRY, maintainability)  
‚úÖ Override patterns  
‚úÖ Batch creation  

---

## H. What's Next?

In **Lesson 4.14 (Building Data Factories)**, we'll learn:
- Building production-ready factories
- Advanced factory patterns
- Factory organization

You understand the Factory Pattern! üéâ

---

**Ready for the next lesson?**
