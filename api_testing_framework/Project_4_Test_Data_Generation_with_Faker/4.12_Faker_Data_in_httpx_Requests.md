# 4.12 Faker Data in httpx Requests

## A. Concept Overview

### What & Why
This is **the ultimate integration** â€“ using Faker-generated data in real httpx API requests, validated by Pydantic models. This workflow represents production-ready API testing: generate realistic test data, send it via httpx, and validate responses with Pydantic. This is how professional test frameworks work!

### Analogy
Think of the complete workflow like **an assembly line with quality control at every stage**.

1. **Faker** â†’ Raw materials factory (generates data)
2. **Pydantic (request)** â†’ Quality check before shipping (validates request data)
3. **httpx** â†’ Shipping service (sends request to API)
4. **Pydantic (response)** â†’ Quality check on delivery (validates response data)

Each stage ensures quality, creating reliable end-to-end testing!

---

## B. Code Implementation

### File Path: `tests/test_faker_httpx_integration.py`

```python
"""Integration tests using Faker + Pydantic + httpx."""
import httpx
import pytest
from pydantic import BaseModel, EmailStr, Field, ValidationError
from faker import Faker
from typing import Optional, List

fake = Faker()


# ==================== Request/Response Models ====================

class UserCreateRequest(BaseModel):
    """Request model for creating a user."""
    name: str = Field(min_length=1)
    username: str = Field(min_length=3, max_length=20)
    email: EmailStr
    phone: Optional[str] = None
    website: Optional[str] = None


class UserResponse(BaseModel):
    """Response model for user."""
    id: int
    name: str
    username: str
    email: EmailStr
    phone: Optional[str] = None
    website: Optional[str] = None


class PostCreateRequest(BaseModel):
    """Request model for creating a post."""
    title: str = Field(min_length=1, max_length=200)
    body: str = Field(min_length=1)
    userId: int = Field(gt=0)


class PostResponse(BaseModel):
    """Response model for post."""
    id: int
    title: str
    body: str
    userId: int


# ==================== Factory Functions ====================

def create_user_request() -> UserCreateRequest:
    """Create a fake user creation request."""
    return UserCreateRequest(
        name=fake.name(),
        username=fake.user_name(),
        email=fake.email(),
        phone=fake.phone_number() if fake.boolean() else None,
        website=fake.url() if fake.boolean() else None
    )


def create_post_request(user_id: int) -> PostCreateRequest:
    """Create a fake post creation request."""
    return PostCreateRequest(
        title=fake.sentence(nb_words=5).replace(".", ""),
        body=fake.text(max_nb_chars=500),
        userId=user_id
    )


# ==================== Test: POST Request ====================

def test_create_user_with_faker_data():
    """Test creating a user with Faker-generated data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Generate fake user data
    user_request = create_user_request()
    
    # Send POST request
    response = client.post("/users", json=user_request.model_dump())
    
    # JSONPlaceholder returns 201 for create
    assert response.status_code == 201
    
    # Validate response (JSONPlaceholder echoes back + adds ID)
    response_data = response.json()
    assert "id" in response_data
    
    print(f"âœ… Created user via API with Faker data!")
    print(f"   Request: {user_request.username} ({user_request.email})")
    print(f"   Response ID: {response_data.get('id')}")


def test_create_multiple_users_with_faker():
    """Test creating multiple users with different Faker data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    created_users = []
    
    # Create 5 users with fake data
    for i in range(5):
        user_request = create_user_request()
        
        response = client.post("/users", json=user_request.model_dump())
        assert response.status_code == 201
        
        created_users.append({
            "request": user_request,
            "response": response.json()
        })
    
    assert len(created_users) == 5
    
    # All should have unique usernames (probably)
    usernames = [u["request"].username for u in created_users]
    assert len(set(usernames)) >= 4
    
    print(f"âœ… Created {len(created_users)} users with Faker!")
    for i, user in enumerate(created_users[:3], 1):
        print(f"   {i}. {user['request'].username}")


def test_create_post_with_faker_data():
    """Test creating a post with Faker-generated content."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Generate fake post data
    post_request = create_post_request(user_id=1)
    
    # Send POST request
    response = client.post("/posts", json=post_request.model_dump())
    
    assert response.status_code == 201
    
    # Validate response
    response_data = response.json()
    assert "id" in response_data
    
    print(f"âœ… Created post via API with Faker data!")
    print(f"   Title: {post_request.title}")
    print(f"   Body length: {len(post_request.body)} chars")


# ==================== Test: PUT Request ====================

def test_update_user_with_faker_data():
    """Test updating a user with Faker-generated data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Generate new fake data for update
    update_request = create_user_request()
    
    # Send PUT request
    response = client.put("/users/1", json=update_request.model_dump())
    
    assert response.status_code == 200
    
    print(f"âœ… Updated user with Faker data!")
    print(f"   New username: {update_request.username}")


# ==================== Test: PATCH Request ====================

def test_partial_update_with_faker():
    """Test partial update (PATCH) with Faker data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Generate partial update data
    partial_update = {
        "email": fake.email(),
        "phone": fake.phone_number()
    }
    
    response = client.patch("/users/1", json=partial_update)
    
    assert response.status_code == 200
    
    print(f"âœ… Partial update with Faker!")
    print(f"   New email: {partial_update['email']}")


# ==================== Complex Workflow ====================

def test_complete_user_workflow():
    """Test complete workflow: create, read, update with Faker."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Step 1: Create user with Faker data
    create_request = create_user_request()
    create_response = client.post("/users", json=create_request.model_dump())
    assert create_response.status_code == 201
    
    user_id = create_response.json().get("id", 1)
    
    # Step 2: Read created user
    get_response = client.get(f"/users/{user_id}")
    assert get_response.status_code == 200
    
    # Step 3: Update with new Faker data
    update_request = create_user_request()
    update_response = client.put(f"/users/{user_id}", json=update_request.model_dump())
    assert update_response.status_code == 200
    
    print(f"âœ… Complete workflow with Faker!")
    print(f"   Created: {create_request.username}")
    print(f"   Updated to: {update_request.username}")


def test_user_creates_posts_workflow():
    """Test user creating multiple posts with Faker."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    user_id = 1
    
    # Create 3 posts with fake data
    created_posts = []
    for i in range(3):
        post_request = create_post_request(user_id=user_id)
        response = client.post("/posts", json=post_request.model_dump())
        
        if response.status_code == 201:
            created_posts.append(post_request)
    
    assert len(created_posts) == 3
    
    # All posts should have different titles
    titles = [p.title for p in created_posts]
    assert len(set(titles)) == 3
    
    print(f"âœ… User created {len(created_posts)} posts!")
    for i, post in enumerate(created_posts, 1):
        print(f"   {i}. {post.title}")


# ==================== Error Handling ====================

def test_invalid_faker_data_caught_by_pydantic():
    """Test that invalid data is caught before sending."""
    # Try to create user with invalid data
    with pytest.raises(ValidationError):
        UserCreateRequest(
            name="",  # Too short! min_length=1 will fail
            username="ab",  # Too short! min_length=3
            email="not-an-email"
        )
    
    print(f"âœ… Pydantic catches invalid data before API call!")


def test_api_error_handling():
    """Test handling API errors with Faker data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Valid request data
    request = create_user_request()
    
    # Try invalid endpoint
    response = client.post("/invalid-endpoint", json=request.model_dump())
    
    # Should get 404
    assert response.status_code == 404
    
    print(f"âœ… Handled API error with Faker data!")


# ==================== Batch Operations ====================

def test_batch_create_with_faker():
    """Test batch creating resources with Faker."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Generate 10 fake users
    user_requests = [create_user_request() for _ in range(10)]
    
    # Send all requests
    responses = []
    for user_req in user_requests:
        response = client.post("/users", json=user_req.model_dump())
        responses.append(response)
    
    # All should succeed
    assert all(r.status_code == 201 for r in responses)
    
    print(f"âœ… Batch created {len(user_requests)} users!")


# ==================== Data-Driven Testing ====================

@pytest.mark.parametrize("execution_number", range(5))
def test_parametrized_with_faker(execution_number):
    """Test parametrized tests with Faker data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Each execution gets different Faker data
    user_request = create_user_request()
    
    response = client.post("/users", json=user_request.model_dump())
    assert response.status_code == 201
    
    print(f"âœ… Execution {execution_number}: {user_request.username}")


# ==================== Realistic Test Scenarios ====================

def test_user_registration_scenario():
    """Test realistic user registration scenario."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # User fills out registration form
    registration_data = UserCreateRequest(
        name=fake.name(),
        username=fake.user_name(),
        email=fake.email(),
        phone=fake.phone_number(),
        website=fake.url()
    )
    
    # Submit registration
    response = client.post("/users", json=registration_data.model_dump())
    
    assert response.status_code == 201
    
    print(f"âœ… User registration scenario!")
    print(f"   User: {registration_data.name}")
    print(f"   Email: {registration_data.email}")


def test_content_creation_scenario():
    """Test content creation with realistic data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Create 5 posts with varied content
    posts = []
    for i in range(5):
        post = create_post_request(user_id=1)
        response = client.post("/posts", json=post.model_dump())
        
        if response.status_code == 201:
            posts.append(post)
    
    assert len(posts) == 5
    
    # Check content variety
    titles = [p.title for p in posts]
    assert len(set(titles)) == 5  # All unique
    
    # Check lengths vary
    lengths = [len(p.body) for p in posts]
    assert min(lengths) != max(lengths)  # Different lengths
    
    print(f"âœ… Content creation scenario!")
    print(f"   Created {len(posts)} posts with varied content")
    print(f"   Body lengths: {min(lengths)}-{max(lengths)} chars")


# ==================== Async Integration ====================

@pytest.mark.asyncio
async def test_async_create_with_faker():
    """Test async API calls with Faker data."""
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        # Generate fake data
        user_request = create_user_request()
        
        # Async POST request
        response = await client.post("/users", json=user_request.model_dump())
        
        assert response.status_code == 201
        
        print(f"âœ… Async create with Faker!")
        print(f"   User: {user_request.username}")


@pytest.mark.asyncio
async def test_async_batch_create_with_faker():
    """Test async batch creation with Faker."""
    import asyncio
    
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        # Generate 10 fake users
        user_requests = [create_user_request() for _ in range(10)]
        
        # Create tasks for concurrent requests
        tasks = [
            client.post("/users", json=req.model_dump())
            for req in user_requests
        ]
        
        # Execute all concurrently
        responses = await asyncio.gather(*tasks)
        
        # All should succeed
        assert all(r.status_code == 201 for r in responses)
        
        print(f"âœ… Async batch created {len(user_requests)} users!")


# ==================== Complete CRUD with Faker ====================

def test_complete_crud_with_faker():
    """Test complete CRUD operations with Faker data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # CREATE
    create_req = create_user_request()
    create_resp = client.post("/users", json=create_req.model_dump())
    assert create_resp.status_code == 201
    user_id = create_resp.json().get("id", 1)
    print(f"âœ… Created user: {create_req.username}")
    
    # READ
    read_resp = client.get(f"/users/{user_id}")
    assert read_resp.status_code == 200
    print(f"âœ… Read user: {user_id}")
    
    # UPDATE
    update_req = create_user_request()
    update_resp = client.put(f"/users/{user_id}", json=update_req.model_dump())
    assert update_resp.status_code == 200
    print(f"âœ… Updated user to: {update_req.username}")
    
    # DELETE
    delete_resp = client.delete(f"/users/{user_id}")
    assert delete_resp.status_code == 200
    print(f"âœ… Deleted user: {user_id}")
    
    print(f"\nâœ… Complete CRUD cycle with Faker data!")


# ==================== Validation Throughout ====================

def test_request_validation_before_send():
    """Test validating request data before sending."""
    # Generate data
    user_data = {
        "name": fake.name(),
        "username": fake.user_name(),
        "email": fake.email(),
        "phone": fake.phone_number()
    }
    
    # Validate with Pydantic BEFORE sending
    user_request = UserCreateRequest.model_validate(user_data)
    
    # Now send validated data
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.post("/users", json=user_request.model_dump())
    
    assert response.status_code == 201
    
    print(f"âœ… Request validated before sending!")


def test_response_validation_after_receive():
    """Test validating response data after receiving."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Send request with Faker data
    request = create_user_request()
    response = client.post("/users", json=request.model_dump())
    
    # Validate response with Pydantic
    # Note: JSONPlaceholder might not return all fields
    try:
        # Try to validate as UserResponse
        response_data = response.json()
        print(f"âœ… Response received: {response_data}")
    except ValidationError as e:
        print(f"â„¹ï¸ Response validation note: {e.error_count()} fields missing/invalid")
    
    print(f"âœ… Response handling demonstrated!")


# ==================== Real-World Pattern ====================

class APIClient:
    """Reusable API client with Faker integration."""
    
    def __init__(self, base_url: str):
        self.client = httpx.Client(base_url=base_url)
    
    def create_user(self, **overrides) -> dict:
        """Create a user with optional overrides."""
        # Generate fake data
        user_data = {
            "name": fake.name(),
            "username": fake.user_name(),
            "email": fake.email(),
            "phone": fake.phone_number()
        }
        
        # Override with custom values
        user_data.update(overrides)
        
        # Validate with Pydantic
        user_request = UserCreateRequest.model_validate(user_data)
        
        # Send request
        response = self.client.post("/users", json=user_request.model_dump())
        response.raise_for_status()
        
        return response.json()
    
    def create_post(self, user_id: int, **overrides) -> dict:
        """Create a post with optional overrides."""
        post_data = {
            "title": fake.sentence(nb_words=5).replace(".", ""),
            "body": fake.text(max_nb_chars=300),
            "userId": user_id
        }
        
        post_data.update(overrides)
        
        post_request = PostCreateRequest.model_validate(post_data)
        
        response = self.client.post("/posts", json=post_request.model_dump())
        response.raise_for_status()
        
        return response.json()


def test_api_client_class():
    """Test reusable API client with Faker integration."""
    api = APIClient("https://jsonplaceholder.typicode.com")
    
    # Create user with fake data
    user = api.create_user()
    assert "id" in user
    
    # Create user with custom email
    user2 = api.create_user(email="custom@example.com")
    
    # Create post for user
    post = api.create_post(user_id=1)
    assert "id" in post
    
    # Create post with custom title
    post2 = api.create_post(user_id=1, title="Custom Title")
    
    print(f"âœ… API client with Faker integration!")
    print(f"   Created users and posts seamlessly!")


# ==================== Edge Cases with Faker ====================

def test_edge_cases_automatic():
    """Test that Faker automatically provides edge cases."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Generate 20 users - Faker provides variety automatically
    for i in range(20):
        user = create_user_request()
        response = client.post("/users", json=user.model_dump())
        
        # All should succeed even with varied data
        assert response.status_code == 201
    
    print(f"âœ… 20 users created with automatic variety!")


def test_different_data_each_run():
    """Test that each test run uses different data."""
    # Generate user
    user1 = create_user_request()
    
    # Generate another
    user2 = create_user_request()
    
    # Should be different (probably)
    assert user1.username != user2.username
    assert user1.email != user2.email
    
    print(f"âœ… Different data each generation!")
    print(f"   User 1: {user1.username}")
    print(f"   User 2: {user2.username}")


# ==================== Performance Testing ====================

def test_load_test_with_faker():
    """Test load testing with Faker-generated data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    import time
    start = time.time()
    
    # Simulate load test: create 50 users
    success_count = 0
    for i in range(50):
        user = create_user_request()
        response = client.post("/users", json=user.model_dump())
        
        if response.status_code == 201:
            success_count += 1
    
    end = time.time()
    duration = end - start
    
    print(f"âœ… Load test complete!")
    print(f"   Successful: {success_count}/50")
    print(f"   Duration: {duration:.2f}s")
    print(f"   Rate: {50/duration:.1f} requests/sec")


# ==================== Real API Pattern ====================

def test_realistic_api_testing_pattern():
    """Demonstrate realistic API testing pattern."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # 1. Generate realistic test data with Faker
    test_user = create_user_request()
    
    # 2. Validate request with Pydantic (already done in factory)
    assert isinstance(test_user, UserCreateRequest)
    
    # 3. Send request with httpx
    response = client.post("/users", json=test_user.model_dump())
    
    # 4. Validate response status
    assert response.status_code in [200, 201]
    
    # 5. Validate response data with Pydantic (if model matches)
    response_data = response.json()
    assert "id" in response_data or "name" in response_data
    
    print(f"âœ… Complete Faker + Pydantic + httpx pattern!")
    print(f"   Generated: {test_user.username}")
    print(f"   Sent via httpx")
    print(f"   Status: {response.status_code}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run all integration tests
pytest tests/test_faker_httpx_integration.py -v -s

# Run specific test
pytest tests/test_faker_httpx_integration.py::test_complete_crud_with_faker -v -s

# Run async tests
pytest tests/test_faker_httpx_integration.py -v -s -k "async"
```

### Expected Result

```
tests/test_faker_httpx_integration.py::test_create_user_with_faker_data PASSED
âœ… Created user via API with Faker data!
   Request: emily_johnson (emily.j@gmail.com)
   Response ID: 11

tests/test_faker_httpx_integration.py::test_complete_crud_with_faker PASSED
âœ… Complete CRUD cycle with Faker data!

tests/test_faker_httpx_integration.py::test_load_test_with_faker PASSED
âœ… Load test complete!
   Successful: 50/50
   Duration: 12.34s
   Rate: 4.0 requests/sec

======================== 23 passed in 15.67s =========================
```

---

## D. The Complete Pattern

```python
# 1. Define Pydantic models
class UserRequest(BaseModel):
    name: str
    email: EmailStr

# 2. Create factory with Faker
def create_fake_user():
    return UserRequest(
        name=fake.name(),
        email=fake.email()
    )

# 3. Use in httpx request
user = create_fake_user()
response = client.post("/users", json=user.model_dump())

# 4. Validate response
response_user = UserResponse.model_validate(response.json())
```

---

## E. Best Practices

### 1. **Validate Before Sending**
```python
# Generate â†’ Validate â†’ Send
request = UserRequest.model_validate(faker_data)
response = client.post("/endpoint", json=request.model_dump())
```

### 2. **Validate After Receiving**
```python
# Receive â†’ Validate
response = client.get("/endpoint")
data = ResponseModel.model_validate(response.json())
```

### 3. **Use model_dump() for JSON**
```python
# âœ… Correct
json=user.model_dump()

# âŒ Wrong
json=user  # Pydantic model, not dict
```

---

## F. What You've Learned

âœ… Using Faker data in httpx requests  
âœ… POST requests with fake data  
âœ… PUT/PATCH updates with Faker  
âœ… Complete CRUD workflows  
âœ… Async requests with Faker  
âœ… Batch operations  
âœ… Request validation before sending  
âœ… Response validation after receiving  
âœ… Reusable API client classes  
âœ… Load testing with varied data  
âœ… **The complete Faker + Pydantic + httpx pattern!**  

---

## G. What's Next?

In **Lesson 4.13 (Factory Pattern Introduction)**, we'll learn:
- Factory design pattern fundamentals
- When and why to use factories
- Organizing factory code

You've mastered the core integration! ğŸ‰

---

**Ready for the next lesson?**
