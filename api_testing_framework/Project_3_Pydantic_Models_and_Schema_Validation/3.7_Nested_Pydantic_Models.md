# 3.7 Nested Pydantic Models

## A. Concept Overview

### What & Why
Real-world APIs return complex, hierarchical data structures. **Nested Pydantic models** allow you to represent and validate these structures by composing smaller models into larger ones. This creates clean, reusable, and maintainable validation logic that mirrors the actual API structure.

### Analogy
Think of nested models like **Russian nesting dolls (Matryoshkas)**.

Each doll contains a smaller doll inside, which contains an even smaller doll, and so on. Similarly:
- A **User** model contains an **Address** model
- The **Address** model contains a **Geo** model (latitude/longitude)
- The **User** model also contains a **Company** model

Each model validates its own level, and Pydantic automatically validates the entire hierarchy!

---

## B. Code Implementation

### File Path: `models/nested_models.py`

```python
"""Demonstrating nested Pydantic models for complex API structures."""
from typing import List, Optional
from datetime import datetime
from pydantic import BaseModel, EmailStr, HttpUrl, Field


# ==================== Simple Nesting ====================

class Coordinates(BaseModel):
    """Geographic coordinates."""
    latitude: float = Field(ge=-90, le=90)
    longitude: float = Field(ge=-180, le=180)


class Address(BaseModel):
    """Address with nested coordinates."""
    street: str
    city: str
    country: str
    postal_code: str
    coordinates: Coordinates  # Nested model


class SimpleUser(BaseModel):
    """User with nested address."""
    id: int
    name: str
    email: EmailStr
    address: Address  # Nested model


# ==================== Deep Nesting ====================

class Geo(BaseModel):
    """Deepest level - geographic location."""
    lat: str
    lng: str


class Address(BaseModel):
    """Middle level - address with geo."""
    street: str
    suite: str
    city: str
    zipcode: str
    geo: Geo  # Nested one level deep


class Company(BaseModel):
    """Company information."""
    name: str
    catchPhrase: str
    bs: str


class User(BaseModel):
    """Top level - user with nested address and company."""
    id: int
    name: str
    username: str
    email: EmailStr
    address: Address  # Nested (which contains Geo)
    phone: str
    website: str
    company: Company  # Also nested


# ==================== Optional Nested Models ====================

class SocialMedia(BaseModel):
    """Optional social media links."""
    twitter: Optional[str] = None
    linkedin: Optional[str] = None
    github: Optional[str] = None


class ContactInfo(BaseModel):
    """Contact information with optional nested social media."""
    email: EmailStr
    phone: str
    social_media: Optional[SocialMedia] = None  # Nested and optional


class Profile(BaseModel):
    """User profile with optional nested contact info."""
    username: str
    bio: Optional[str] = None
    contact: Optional[ContactInfo] = None  # Nested and optional


# ==================== Lists of Nested Models ====================

class Comment(BaseModel):
    """Single comment."""
    id: int
    author: str
    text: str
    created_at: datetime


class Post(BaseModel):
    """Blog post with list of nested comments."""
    id: int
    title: str
    content: str
    author: str
    comments: List[Comment] = Field(default_factory=list)  # List of nested models


# ==================== Nested Models with Relationships ====================

class Author(BaseModel):
    """Author information."""
    id: int
    name: str
    email: EmailStr
    bio: Optional[str] = None


class Category(BaseModel):
    """Post category."""
    id: int
    name: str
    slug: str


class Tag(BaseModel):
    """Post tag."""
    id: int
    name: str


class BlogPost(BaseModel):
    """Complete blog post with multiple nested models."""
    id: int
    title: str
    content: str
    author: Author  # Nested model
    category: Category  # Nested model
    tags: List[Tag] = Field(default_factory=list)  # List of nested models
    comments: List[Comment] = Field(default_factory=list)  # List of nested models
    created_at: datetime
    updated_at: datetime


# ==================== Reusable Nested Models ====================

class Image(BaseModel):
    """Reusable image model."""
    url: HttpUrl
    width: int
    height: int
    alt_text: Optional[str] = None


class Product(BaseModel):
    """Product with nested images."""
    id: int
    name: str
    description: str
    price: float
    images: List[Image] = Field(default_factory=list)  # Reusable nested model


class User(BaseModel):
    """User with nested avatar image."""
    id: int
    username: str
    email: EmailStr
    avatar: Optional[Image] = None  # Same Image model reused


# ==================== Complex E-Commerce Example ====================

class Money(BaseModel):
    """Money with currency."""
    amount: float = Field(ge=0)
    currency: str = Field(pattern="^[A-Z]{3}$")  # ISO 4217 currency code


class Discount(BaseModel):
    """Discount information."""
    code: str
    percentage: float = Field(ge=0, le=100)
    amount: Money


class ShippingAddress(BaseModel):
    """Shipping address."""
    recipient: str
    street: str
    city: str
    state: str
    postal_code: str
    country: str
    phone: str


class OrderItem(BaseModel):
    """Single item in an order."""
    product_id: int
    product_name: str
    quantity: int = Field(gt=0)
    unit_price: Money
    total_price: Money


class PaymentMethod(BaseModel):
    """Payment method details."""
    type: str  # "credit_card", "paypal", etc.
    last_four: Optional[str] = None
    brand: Optional[str] = None


class Order(BaseModel):
    """Complete order with deeply nested models."""
    id: str
    customer_id: int
    items: List[OrderItem]  # List of nested models
    subtotal: Money
    discount: Optional[Discount] = None  # Optional nested
    shipping_cost: Money
    tax: Money
    total: Money
    shipping_address: ShippingAddress  # Nested
    payment_method: PaymentMethod  # Nested
    status: str
    created_at: datetime
    updated_at: datetime


# ==================== Self-Referencing Models ====================

class TreeNode(BaseModel):
    """Tree node that can contain other tree nodes."""
    id: int
    value: str
    children: List['TreeNode'] = Field(default_factory=list)  # Self-reference!


# Tell Pydantic to resolve the forward reference
TreeNode.model_rebuild()


class MenuItem(BaseModel):
    """Menu item that can have sub-menus."""
    id: int
    label: str
    url: Optional[str] = None
    sub_items: List['MenuItem'] = Field(default_factory=list)  # Self-reference


MenuItem.model_rebuild()
```

---

## C. Testing Nested Models

### File Path: `tests/test_nested_models.py`

```python
"""Tests demonstrating nested Pydantic model validation."""
import httpx
import pytest
from datetime import datetime
from pydantic import ValidationError

from models.nested_models import (
    SimpleUser,
    Address,
    Coordinates,
    User,
    Profile,
    SocialMedia,
    ContactInfo,
    BlogPost,
    Author,
    Category,
    Tag,
    Comment,
    Order,
    OrderItem,
    Money,
    ShippingAddress,
    PaymentMethod,
    TreeNode,
    MenuItem,
)


def test_simple_nesting():
    """Test simple nested model."""
    user_data = {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com",
        "address": {
            "street": "123 Main St",
            "city": "Boston",
            "country": "USA",
            "postal_code": "02101",
            "coordinates": {
                "latitude": 42.3601,
                "longitude": -71.0589
            }
        }
    }
    
    user = SimpleUser.model_validate(user_data)
    
    # Access nested fields with dot notation
    assert user.name == "John Doe"
    assert user.address.city == "Boston"
    assert user.address.coordinates.latitude == 42.3601
    assert user.address.coordinates.longitude == -71.0589
    
    print("‚úÖ Simple nested model validated!")
    print(f"   User: {user.name}")
    print(f"   Location: {user.address.city}, {user.address.country}")
    print(f"   Coords: ({user.address.coordinates.latitude}, {user.address.coordinates.longitude})")


def test_deep_nesting_from_real_api():
    """Test deeply nested model with real API data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    assert response.status_code == 200
    
    # Parse deeply nested response
    user = User.model_validate(response.json())
    
    # Access all nested levels
    assert user.id == 1
    assert user.name == "Leanne Graham"
    assert user.address.city == "Gwenborough"
    assert user.address.geo.lat == "-37.3159"
    assert user.company.name == "Romaguera-Crona"
    
    print("‚úÖ Deep nesting from real API validated!")
    print(f"   User: {user.name}")
    print(f"   City: {user.address.city}")
    print(f"   Geo: ({user.address.geo.lat}, {user.address.geo.lng})")
    print(f"   Company: {user.company.name}")


def test_optional_nested_models():
    """Test optional nested models."""
    # Without optional nested data
    profile1 = Profile(username="john_doe")
    assert profile1.username == "john_doe"
    assert profile1.contact is None
    
    # With optional nested data
    profile2 = Profile(
        username="jane_doe",
        bio="Software engineer",
        contact={
            "email": "jane@example.com",
            "phone": "+1234567890",
            "social_media": {
                "twitter": "@janedoe",
                "github": "janedoe"
            }
        }
    )
    
    assert profile2.contact.email == "jane@example.com"
    assert profile2.contact.social_media.twitter == "@janedoe"
    assert profile2.contact.social_media.linkedin is None  # Optional within nested
    
    print("‚úÖ Optional nested models work!")


def test_list_of_nested_models():
    """Test list of nested models."""
    post_data = {
        "id": 1,
        "title": "My Post",
        "content": "Post content here",
        "author": "John",
        "comments": [
            {
                "id": 1,
                "author": "Alice",
                "text": "Great post!",
                "created_at": "2024-01-15T10:30:00"
            },
            {
                "id": 2,
                "author": "Bob",
                "text": "Thanks for sharing!",
                "created_at": "2024-01-15T11:00:00"
            }
        ]
    }
    
    post = Post.model_validate(post_data)
    
    assert len(post.comments) == 2
    assert post.comments[0].author == "Alice"
    assert post.comments[1].text == "Thanks for sharing!"
    
    # Iterate over nested models
    for comment in post.comments:
        assert isinstance(comment, Comment)
        assert hasattr(comment, 'author')
    
    print("‚úÖ List of nested models validated!")


def test_complex_blog_post():
    """Test complex model with multiple nested relationships."""
    blog_data = {
        "id": 1,
        "title": "Advanced Pydantic",
        "content": "Learn about nested models...",
        "author": {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com",
            "bio": "Python developer"
        },
        "category": {
            "id": 1,
            "name": "Programming",
            "slug": "programming"
        },
        "tags": [
            {"id": 1, "name": "python"},
            {"id": 2, "name": "pydantic"},
            {"id": 3, "name": "testing"}
        ],
        "comments": [],
        "created_at": "2024-01-15T10:00:00",
        "updated_at": "2024-01-15T10:00:00"
    }
    
    blog = BlogPost.model_validate(blog_data)
    
    assert blog.author.name == "John Doe"
    assert blog.category.slug == "programming"
    assert len(blog.tags) == 3
    assert blog.tags[0].name == "python"
    
    print("‚úÖ Complex blog post with multiple nested models validated!")


def test_ecommerce_order():
    """Test complex e-commerce order with deep nesting."""
    order_data = {
        "id": "ORD-12345",
        "customer_id": 789,
        "items": [
            {
                "product_id": 1,
                "product_name": "Python Book",
                "quantity": 2,
                "unit_price": {"amount": 29.99, "currency": "USD"},
                "total_price": {"amount": 59.98, "currency": "USD"}
            }
        ],
        "subtotal": {"amount": 59.98, "currency": "USD"},
        "shipping_cost": {"amount": 5.00, "currency": "USD"},
        "tax": {"amount": 5.20, "currency": "USD"},
        "total": {"amount": 70.18, "currency": "USD"},
        "shipping_address": {
            "recipient": "John Doe",
            "street": "123 Main St",
            "city": "Boston",
            "state": "MA",
            "postal_code": "02101",
            "country": "USA",
            "phone": "+1234567890"
        },
        "payment_method": {
            "type": "credit_card",
            "last_four": "4242",
            "brand": "Visa"
        },
        "status": "confirmed",
        "created_at": "2024-01-15T10:00:00",
        "updated_at": "2024-01-15T10:00:00"
    }
    
    order = Order.model_validate(order_data)
    
    assert order.id == "ORD-12345"
    assert len(order.items) == 1
    assert order.items[0].product_name == "Python Book"
    assert order.items[0].unit_price.amount == 29.99
    assert order.items[0].unit_price.currency == "USD"
    assert order.shipping_address.city == "Boston"
    assert order.payment_method.brand == "Visa"
    assert order.total.amount == 70.18
    
    print("‚úÖ Complex e-commerce order validated!")
    print(f"   Order ID: {order.id}")
    print(f"   Items: {len(order.items)}")
    print(f"   Total: {order.total.amount} {order.total.currency}")


def test_self_referencing_tree():
    """Test self-referencing model (tree structure)."""
    tree_data = {
        "id": 1,
        "value": "root",
        "children": [
            {
                "id": 2,
                "value": "child1",
                "children": [
                    {"id": 4, "value": "grandchild1", "children": []},
                    {"id": 5, "value": "grandchild2", "children": []}
                ]
            },
            {
                "id": 3,
                "value": "child2",
                "children": []
            }
        ]
    }
    
    tree = TreeNode.model_validate(tree_data)
    
    assert tree.value == "root"
    assert len(tree.children) == 2
    assert tree.children[0].value == "child1"
    assert len(tree.children[0].children) == 2
    assert tree.children[0].children[0].value == "grandchild1"
    
    print("‚úÖ Self-referencing tree structure validated!")


def test_nested_validation_error():
    """Test that validation errors in nested models are clear."""
    invalid_data = {
        "id": 1,
        "name": "John",
        "email": "john@example.com",
        "address": {
            "street": "123 Main St",
            "city": "Boston",
            "country": "USA",
            "postal_code": "02101",
            "coordinates": {
                "latitude": 200,  # Invalid! Must be -90 to 90
                "longitude": -71.0589
            }
        }
    }
    
    with pytest.raises(ValidationError) as exc:
        SimpleUser.model_validate(invalid_data)
    
    errors = exc.value.errors()
    # Error location shows the nested path
    assert errors[0]["loc"] == ("address", "coordinates", "latitude")
    
    print("‚úÖ Nested validation errors show clear path!")
    print(f"   Error location: {errors[0]['loc']}")
    print(f"   Error message: {errors[0]['msg']}")


def test_converting_nested_to_dict():
    """Test converting nested models back to dictionaries."""
    user_data = {
        "id": 1,
        "name": "John",
        "email": "john@example.com",
        "address": {
            "street": "123 Main St",
            "city": "Boston",
            "country": "USA",
            "postal_code": "02101",
            "coordinates": {
                "latitude": 42.3601,
                "longitude": -71.0589
            }
        }
    }
    
    user = SimpleUser.model_validate(user_data)
    
    # Convert back to dictionary
    user_dict = user.model_dump()
    
    assert user_dict["address"]["city"] == "Boston"
    assert user_dict["address"]["coordinates"]["latitude"] == 42.3601
    
    print("‚úÖ Nested models convert back to dicts correctly!")
```

---

## D. Connect & Apply

### How to Test It

```bash
# Run all tests
pytest tests/test_nested_models.py -v

# Run with detailed output
pytest tests/test_nested_models.py -v -s

# Run specific test
pytest tests/test_nested_models.py::test_deep_nesting_from_real_api -v -s
```

### Expected Result

```
tests/test_nested_models.py::test_simple_nesting PASSED
‚úÖ Simple nested model validated!

tests/test_nested_models.py::test_deep_nesting_from_real_api PASSED
‚úÖ Deep nesting from real API validated!

tests/test_nested_models.py::test_list_of_nested_models PASSED
‚úÖ List of nested models validated!

tests/test_nested_models.py::test_ecommerce_order PASSED
‚úÖ Complex e-commerce order validated!

======================== 11 passed in 1.45s =========================
```

---

## E. Common Stumbling Blocks

### Problem 1: Forward References

**Issue:** Self-referencing models need special handling.

```python
# ‚ùå Won't work immediately
class TreeNode(BaseModel):
    children: List['TreeNode']  # Forward reference

# ‚úÖ Need to rebuild after definition
TreeNode.model_rebuild()
```

---

### Problem 2: Accessing Nested Fields

```python
# ‚úÖ Use dot notation
city = user.address.city
lat = user.address.coordinates.latitude

# ‚ùå Don't use dictionary access on models
# city = user["address"]["city"]  # This won't work!
```

---

### Problem 3: Understanding Error Locations

When validation fails in nested models, error location is a tuple:

```python
errors[0]["loc"] == ("address", "coordinates", "latitude")
# Means: user.address.coordinates.latitude is invalid
```

---

## F. Best Practices for Nested Models

### 1. **Keep Models Focused**
Each model should represent one logical entity:
```python
class Address(BaseModel):  # Just address concerns
    ...

class User(BaseModel):  # Just user concerns
    address: Address  # Compose!
```

### 2. **Reuse Models**
Don't duplicate! Define once, use everywhere:
```python
class Image(BaseModel):
    url: HttpUrl
    width: int
    height: int

class Product(BaseModel):
    images: List[Image]  # Reuse

class User(BaseModel):
    avatar: Image  # Reuse same model
```

### 3. **Make Optional What's Optional**
```python
class Profile(BaseModel):
    username: str  # Always required
    bio: Optional[str] = None  # Optional
    contact: Optional[ContactInfo] = None  # Nested AND optional
```

### 4. **Use Descriptive Names**
```python
# ‚úÖ Clear
class ShippingAddress(BaseModel): ...
class BillingAddress(BaseModel): ...

# ‚ùå Ambiguous
class Address1(BaseModel): ...
class Address2(BaseModel): ...
```

---

## G. What You've Learned

‚úÖ Creating nested Pydantic models  
‚úÖ Validating deeply nested structures  
‚úÖ Optional nested models  
‚úÖ Lists of nested models  
‚úÖ Multiple nested relationships  
‚úÖ Self-referencing models (trees, menus)  
‚úÖ Accessing nested fields with dot notation  
‚úÖ Understanding nested validation errors  
‚úÖ Converting nested models to dicts  
‚úÖ Best practices for model composition  

---

## H. What's Next?

In **Lesson 3.8 (Lists and Collections in Models)**, we'll master:
- Validating lists with constraints
- Sets and tuples in Pydantic
- Complex collection patterns
- List comprehensions with models

You can now handle any level of nesting! üéâ

---

**Does that make sense? Let me know if you'd like me to explain it in a different way.**

**Ready for the next lesson, or would you like to practice this a bit more?**
