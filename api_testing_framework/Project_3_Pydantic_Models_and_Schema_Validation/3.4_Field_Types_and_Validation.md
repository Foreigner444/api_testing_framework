# 3.4 Field Types and Validation

## A. Concept Overview

### What & Why
Pydantic supports a rich set of field types beyond basic `str`, `int`, and `bool`. These specialized types automatically validate data format, range, and structure ‚Äì from URLs and dates to UUIDs and JSON objects. Understanding field types transforms your models from simple data containers into powerful validation engines.

### Analogy
Think of field types as **different types of containers with built-in inspectors**.

- A **`str`** field is like a generic box ‚Äì accepts any text
- An **`EmailStr`** field is like a mailbox ‚Äì only accepts properly formatted addresses
- An **`HttpUrl`** field is like a web browser ‚Äì only accepts valid URLs
- A **`datetime`** field is like a calendar ‚Äì only accepts valid dates and times

Each specialized container knows exactly what it should hold and rejects anything else automatically.

---

## B. Code Implementation

Let's explore all the essential Pydantic field types!

### File Path: `models/field_types_demo.py`

```python
"""Comprehensive demonstration of Pydantic field types."""
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Set, Tuple
from uuid import UUID

from pydantic import (
    BaseModel,
    EmailStr,
    HttpUrl,
    IPvAnyAddress,
    Json,
    SecretStr,
    constr,
    conint,
    confloat,
    Field,
)


# ==================== Basic Types ====================

class BasicTypes(BaseModel):
    """Demonstration of basic Python types."""
    # String types
    text: str                    # Any string
    name: constr(min_length=1)  # Non-empty string
    
    # Numeric types
    age: int                     # Any integer
    price: float                 # Any float
    precise_value: Decimal       # Precise decimal (for money!)
    
    # Boolean
    is_active: bool              # True or False
    
    # Bytes
    binary_data: bytes           # Binary data


# ==================== String Validation ====================

class StringTypes(BaseModel):
    """Advanced string validation with constraints."""
    # Constrained strings
    username: constr(
        min_length=3,
        max_length=20,
        pattern=r'^[a-zA-Z0-9_]+$'  # Only alphanumeric and underscore
    )
    
    # Email validation
    email: EmailStr              # Validates email format
    
    # URL validation
    website: HttpUrl             # Validates URL format
    
    # IP address
    ip_address: IPvAnyAddress    # Validates IPv4 or IPv6
    
    # Secret (hidden in logs and repr)
    password: SecretStr          # Masked in output
    
    # Custom pattern
    phone: str = Field(pattern=r'^\+?1?\d{9,15}$')


# ==================== Numeric Validation ====================

class NumericTypes(BaseModel):
    """Numeric types with constraints."""
    # Integer constraints
    age: conint(ge=0, le=150)                # 0 <= age <= 150
    quantity: conint(gt=0)                    # quantity > 0
    score: int = Field(ge=0, le=100)         # 0 <= score <= 100
    
    # Float constraints
    price: confloat(ge=0.0)                   # price >= 0.0
    discount: confloat(ge=0.0, le=1.0)       # 0.0 <= discount <= 1.0
    temperature: float = Field(ge=-273.15)   # Above absolute zero
    
    # Decimal for precise money
    balance: Decimal = Field(decimal_places=2)


# ==================== Date and Time ====================

class DateTimeTypes(BaseModel):
    """Date and time field types."""
    # Date only
    birth_date: date             # YYYY-MM-DD
    
    # Time only
    start_time: time             # HH:MM:SS
    
    # Full datetime
    created_at: datetime         # ISO 8601 format
    updated_at: datetime
    
    # Duration
    duration: timedelta          # Time span


# ==================== Collections ====================

class CollectionTypes(BaseModel):
    """Lists, sets, tuples, and dicts."""
    # Lists (ordered, duplicates allowed)
    tags: List[str]                          # List of strings
    scores: List[int]                        # List of integers
    
    # List with constraints
    top_items: List[str] = Field(min_length=1, max_length=10)
    
    # Sets (unordered, no duplicates)
    unique_tags: Set[str]                    # Automatically deduplicates
    
    # Tuples (fixed-length, ordered)
    coordinates: Tuple[float, float]         # Exactly 2 floats
    rgb_color: Tuple[int, int, int]          # Exactly 3 ints
    
    # Dictionaries
    metadata: Dict[str, Any]                 # String keys, any values
    settings: Dict[str, str]                 # String keys and values


# ==================== Nested and Complex ====================

class Address(BaseModel):
    """Nested address model."""
    street: str
    city: str
    country: str
    postal_code: str


class ComplexTypes(BaseModel):
    """Complex and nested types."""
    # Nested model
    address: Address                         # Full Address object
    
    # List of nested models
    addresses: List[Address]                 # Multiple addresses
    
    # UUID
    user_id: UUID                            # UUID validation
    
    # JSON (parses JSON string to dict)
    raw_json: Json                           # Auto-parses JSON strings
    
    # Path
    file_path: Path                          # File system path
    
    # Any type (no validation)
    flexible_field: Any                      # Accepts anything


# ==================== Enums ====================

class UserRole(str, Enum):
    """User role enumeration."""
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"


class Status(str, Enum):
    """Status enumeration."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"


class EnumTypes(BaseModel):
    """Enum field types."""
    role: UserRole                           # Must be one of the enum values
    status: Status


# ==================== Complete Example ====================

class Product(BaseModel):
    """A complete product model using various field types."""
    # Identifiers
    id: UUID
    sku: constr(min_length=5, max_length=20, pattern=r'^[A-Z0-9-]+$')
    
    # Basic info
    name: constr(min_length=1, max_length=200)
    description: str
    
    # Pricing
    price: Decimal = Field(ge=0, decimal_places=2)
    discount_percent: confloat(ge=0.0, le=100.0) = 0.0
    
    # Inventory
    stock_quantity: conint(ge=0)
    is_available: bool
    
    # Categories and tags
    category: str
    tags: Set[str] = Field(default_factory=set)
    
    # Dates
    created_at: datetime
    updated_at: datetime
    available_from: date
    
    # Media
    images: List[HttpUrl] = Field(max_length=10)
    
    # Metadata
    metadata: Dict[str, Any] = Field(default_factory=dict)
```

---

## C. Testing Field Types

### File Path: `tests/test_field_types.py`

```python
"""Tests demonstrating Pydantic field type validation."""
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from uuid import UUID, uuid4

import pytest
from pydantic import ValidationError

from models.field_types_demo import (
    BasicTypes,
    StringTypes,
    NumericTypes,
    DateTimeTypes,
    CollectionTypes,
    UserRole,
    Status,
    EnumTypes,
    Product,
)


def test_basic_types():
    """Test basic type validation."""
    data = BasicTypes(
        text="Hello World",
        name="John",
        age=30,
        price=99.99,
        precise_value=Decimal("19.99"),
        is_active=True,
        binary_data=b"binary"
    )
    
    assert data.text == "Hello World"
    assert data.age == 30
    assert isinstance(data.precise_value, Decimal)
    print("‚úÖ Basic types validated successfully!")


def test_string_types():
    """Test advanced string validation."""
    data = StringTypes(
        username="john_doe_123",
        email="john@example.com",
        website="https://example.com",
        ip_address="192.168.1.1",
        password="secret123",
        phone="+1234567890"
    )
    
    assert data.username == "john_doe_123"
    assert data.email == "john@example.com"
    # Password is masked
    assert "secret" not in str(data.password)
    print("‚úÖ String types validated successfully!")


def test_invalid_email():
    """Test that invalid emails are rejected."""
    with pytest.raises(ValidationError) as exc:
        StringTypes(
            username="john",
            email="not-an-email",  # Invalid!
            website="https://example.com",
            ip_address="192.168.1.1",
            password="secret",
            phone="+1234567890"
        )
    
    assert "email" in str(exc.value)
    print("‚úÖ Invalid email correctly rejected!")


def test_invalid_url():
    """Test that invalid URLs are rejected."""
    with pytest.raises(ValidationError) as exc:
        StringTypes(
            username="john",
            email="john@example.com",
            website="not-a-url",  # Invalid!
            ip_address="192.168.1.1",
            password="secret",
            phone="+1234567890"
        )
    
    assert "website" in str(exc.value)
    print("‚úÖ Invalid URL correctly rejected!")


def test_numeric_constraints():
    """Test numeric field constraints."""
    # Valid data
    data = NumericTypes(
        age=25,
        quantity=5,
        score=85,
        price=19.99,
        discount=0.15,
        temperature=22.5,
        balance=Decimal("100.50")
    )
    
    assert data.age == 25
    assert data.discount == 0.15
    print("‚úÖ Numeric constraints validated!")


def test_age_out_of_range():
    """Test that age constraints are enforced."""
    with pytest.raises(ValidationError) as exc:
        NumericTypes(
            age=200,  # Too old! Max is 150
            quantity=5,
            score=85,
            price=19.99,
            discount=0.15,
            temperature=22.5,
            balance=Decimal("100.50")
        )
    
    assert "age" in str(exc.value)
    print("‚úÖ Age constraint enforced!")


def test_datetime_types():
    """Test date and time types."""
    data = DateTimeTypes(
        birth_date=date(1990, 1, 15),
        start_time=time(9, 30, 0),
        created_at=datetime.now(),
        updated_at=datetime.now(),
        duration=timedelta(hours=2, minutes=30)
    )
    
    assert data.birth_date.year == 1990
    assert data.start_time.hour == 9
    assert isinstance(data.duration, timedelta)
    print("‚úÖ DateTime types validated!")


def test_collection_types():
    """Test lists, sets, tuples, and dicts."""
    data = CollectionTypes(
        tags=["python", "testing", "api"],
        scores=[85, 90, 78, 92],
        top_items=["item1", "item2"],
        unique_tags=["tag1", "tag2", "tag1"],  # Duplicates removed!
        coordinates=(40.7128, -74.0060),
        rgb_color=(255, 128, 0),
        metadata={"key1": "value1", "key2": 123},
        settings={"theme": "dark", "language": "en"}
    )
    
    assert len(data.tags) == 3
    assert len(data.unique_tags) == 2  # Duplicate "tag1" removed
    assert data.coordinates[0] == 40.7128
    assert data.rgb_color == (255, 128, 0)
    print("‚úÖ Collection types validated!")


def test_enum_types():
    """Test enum validation."""
    data = EnumTypes(
        role=UserRole.ADMIN,
        status=Status.ACTIVE
    )
    
    assert data.role == UserRole.ADMIN
    assert data.status == Status.ACTIVE
    print("‚úÖ Enum types validated!")


def test_invalid_enum():
    """Test that invalid enum values are rejected."""
    with pytest.raises(ValidationError) as exc:
        EnumTypes(
            role="superadmin",  # Not a valid role!
            status="active"
        )
    
    assert "role" in str(exc.value)
    print("‚úÖ Invalid enum correctly rejected!")


def test_complete_product():
    """Test a complete real-world model."""
    product_data = {
        "id": str(uuid4()),
        "sku": "PROD-12345",
        "name": "Awesome Product",
        "description": "This is an awesome product",
        "price": "29.99",
        "discount_percent": 10.0,
        "stock_quantity": 100,
        "is_available": True,
        "category": "Electronics",
        "tags": ["new", "featured", "sale"],
        "created_at": "2024-01-15T10:30:00",
        "updated_at": "2024-01-15T10:30:00",
        "available_from": "2024-01-15",
        "images": [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg"
        ],
        "metadata": {"color": "blue", "size": "medium"}
    }
    
    product = Product.model_validate(product_data)
    
    assert isinstance(product.id, UUID)
    assert product.sku == "PROD-12345"
    assert product.price == Decimal("29.99")
    assert len(product.tags) == 3
    assert product.is_available is True
    
    print("‚úÖ Complete product model validated!")
    print(f"   Product: {product.name}")
    print(f"   Price: ${product.price}")
    print(f"   Stock: {product.stock_quantity}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run all field type tests
pytest tests/test_field_types.py -v

# Run with detailed output
pytest tests/test_field_types.py -v -s
```

### Expected Result

```
tests/test_field_types.py::test_basic_types PASSED
‚úÖ Basic types validated successfully!

tests/test_field_types.py::test_string_types PASSED
‚úÖ String types validated successfully!

tests/test_field_types.py::test_invalid_email PASSED
‚úÖ Invalid email correctly rejected!

tests/test_field_types.py::test_invalid_url PASSED
‚úÖ Invalid URL correctly rejected!

tests/test_field_types.py::test_numeric_constraints PASSED
‚úÖ Numeric constraints validated!

tests/test_field_types.py::test_age_out_of_range PASSED
‚úÖ Age constraint enforced!

tests/test_field_types.py::test_datetime_types PASSED
‚úÖ DateTime types validated!

tests/test_field_types.py::test_collection_types PASSED
‚úÖ Collection types validated!

tests/test_field_types.py::test_enum_types PASSED
‚úÖ Enum types validated!

tests/test_field_types.py::test_invalid_enum PASSED
‚úÖ Invalid enum correctly rejected!

tests/test_field_types.py::test_complete_product PASSED
‚úÖ Complete product model validated!

======================== 11 passed in 0.89s =========================
```

---

## D. Common Stumbling Blocks

### Problem 1: "No module named 'email_validator'"

**What it means:** You're using `EmailStr` without installing the email validation dependency.

**The fix:**
```bash
pip install "pydantic[email]"
```

---

### Problem 2: Type Coercion Confusion

**Issue:** Pydantic automatically converts compatible types:

```python
class Model(BaseModel):
    age: int

# These all work - Pydantic coerces them to int
Model(age=25)      # int -> int ‚úÖ
Model(age="25")    # str -> int ‚úÖ
Model(age=25.0)    # float -> int ‚úÖ
Model(age=25.7)    # float -> int ‚úÖ (truncates to 25)

# This fails - can't coerce
Model(age="abc")   # str -> int ‚ùå ValidationError
```

**Key point:** Pydantic tries to convert, but validates strictly when conversion fails.

---

### Problem 3: constr vs Field

**Both work, choose based on preference:**

```python
# Using constr
username: constr(min_length=3, max_length=20)

# Using Field
username: str = Field(min_length=3, max_length=20)
```

**Modern recommendation:** Use `Field()` ‚Äì it's more flexible and consistent.

---

### Problem 4: Decimal for Money

**Wrong:**
```python
price: float  # Loses precision! 19.99 might become 19.990000000001
```

**Right:**
```python
from decimal import Decimal
price: Decimal  # Exact precision for financial calculations
```

---

## E. Field Type Quick Reference

| Type | Use Case | Example |
|------|----------|---------|
| `str` | Any text | `"hello"` |
| `constr(...)` | Constrained string | `constr(min_length=1)` |
| `EmailStr` | Email addresses | `"user@example.com"` |
| `HttpUrl` | URLs | `"https://example.com"` |
| `int` | Whole numbers | `42` |
| `conint(...)` | Constrained integer | `conint(ge=0, le=100)` |
| `float` | Decimal numbers | `3.14` |
| `Decimal` | **Precise** decimals | `Decimal("19.99")` |
| `bool` | True/False | `True` |
| `date` | Date only | `date(2024, 1, 15)` |
| `datetime` | Date and time | `datetime.now()` |
| `UUID` | Unique identifiers | `uuid4()` |
| `List[T]` | List of type T | `[1, 2, 3]` |
| `Set[T]` | Unique values | `{1, 2, 3}` |
| `Dict[K, V]` | Key-value pairs | `{"key": "value"}` |
| `Enum` | Fixed choices | `UserRole.ADMIN` |

---

## F. What You've Learned

‚úÖ All major Pydantic field types  
‚úÖ String validation with constraints  
‚úÖ Numeric constraints (min, max)  
‚úÖ Date and time handling  
‚úÖ Collections (lists, sets, tuples, dicts)  
‚úÖ Enums for fixed choices  
‚úÖ Type coercion behavior  
‚úÖ When to use Decimal vs float  

---

## G. What's Next?

In **Lesson 3.5 (Required vs Optional Fields)**, we'll master:
- Making fields optional with proper defaults
- The difference between `None` and missing fields
- Using `Field()` for complex default behaviors

You now have a complete toolkit of field types! üéâ

---

**Does that make sense? Let me know if you'd like me to explain it in a different way.**

**Ready for the next lesson, or would you like to practice this a bit more?**
