# 3.15 JSON Schema Generation

## A. Concept Overview

### What & Why
Pydantic can automatically generate **JSON Schemas** from your models. JSON Schema is a standard way to describe data structures, used for API documentation, validation, and OpenAPI specifications. Instead of manually writing schemas, Pydantic generates them from your validated code!

### Analogy
Think of JSON Schema like **architectural blueprints auto-generated from a building**.

Instead of:
1. Building a house
2. Manually drawing blueprints afterward (error-prone!)

You:
1. Define the house plan once (Pydantic model)
2. Automatically generate blueprints (JSON Schema)
3. Use blueprints for documentation, validation, and communication

One source of truth, multiple uses!

---

## B. Code Implementation

### File Path: `examples/schema_generation.py`

```python
"""JSON Schema generation examples."""
import json
from typing import List, Optional
from pydantic import BaseModel, EmailStr, Field, HttpUrl


# ==================== Basic Schema Generation ====================

class SimpleUser(BaseModel):
    """Simple user model."""
    name: str
    age: int
    email: EmailStr


# Generate JSON Schema
schema = SimpleUser.model_json_schema()

print("Simple User Schema:")
print(json.dumps(schema, indent=2))


# ==================== Schema with Field Metadata ====================

class DetailedProduct(BaseModel):
    """Product with rich field metadata."""
    id: int = Field(description="Unique product identifier")
    name: str = Field(
        min_length=1,
        max_length=200,
        description="Product name",
        examples=["Laptop", "Phone", "Tablet"]
    )
    price: float = Field(
        gt=0,
        description="Product price in USD",
        examples=[99.99, 1299.99]
    )
    description: str = Field(
        default="",
        max_length=1000,
        description="Product description"
    )
    in_stock: bool = Field(
        default=True,
        description="Whether product is in stock"
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Product tags",
        examples=[["electronics", "computers"]]
    )


# Generate schema with metadata
product_schema = DetailedProduct.model_json_schema()

print("\n\nDetailed Product Schema:")
print(json.dumps(product_schema, indent=2))


# ==================== Nested Models Schema ====================

class Address(BaseModel):
    """Address model."""
    street: str = Field(description="Street address")
    city: str = Field(description="City name")
    country: str = Field(description="Country code", pattern="^[A-Z]{2}$")
    postal_code: str = Field(description="Postal/ZIP code")


class Company(BaseModel):
    """Company model."""
    name: str = Field(description="Company name")
    website: Optional[HttpUrl] = Field(None, description="Company website")


class CompleteUser(BaseModel):
    """User with nested models."""
    id: int = Field(description="User ID")
    username: str = Field(min_length=3, max_length=20, description="Username")
    email: EmailStr = Field(description="Email address")
    address: Address = Field(description="User address")
    company: Optional[Company] = Field(None, description="User company")


# Nested schema generation
user_schema = CompleteUser.model_json_schema()

print("\n\nComplete User Schema (with nested models):")
print(json.dumps(user_schema, indent=2))


# ==================== Export Schemas to Files ====================

def export_schemas():
    """Export schemas to JSON files."""
    schemas = {
        "SimpleUser": SimpleUser.model_json_schema(),
        "DetailedProduct": DetailedProduct.model_json_schema(),
        "CompleteUser": CompleteUser.model_json_schema()
    }
    
    for name, schema in schemas.items():
        filename = f"schemas/{name}.json"
        with open(filename, "w") as f:
            json.dump(schema, f, indent=2)
        print(f"Exported {filename}")


if __name__ == "__main__":
    export_schemas()
```

---

### File Path: `tests/test_schema_generation.py`

```python
"""Tests for JSON Schema generation."""
import json
import pytest
from pydantic import BaseModel, EmailStr, Field, HttpUrl
from typing import List, Optional


# ==================== Basic Schema Generation ====================

class User(BaseModel):
    """User model for testing."""
    id: int
    name: str
    email: EmailStr


def test_basic_schema_generation():
    """Test generating basic JSON schema."""
    schema = User.model_json_schema()
    
    # Schema has required fields
    assert "properties" in schema
    assert "required" in schema
    assert "title" in schema
    
    # Check properties
    assert "id" in schema["properties"]
    assert "name" in schema["properties"]
    assert "email" in schema["properties"]
    
    # Check required fields
    assert "id" in schema["required"]
    assert "name" in schema["required"]
    assert "email" in schema["required"]
    
    print("âœ… Basic schema generated!")
    print(json.dumps(schema, indent=2))


def test_schema_property_types():
    """Test that property types are correct in schema."""
    schema = User.model_json_schema()
    
    # Check types
    assert schema["properties"]["id"]["type"] == "integer"
    assert schema["properties"]["name"]["type"] == "string"
    assert schema["properties"]["email"]["type"] == "string"
    assert schema["properties"]["email"]["format"] == "email"
    
    print("âœ… Property types correct!")


# ==================== Schema with Constraints ====================

class Product(BaseModel):
    """Product with constraints."""
    name: str = Field(min_length=1, max_length=200)
    price: float = Field(gt=0, le=1000000)
    stock: int = Field(ge=0)
    tags: List[str] = Field(min_length=1, max_length=10)


def test_schema_with_constraints():
    """Test schema includes field constraints."""
    schema = Product.model_json_schema()
    
    # String length constraints
    name_schema = schema["properties"]["name"]
    assert name_schema["minLength"] == 1
    assert name_schema["maxLength"] == 200
    
    # Numeric constraints
    price_schema = schema["properties"]["price"]
    assert price_schema["exclusiveMinimum"] == 0
    assert price_schema["maximum"] == 1000000
    
    # Array constraints
    tags_schema = schema["properties"]["tags"]
    assert tags_schema["minItems"] == 1
    assert tags_schema["maxItems"] == 10
    
    print("âœ… Constraints in schema!")


# ==================== Schema with Metadata ====================

class DocumentedModel(BaseModel):
    """Model with field documentation."""
    username: str = Field(
        description="User's unique username",
        examples=["john_doe", "alice123"]
    )
    age: int = Field(
        ge=13,
        le=120,
        description="User's age in years"
    )


def test_schema_with_metadata():
    """Test schema includes field descriptions."""
    schema = DocumentedModel.model_json_schema()
    
    # Check descriptions
    assert schema["properties"]["username"]["description"] == "User's unique username"
    assert schema["properties"]["age"]["description"] == "User's age in years"
    
    # Check examples
    assert "examples" in schema["properties"]["username"]
    
    print("âœ… Metadata in schema!")


# ==================== Nested Models Schema ====================

class Address(BaseModel):
    """Address model."""
    street: str
    city: str


class UserWithAddress(BaseModel):
    """User with nested address."""
    name: str
    address: Address


def test_nested_model_schema():
    """Test schema for nested models."""
    schema = UserWithAddress.model_json_schema()
    
    # Has $defs for nested models
    assert "$defs" in schema
    assert "Address" in schema["$defs"]
    
    # Address property references the definition
    address_prop = schema["properties"]["address"]
    assert "$ref" in address_prop
    assert "Address" in address_prop["$ref"]
    
    print("âœ… Nested model schema generated!")
    print(json.dumps(schema, indent=2))


# ==================== Optional Fields Schema ====================

class OptionalModel(BaseModel):
    """Model with optional fields."""
    required_field: str
    optional_field: Optional[str] = None
    field_with_default: str = "default"


def test_optional_fields_schema():
    """Test schema for optional fields."""
    schema = OptionalModel.model_json_schema()
    
    # Only required_field is in required list
    assert "required_field" in schema["required"]
    assert "optional_field" not in schema["required"]
    assert "field_with_default" not in schema["required"]
    
    # Optional field can be null
    optional_schema = schema["properties"]["optional_field"]
    assert "anyOf" in optional_schema or "null" in str(optional_schema)
    
    # Field with default has default value
    default_schema = schema["properties"]["field_with_default"]
    assert default_schema.get("default") == "default"
    
    print("âœ… Optional fields handled correctly!")


# ==================== Pattern Validation Schema ====================

class PatternModel(BaseModel):
    """Model with regex patterns."""
    username: str = Field(pattern=r'^[a-zA-Z0-9_]+$')
    phone: str = Field(pattern=r'^\+?[1-9]\d{1,14}$')


def test_pattern_schema():
    """Test schema includes regex patterns."""
    schema = PatternModel.model_json_schema()
    
    # Patterns included
    assert "pattern" in schema["properties"]["username"]
    assert schema["properties"]["username"]["pattern"] == r'^[a-zA-Z0-9_]+$'
    
    assert "pattern" in schema["properties"]["phone"]
    
    print("âœ… Patterns in schema!")


# ==================== List and Dict Schema ====================

class CollectionModel(BaseModel):
    """Model with collections."""
    tags: List[str]
    metadata: dict


def test_collection_schema():
    """Test schema for lists and dicts."""
    schema = CollectionModel.model_json_schema()
    
    # List schema
    tags_schema = schema["properties"]["tags"]
    assert tags_schema["type"] == "array"
    assert tags_schema["items"]["type"] == "string"
    
    # Dict schema
    metadata_schema = schema["properties"]["metadata"]
    assert metadata_schema["type"] == "object"
    
    print("âœ… Collection schemas generated!")


# ==================== Schema Serialization ====================

def test_schema_to_json_string():
    """Test serializing schema to JSON string."""
    schema = User.model_json_schema()
    
    # Convert to JSON string
    json_string = json.dumps(schema, indent=2)
    
    assert isinstance(json_string, str)
    assert "properties" in json_string
    
    # Can parse back
    parsed = json.loads(json_string)
    assert parsed == schema
    
    print("âœ… Schema serialization works!")


# ==================== Multiple Models Schema ====================

def test_multiple_models_schema():
    """Test generating schemas for multiple related models."""
    from pydantic import BaseModel
    
    class Author(BaseModel):
        id: int
        name: str
    
    class Book(BaseModel):
        id: int
        title: str
        author: Author
    
    # Generate schema
    schema = Book.model_json_schema()
    
    # Has definitions for both models
    assert "$defs" in schema
    assert "Author" in schema["$defs"]
    
    print("âœ… Multiple model schemas generated!")


# ==================== Schema Export ====================

def test_export_schema_to_file(tmp_path):
    """Test exporting schema to file."""
    schema = User.model_json_schema()
    
    # Export to file
    schema_file = tmp_path / "user_schema.json"
    with open(schema_file, "w") as f:
        json.dump(schema, f, indent=2)
    
    # Verify file exists and is valid JSON
    assert schema_file.exists()
    
    with open(schema_file, "r") as f:
        loaded_schema = json.load(f)
    
    assert loaded_schema == schema
    
    print(f"âœ… Schema exported to {schema_file}!")


# ==================== Schema Validation ====================

def test_schema_validates_valid_data():
    """Test that generated schema matches valid data."""
    import jsonschema
    
    schema = User.model_json_schema()
    
    # Valid data
    valid_data = {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com"
    }
    
    # Should not raise
    jsonschema.validate(valid_data, schema)
    
    print("âœ… Schema validates valid data!")


def test_schema_rejects_invalid_data():
    """Test that generated schema rejects invalid data."""
    import jsonschema
    
    schema = User.model_json_schema()
    
    # Invalid data (missing email)
    invalid_data = {
        "id": 1,
        "name": "John Doe"
    }
    
    # Should raise
    with pytest.raises(jsonschema.ValidationError):
        jsonschema.validate(invalid_data, schema)
    
    print("âœ… Schema rejects invalid data!")


# ==================== Schema Usage Example ====================

def test_schema_for_api_documentation():
    """Example: Using schema for API documentation."""
    class CreateUserRequest(BaseModel):
        """Request model for creating a user."""
        username: str = Field(
            min_length=3,
            max_length=20,
            description="Unique username",
            examples=["john_doe"]
        )
        email: EmailStr = Field(
            description="User email address",
            examples=["john@example.com"]
        )
        password: str = Field(
            min_length=8,
            description="User password (min 8 chars)"
        )
    
    # Generate schema for API docs
    schema = CreateUserRequest.model_json_schema()
    
    # Schema includes all documentation
    assert schema["properties"]["username"]["description"] == "Unique username"
    assert schema["properties"]["username"]["minLength"] == 3
    assert schema["properties"]["username"]["maxLength"] == 20
    
    print("âœ… Schema ready for API documentation!")
    print("\nAPI Request Schema:")
    print(json.dumps(schema, indent=2))
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run schema generation tests
pytest tests/test_schema_generation.py -v -s

# Run example script
python examples/schema_generation.py
```

### Expected Result

```
tests/test_schema_generation.py::test_basic_schema_generation PASSED
âœ… Basic schema generated!
{
  "properties": {
    "id": {"type": "integer"},
    "name": {"type": "string"},
    "email": {"type": "string", "format": "email"}
  },
  "required": ["id", "name", "email"]
}

... [all tests pass]

======================== 14 passed in 1.23s =========================
```

---

## D. Schema Use Cases

### 1. **API Documentation**
Generate OpenAPI/Swagger schemas automatically

### 2. **Client Generation**
Generate API clients from schemas

### 3. **Validation**
Validate JSON data against schemas

### 4. **Testing**
Ensure API responses match expected structure

### 5. **Communication**
Share data structure contracts between teams

---

## E. What You've Learned

âœ… Generating JSON schemas from Pydantic models  
âœ… Schema structure and properties  
âœ… Including constraints in schemas  
âœ… Field metadata and descriptions  
âœ… Nested model schemas with $defs  
âœ… Optional fields in schemas  
âœ… Pattern/regex constraints  
âœ… Exporting schemas to files  
âœ… Validating data against schemas  

---

## F. What's Next?

In **Lesson 3.16 (Pydantic with Async httpx)**, we'll learn:
- Using Pydantic with async httpx
- AsyncClient patterns
- Concurrent validation

You're almost done with Project 3! ðŸŽ‰

---

**Ready for the next lesson?**
