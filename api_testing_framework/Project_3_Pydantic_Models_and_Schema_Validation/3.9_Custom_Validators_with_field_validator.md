# 3.9 Custom Validators with field_validator

## A. Concept Overview

### What & Why
While Pydantic's built-in validation is powerful, sometimes you need **custom business logic** â€“ checking if a username is appropriate, validating complex password rules, or ensuring email domains are from allowed lists. The `@field_validator` decorator lets you write custom validation functions that run automatically during model validation.

### Analogy
Think of custom validators as **security guards with specific instructions**.

Built-in validation is like the basic security check everyone goes through (ID check, metal detector). But sometimes you need specialized security:
- A **password validator** is like a guard checking if your password meets company policy
- An **email domain validator** is like a bouncer checking if you're on the guest list
- A **username profanity filter** is like a guard ensuring appropriate language

Custom validators are your specialized security guards enforcing your specific rules!

---

## B. Code Implementation

### File Path: `models/custom_validators.py`

```python
"""Custom validators using @field_validator decorator."""
import re
from typing import List, Optional
from datetime import datetime, date
from pydantic import BaseModel, EmailStr, Field, field_validator, ValidationError


# ==================== Basic field_validator ====================

class User(BaseModel):
    """User with custom username validation."""
    username: str
    email: EmailStr
    age: int
    
    @field_validator('username')
    @classmethod
    def username_must_be_alphanumeric(cls, v: str) -> str:
        """Validate that username contains only alphanumeric characters."""
        if not v.isalnum():
            raise ValueError('Username must be alphanumeric')
        return v
    
    @field_validator('username')
    @classmethod
    def username_length(cls, v: str) -> str:
        """Validate username length."""
        if len(v) < 3:
            raise ValueError('Username must be at least 3 characters')
        if len(v) > 20:
            raise ValueError('Username must be at most 20 characters')
        return v
    
    @field_validator('age')
    @classmethod
    def age_must_be_realistic(cls, v: int) -> int:
        """Validate age is realistic."""
        if v < 13:
            raise ValueError('Must be at least 13 years old')
        if v > 120:
            raise ValueError('Age must be less than 120')
        return v


# ==================== Transforming Values ====================

class UserProfile(BaseModel):
    """User profile with value transformation."""
    username: str
    bio: Optional[str] = None
    website: Optional[str] = None
    
    @field_validator('username')
    @classmethod
    def lowercase_username(cls, v: str) -> str:
        """Convert username to lowercase."""
        return v.lower()
    
    @field_validator('bio')
    @classmethod
    def strip_bio(cls, v: Optional[str]) -> Optional[str]:
        """Strip whitespace from bio."""
        if v is None:
            return v
        return v.strip()
    
    @field_validator('website')
    @classmethod
    def add_https_to_website(cls, v: Optional[str]) -> Optional[str]:
        """Add https:// if missing."""
        if v is None:
            return v
        if not v.startswith(('http://', 'https://')):
            return f'https://{v}'
        return v


# ==================== Complex Validation Logic ====================

class Password(BaseModel):
    """Password with complex validation rules."""
    password: str
    
    @field_validator('password')
    @classmethod
    def validate_password_strength(cls, v: str) -> str:
        """Validate password meets security requirements."""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        
        if not re.search(r'\d', v):
            raise ValueError('Password must contain at least one digit')
        
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('Password must contain at least one special character')
        
        return v


class EmailDomain(BaseModel):
    """Email with domain whitelist validation."""
    email: EmailStr
    
    ALLOWED_DOMAINS = {'example.com', 'company.com', 'trusted.org'}
    
    @field_validator('email')
    @classmethod
    def email_domain_must_be_allowed(cls, v: EmailStr) -> EmailStr:
        """Validate email domain is in whitelist."""
        domain = v.split('@')[1]
        if domain not in cls.ALLOWED_DOMAINS:
            raise ValueError(
                f'Email domain must be one of: {", ".join(cls.ALLOWED_DOMAINS)}'
            )
        return v


# ==================== Validating Multiple Fields ====================

class MultiFieldValidator(BaseModel):
    """Validate multiple fields with one validator."""
    first_name: str
    last_name: str
    middle_name: Optional[str] = None
    
    @field_validator('first_name', 'last_name', 'middle_name')
    @classmethod
    def names_must_be_capitalized(cls, v: Optional[str]) -> Optional[str]:
        """Ensure all names are properly capitalized."""
        if v is None:
            return v
        return v.strip().title()


# ==================== List Validation ====================

class TagValidator(BaseModel):
    """Validate list items."""
    tags: List[str]
    
    @field_validator('tags')
    @classmethod
    def validate_tags(cls, v: List[str]) -> List[str]:
        """Validate and clean tags."""
        if not v:
            raise ValueError('At least one tag is required')
        
        # Remove duplicates while preserving order
        seen = set()
        unique_tags = []
        for tag in v:
            tag_lower = tag.lower().strip()
            if tag_lower not in seen:
                seen.add(tag_lower)
                unique_tags.append(tag_lower)
        
        # Validate each tag
        for tag in unique_tags:
            if len(tag) < 2:
                raise ValueError(f'Tag "{tag}" is too short (min 2 characters)')
            if len(tag) > 20:
                raise ValueError(f'Tag "{tag}" is too long (max 20 characters)')
            if not tag.replace('-', '').replace('_', '').isalnum():
                raise ValueError(f'Tag "{tag}" contains invalid characters')
        
        return unique_tags


# ==================== Date Validation ====================

class DateValidator(BaseModel):
    """Validate dates with custom logic."""
    birth_date: date
    registration_date: date = Field(default_factory=date.today)
    
    @field_validator('birth_date')
    @classmethod
    def birth_date_must_be_in_past(cls, v: date) -> date:
        """Validate birth date is not in future."""
        if v > date.today():
            raise ValueError('Birth date cannot be in the future')
        
        # Calculate age
        today = date.today()
        age = today.year - v.year - ((today.month, today.day) < (v.month, v.day))
        
        if age < 13:
            raise ValueError('Must be at least 13 years old')
        if age > 120:
            raise ValueError('Age seems unrealistic')
        
        return v


# ==================== Profanity Filter ====================

class ContentModeration(BaseModel):
    """Content with profanity filtering."""
    title: str
    content: str
    
    PROFANITY_LIST = {'badword1', 'badword2', 'inappropriate'}
    
    @field_validator('title', 'content')
    @classmethod
    def check_profanity(cls, v: str) -> str:
        """Check for profanity in content."""
        v_lower = v.lower()
        for bad_word in cls.PROFANITY_LIST:
            if bad_word in v_lower:
                raise ValueError(f'Content contains inappropriate language')
        return v


# ==================== Conditional Validation ====================

class ConditionalValidator(BaseModel):
    """Validation that depends on field value."""
    user_type: str
    company_name: Optional[str] = None
    
    @field_validator('company_name')
    @classmethod
    def company_required_for_business(cls, v: Optional[str], info) -> Optional[str]:
        """Company name required for business users."""
        # Access other field values via info.data
        user_type = info.data.get('user_type')
        
        if user_type == 'business' and not v:
            raise ValueError('Company name is required for business users')
        
        return v


# ==================== Real-World Example: User Registration ====================

class UserRegistration(BaseModel):
    """Complete user registration with comprehensive validation."""
    username: str
    email: EmailStr
    password: str
    confirm_password: str
    age: int
    terms_accepted: bool
    
    @field_validator('username')
    @classmethod
    def validate_username(cls, v: str) -> str:
        """Validate username format and availability."""
        # Convert to lowercase
        v = v.lower().strip()
        
        # Check length
        if len(v) < 3 or len(v) > 20:
            raise ValueError('Username must be 3-20 characters')
        
        # Check format (alphanumeric and underscore only)
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Username can only contain letters, numbers, and underscore')
        
        # Check it doesn't start with number
        if v[0].isdigit():
            raise ValueError('Username cannot start with a number')
        
        # Reserved usernames
        reserved = {'admin', 'root', 'system', 'api', 'test'}
        if v in reserved:
            raise ValueError(f'Username "{v}" is reserved')
        
        return v
    
    @field_validator('password')
    @classmethod
    def validate_password(cls, v: str) -> str:
        """Validate password strength."""
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        
        checks = {
            'uppercase': re.search(r'[A-Z]', v),
            'lowercase': re.search(r'[a-z]', v),
            'digit': re.search(r'\d', v),
            'special': re.search(r'[!@#$%^&*(),.?":{}|<>]', v)
        }
        
        missing = [name for name, check in checks.items() if not check]
        if missing:
            raise ValueError(
                f'Password must contain: {", ".join(missing)}'
            )
        
        return v
    
    @field_validator('age')
    @classmethod
    def validate_age(cls, v: int) -> int:
        """Validate age requirements."""
        if v < 13:
            raise ValueError('You must be at least 13 years old to register')
        if v > 150:
            raise ValueError('Please enter a valid age')
        return v
    
    @field_validator('terms_accepted')
    @classmethod
    def terms_must_be_accepted(cls, v: bool) -> bool:
        """Ensure terms are accepted."""
        if not v:
            raise ValueError('You must accept the terms and conditions')
        return v


# ==================== Product Validation ====================

class Product(BaseModel):
    """Product with business logic validation."""
    name: str
    sku: str
    price: float
    discount_percent: float = 0.0
    stock_quantity: int
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate product name."""
        v = v.strip()
        if len(v) < 3:
            raise ValueError('Product name must be at least 3 characters')
        if len(v) > 200:
            raise ValueError('Product name must be at most 200 characters')
        return v
    
    @field_validator('sku')
    @classmethod
    def validate_sku(cls, v: str) -> str:
        """Validate SKU format."""
        v = v.upper().strip()
        if not re.match(r'^[A-Z0-9\-]+$', v):
            raise ValueError('SKU can only contain uppercase letters, numbers, and hyphens')
        if len(v) < 5 or len(v) > 20:
            raise ValueError('SKU must be 5-20 characters')
        return v
    
    @field_validator('price')
    @classmethod
    def validate_price(cls, v: float) -> float:
        """Validate price is positive."""
        if v <= 0:
            raise ValueError('Price must be greater than 0')
        if v > 1000000:
            raise ValueError('Price seems unrealistic')
        # Round to 2 decimal places
        return round(v, 2)
    
    @field_validator('discount_percent')
    @classmethod
    def validate_discount(cls, v: float) -> float:
        """Validate discount percentage."""
        if v < 0:
            raise ValueError('Discount cannot be negative')
        if v > 99:
            raise ValueError('Discount cannot exceed 99%')
        return round(v, 2)
    
    @field_validator('stock_quantity')
    @classmethod
    def validate_stock(cls, v: int) -> int:
        """Validate stock quantity."""
        if v < 0:
            raise ValueError('Stock quantity cannot be negative')
        return v
```

---

## C. Testing Custom Validators

### File Path: `tests/test_custom_validators.py`

```python
"""Tests for custom field validators."""
import pytest
from datetime import date
from pydantic import ValidationError

from models.custom_validators import (
    User,
    UserProfile,
    Password,
    EmailDomain,
    MultiFieldValidator,
    TagValidator,
    DateValidator,
    ContentModeration,
    UserRegistration,
    Product,
)


def test_username_validation():
    """Test username custom validation."""
    # Valid username
    user = User(username="john123", email="john@example.com", age=25)
    assert user.username == "john123"
    
    # Invalid - contains special characters
    with pytest.raises(ValidationError) as exc:
        User(username="john@123", email="john@example.com", age=25)
    assert "alphanumeric" in str(exc.value).lower()
    
    # Invalid - too short
    with pytest.raises(ValidationError) as exc:
        User(username="ab", email="john@example.com", age=25)
    assert "at least 3" in str(exc.value)
    
    print("âœ… Username validation works!")


def test_age_validation():
    """Test age custom validation."""
    # Valid age
    user = User(username="john", email="john@example.com", age=25)
    assert user.age == 25
    
    # Too young
    with pytest.raises(ValidationError) as exc:
        User(username="john", email="john@example.com", age=10)
    assert "at least 13" in str(exc.value)
    
    # Too old
    with pytest.raises(ValidationError) as exc:
        User(username="john", email="john@example.com", age=150)
    assert "less than 120" in str(exc.value)
    
    print("âœ… Age validation works!")


def test_value_transformation():
    """Test validators that transform values."""
    profile = UserProfile(
        username="JohnDoe",
        bio="  Some bio text  ",
        website="example.com"
    )
    
    # Username lowercased
    assert profile.username == "johndoe"
    
    # Bio stripped
    assert profile.bio == "Some bio text"
    
    # Website has https://
    assert profile.website == "https://example.com"
    
    print("âœ… Value transformation works!")


def test_password_strength():
    """Test password strength validation."""
    # Valid password
    pwd = Password(password="MyPass123!")
    assert pwd.password == "MyPass123!"
    
    # Too short
    with pytest.raises(ValidationError) as exc:
        Password(password="Pass1!")
    assert "at least 8" in str(exc.value)
    
    # No uppercase
    with pytest.raises(ValidationError) as exc:
        Password(password="mypass123!")
    assert "uppercase" in str(exc.value)
    
    # No digit
    with pytest.raises(ValidationError) as exc:
        Password(password="MyPassword!")
    assert "digit" in str(exc.value)
    
    # No special char
    with pytest.raises(ValidationError) as exc:
        Password(password="MyPassword123")
    assert "special character" in str(exc.value)
    
    print("âœ… Password validation works!")


def test_email_domain_whitelist():
    """Test email domain whitelist."""
    # Valid domain
    email = EmailDomain(email="user@example.com")
    assert email.email == "user@example.com"
    
    # Invalid domain
    with pytest.raises(ValidationError) as exc:
        EmailDomain(email="user@blocked.com")
    assert "must be one of" in str(exc.value)
    
    print("âœ… Email domain validation works!")


def test_multi_field_validator():
    """Test validator on multiple fields."""
    person = MultiFieldValidator(
        first_name="john",
        last_name="doe",
        middle_name="michael"
    )
    
    # All names capitalized
    assert person.first_name == "John"
    assert person.last_name == "Doe"
    assert person.middle_name == "Michael"
    
    print("âœ… Multi-field validation works!")


def test_tag_validation():
    """Test list validation and cleaning."""
    # Valid tags (with duplicates and mixed case)
    obj = TagValidator(tags=["Python", "testing", "PYTHON", "API", "Testing"])
    
    # Duplicates removed, lowercased
    assert len(obj.tags) == 3
    assert "python" in obj.tags
    assert "testing" in obj.tags
    assert "api" in obj.tags
    
    # Invalid - tag too short
    with pytest.raises(ValidationError) as exc:
        TagValidator(tags=["a"])
    assert "too short" in str(exc.value)
    
    # Invalid - empty list
    with pytest.raises(ValidationError) as exc:
        TagValidator(tags=[])
    assert "at least one tag" in str(exc.value).lower()
    
    print("âœ… Tag validation works!")


def test_date_validation():
    """Test custom date validation."""
    # Valid date
    obj = DateValidator(birth_date=date(1990, 1, 1))
    assert obj.birth_date.year == 1990
    
    # Future date - invalid
    with pytest.raises(ValidationError) as exc:
        DateValidator(birth_date=date(2030, 1, 1))
    assert "future" in str(exc.value).lower()
    
    # Too young
    today = date.today()
    recent_date = date(today.year - 10, today.month, today.day)
    with pytest.raises(ValidationError) as exc:
        DateValidator(birth_date=recent_date)
    assert "13 years old" in str(exc.value)
    
    print("âœ… Date validation works!")


def test_profanity_filter():
    """Test profanity filtering."""
    # Valid content
    content = ContentModeration(
        title="Great Article",
        content="This is good content"
    )
    assert content.title == "Great Article"
    
    # Invalid - profanity in title
    with pytest.raises(ValidationError) as exc:
        ContentModeration(
            title="This is badword1 title",
            content="Clean content"
        )
    assert "inappropriate" in str(exc.value).lower()
    
    print("âœ… Profanity filter works!")


def test_user_registration():
    """Test complete user registration validation."""
    # Valid registration
    user = UserRegistration(
        username="johndoe",
        email="john@example.com",
        password="MySecure123!",
        confirm_password="MySecure123!",
        age=25,
        terms_accepted=True
    )
    assert user.username == "johndoe"
    
    # Invalid - username starts with number
    with pytest.raises(ValidationError) as exc:
        UserRegistration(
            username="1johndoe",
            email="john@example.com",
            password="MySecure123!",
            confirm_password="MySecure123!",
            age=25,
            terms_accepted=True
        )
    assert "cannot start with a number" in str(exc.value)
    
    # Invalid - reserved username
    with pytest.raises(ValidationError) as exc:
        UserRegistration(
            username="admin",
            email="admin@example.com",
            password="MySecure123!",
            confirm_password="MySecure123!",
            age=25,
            terms_accepted=True
        )
    assert "reserved" in str(exc.value)
    
    # Invalid - terms not accepted
    with pytest.raises(ValidationError) as exc:
        UserRegistration(
            username="johndoe",
            email="john@example.com",
            password="MySecure123!",
            confirm_password="MySecure123!",
            age=25,
            terms_accepted=False
        )
    assert "terms" in str(exc.value).lower()
    
    print("âœ… User registration validation works!")


def test_product_validation():
    """Test product validation."""
    # Valid product
    product = Product(
        name="Awesome Product",
        sku="prod-12345",
        price=29.99,
        discount_percent=10.5,
        stock_quantity=100
    )
    
    # SKU uppercased
    assert product.sku == "PROD-12345"
    
    # Price rounded
    assert product.price == 29.99
    
    # Invalid - price too low
    with pytest.raises(ValidationError) as exc:
        Product(
            name="Product",
            sku="PROD-123",
            price=-10.0,
            stock_quantity=10
        )
    assert "greater than 0" in str(exc.value)
    
    # Invalid - discount too high
    with pytest.raises(ValidationError) as exc:
        Product(
            name="Product",
            sku="PROD-123",
            price=100.0,
            discount_percent=100,
            stock_quantity=10
        )
    assert "cannot exceed 99" in str(exc.value)
    
    print("âœ… Product validation works!")
```

---

## D. Connect & Apply

### How to Test It

```bash
# Run all tests
pytest tests/test_custom_validators.py -v -s
```

### Expected Result

```
tests/test_custom_validators.py::test_username_validation PASSED
âœ… Username validation works!

tests/test_custom_validators.py::test_password_strength PASSED
âœ… Password validation works!

tests/test_custom_validators.py::test_tag_validation PASSED
âœ… Tag validation works!

======================== 11 passed in 0.87s =========================
```

---

## E. Common Stumbling Blocks

### Problem 1: Forgot @classmethod

```python
# âŒ WRONG - Missing @classmethod
@field_validator('username')
def validate_username(cls, v: str) -> str:
    return v

# âœ… CORRECT
@field_validator('username')
@classmethod
def validate_username(cls, v: str) -> str:
    return v
```

---

### Problem 2: Accessing Other Fields

Use `info.data` to access other field values:

```python
@field_validator('field2')
@classmethod
def validate_field2(cls, v, info):
    field1_value = info.data.get('field1')
    # Now you can use field1_value
    return v
```

---

### Problem 3: Validator Order

Validators run **after** type conversion but **before** the model is created. Multiple validators on the same field run in definition order.

---

## F. What You've Learned

âœ… Writing custom validators with `@field_validator`  
âœ… Raising `ValueError` for validation failures  
âœ… Transforming values in validators  
âœ… Complex validation logic (regex, business rules)  
âœ… Validating multiple fields with one validator  
âœ… List validation and cleaning  
âœ… Accessing other field values with `info.data`  
âœ… Real-world validation patterns  

---

## G. What's Next?

In **Lesson 3.10 (Model Validators for Complex Logic)**, we'll learn:
- `@model_validator` for cross-field validation
- Validating entire models
- Password confirmation matching
- Complex business rules

You can now write any custom validation logic! ðŸŽ‰

---

**Ready for the next lesson?**
