# 3.10 Model Validators for Complex Logic

## A. Concept Overview

### What & Why
While `@field_validator` validates individual fields, `@model_validator` lets you validate **relationships between fields** or the **entire model as a whole**. This is essential for business logic like "password must match confirm_password" or "end_date must be after start_date" â€“ rules that depend on multiple fields working together.

### Analogy
Think of the difference like **individual inspections vs. final assembly check**.

- **field_validator**: Like inspecting each car part individually (engine âœ“, tires âœ“, doors âœ“)
- **model_validator**: Like the final assembly check ensuring all parts work together (doors fit the frame, engine matches the transmission, etc.)

Sometimes individual parts are perfect, but they don't work together. Model validators catch those issues!

---

## B. Code Implementation

### File Path: `models/model_validators.py`

```python
"""Model validators for cross-field validation."""
from datetime import date, datetime
from typing import Optional
from pydantic import BaseModel, EmailStr, Field, model_validator, field_validator


# ==================== Password Confirmation ====================

class UserRegistration(BaseModel):
    """User registration with password confirmation."""
    username: str
    email: EmailStr
    password: str
    confirm_password: str
    
    @model_validator(mode='after')
    def passwords_match(self) -> 'UserRegistration':
        """Validate that password and confirm_password match."""
        if self.password != self.confirm_password:
            raise ValueError('Passwords do not match')
        return self


# ==================== Date Range Validation ====================

class DateRange(BaseModel):
    """Date range where end must be after start."""
    start_date: date
    end_date: date
    
    @model_validator(mode='after')
    def end_after_start(self) -> 'DateRange':
        """Validate end_date is after start_date."""
        if self.end_date <= self.start_date:
            raise ValueError('end_date must be after start_date')
        return self


class Event(BaseModel):
    """Event with registration and event dates."""
    name: str
    registration_start: date
    registration_end: date
    event_start: date
    event_end: date
    
    @model_validator(mode='after')
    def validate_dates(self) -> 'Event':
        """Validate all date relationships."""
        # Registration must end before event starts
        if self.registration_end >= self.event_start:
            raise ValueError('Registration must end before event starts')
        
        # Registration end must be after registration start
        if self.registration_end <= self.registration_start:
            raise ValueError('Registration end must be after registration start')
        
        # Event end must be after event start
        if self.event_end <= self.event_start:
            raise ValueError('Event end must be after event start')
        
        return self


# ==================== Conditional Requirements ====================

class ShippingOrder(BaseModel):
    """Order with conditional shipping address requirement."""
    order_id: str
    delivery_method: str  # "pickup" or "delivery"
    shipping_address: Optional[str] = None
    
    @model_validator(mode='after')
    def validate_shipping_address(self) -> 'ShippingOrder':
        """Shipping address required for delivery."""
        if self.delivery_method == 'delivery' and not self.shipping_address:
            raise ValueError('Shipping address is required for delivery')
        return self


class BusinessAccount(BaseModel):
    """Account with conditional business fields."""
    account_type: str  # "personal" or "business"
    company_name: Optional[str] = None
    tax_id: Optional[str] = None
    
    @model_validator(mode='after')
    def validate_business_fields(self) -> 'BusinessAccount':
        """Business fields required for business accounts."""
        if self.account_type == 'business':
            if not self.company_name:
                raise ValueError('Company name required for business accounts')
            if not self.tax_id:
                raise ValueError('Tax ID required for business accounts')
        return self


# ==================== Numeric Relationships ====================

class PriceRange(BaseModel):
    """Price range where max must be greater than min."""
    min_price: float
    max_price: float
    
    @model_validator(mode='after')
    def max_greater_than_min(self) -> 'PriceRange':
        """Validate max_price > min_price."""
        if self.max_price <= self.min_price:
            raise ValueError('max_price must be greater than min_price')
        return self


class Discount(BaseModel):
    """Discount validation."""
    original_price: float = Field(gt=0)
    discounted_price: float = Field(gt=0)
    discount_percent: Optional[float] = None
    
    @model_validator(mode='after')
    def calculate_and_validate_discount(self) -> 'Discount':
        """Validate discount makes sense."""
        if self.discounted_price >= self.original_price:
            raise ValueError('Discounted price must be less than original price')
        
        # Calculate actual discount percentage
        actual_discount = (
            (self.original_price - self.discounted_price) / self.original_price * 100
        )
        
        # If discount_percent provided, verify it matches
        if self.discount_percent is not None:
            if abs(actual_discount - self.discount_percent) > 0.01:
                raise ValueError(
                    f'Discount percent {self.discount_percent}% does not match '
                    f'actual discount {actual_discount:.2f}%'
                )
        else:
            # Auto-calculate if not provided
            self.discount_percent = round(actual_discount, 2)
        
        return self


# ==================== Before vs After Mode ====================

class BeforeExample(BaseModel):
    """Example using mode='before' (dict access)."""
    username: str
    email: str
    
    @model_validator(mode='before')
    @classmethod
    def normalize_email(cls, data):
        """Normalize email before validation (mode='before')."""
        if isinstance(data, dict) and 'email' in data:
            data['email'] = data['email'].lower().strip()
        return data


class AfterExample(BaseModel):
    """Example using mode='after' (model access)."""
    first_name: str
    last_name: str
    full_name: Optional[str] = None
    
    @model_validator(mode='after')
    def generate_full_name(self) -> 'AfterExample':
        """Generate full_name if not provided (mode='after')."""
        if not self.full_name:
            self.full_name = f"{self.first_name} {self.last_name}"
        return self


# ==================== Complex Business Logic ====================

class Reservation(BaseModel):
    """Hotel reservation with complex validation."""
    check_in: date
    check_out: date
    num_guests: int = Field(ge=1, le=10)
    num_rooms: int = Field(ge=1, le=5)
    room_type: str
    
    @model_validator(mode='after')
    def validate_reservation(self) -> 'Reservation':
        """Validate reservation business rules."""
        # Check-out must be after check-in
        if self.check_out <= self.check_in:
            raise ValueError('Check-out must be after check-in')
        
        # Calculate number of nights
        nights = (self.check_out - self.check_in).days
        
        # Minimum stay
        if nights < 1:
            raise ValueError('Minimum stay is 1 night')
        
        # Maximum stay
        if nights > 30:
            raise ValueError('Maximum stay is 30 nights')
        
        # Guests per room validation
        if self.room_type == 'single' and self.num_guests > self.num_rooms:
            raise ValueError('Single rooms can only accommodate 1 guest per room')
        
        if self.room_type == 'double' and self.num_guests > (self.num_rooms * 2):
            raise ValueError('Double rooms can accommodate up to 2 guests per room')
        
        if self.room_type == 'suite' and self.num_guests > (self.num_rooms * 4):
            raise ValueError('Suites can accommodate up to 4 guests per room')
        
        return self


class BankTransfer(BaseModel):
    """Bank transfer with validation."""
    from_account: str
    to_account: str
    amount: float = Field(gt=0)
    currency: str
    transfer_type: str  # "domestic" or "international"
    
    @model_validator(mode='after')
    def validate_transfer(self) -> 'BankTransfer':
        """Validate bank transfer rules."""
        # Can't transfer to same account
        if self.from_account == self.to_account:
            raise ValueError('Cannot transfer to the same account')
        
        # Domestic transfer limits
        if self.transfer_type == 'domestic':
            if self.amount > 50000:
                raise ValueError('Domestic transfers limited to 50,000')
        
        # International transfer limits
        if self.transfer_type == 'international':
            if self.amount > 10000:
                raise ValueError('International transfers limited to 10,000')
        
        return self


# ==================== At Least One Required ====================

class ContactInfo(BaseModel):
    """Contact info where at least one method is required."""
    email: Optional[EmailStr] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    
    @model_validator(mode='after')
    def at_least_one_contact_method(self) -> 'ContactInfo':
        """Ensure at least one contact method is provided."""
        if not any([self.email, self.phone, self.address]):
            raise ValueError('At least one contact method is required')
        return self


# ==================== Mutually Exclusive Fields ====================

class SearchQuery(BaseModel):
    """Search with mutually exclusive options."""
    keyword: Optional[str] = None
    category_id: Optional[int] = None
    tag: Optional[str] = None
    
    @model_validator(mode='after')
    def only_one_search_method(self) -> 'SearchQuery':
        """Ensure only one search method is used."""
        methods = [self.keyword, self.category_id, self.tag]
        provided = [m for m in methods if m is not None]
        
        if len(provided) == 0:
            raise ValueError('At least one search method is required')
        
        if len(provided) > 1:
            raise ValueError('Only one search method can be used at a time')
        
        return self


# ==================== Data Normalization ====================

class Address(BaseModel):
    """Address with normalization."""
    street: str
    city: str
    state: str
    postal_code: str
    country: str
    
    @model_validator(mode='after')
    def normalize_address(self) -> 'Address':
        """Normalize address fields."""
        # Uppercase state codes
        self.state = self.state.upper().strip()
        
        # Uppercase country codes
        self.country = self.country.upper().strip()
        
        # Title case city
        self.city = self.city.title().strip()
        
        # Remove spaces from postal code
        self.postal_code = self.postal_code.replace(' ', '').replace('-', '')
        
        return self


# ==================== Computed Fields ====================

class Rectangle(BaseModel):
    """Rectangle with computed area."""
    width: float = Field(gt=0)
    height: float = Field(gt=0)
    area: Optional[float] = None
    perimeter: Optional[float] = None
    
    @model_validator(mode='after')
    def compute_dimensions(self) -> 'Rectangle':
        """Compute area and perimeter."""
        self.area = round(self.width * self.height, 2)
        self.perimeter = round(2 * (self.width + self.height), 2)
        return self
```

---

## C. Testing Model Validators

### File Path: `tests/test_model_validators.py`

```python
"""Tests for model validators."""
import pytest
from datetime import date, timedelta
from pydantic import ValidationError

from models.model_validators import (
    UserRegistration,
    DateRange,
    Event,
    ShippingOrder,
    BusinessAccount,
    PriceRange,
    Discount,
    Reservation,
    BankTransfer,
    ContactInfo,
    SearchQuery,
    Address,
    Rectangle,
    BeforeExample,
    AfterExample,
)


def test_password_confirmation():
    """Test password confirmation validation."""
    # Valid - passwords match
    user = UserRegistration(
        username="john",
        email="john@example.com",
        password="SecurePass123!",
        confirm_password="SecurePass123!"
    )
    assert user.password == user.confirm_password
    
    # Invalid - passwords don't match
    with pytest.raises(ValidationError) as exc:
        UserRegistration(
            username="john",
            email="john@example.com",
            password="SecurePass123!",
            confirm_password="DifferentPass456!"
        )
    assert "do not match" in str(exc.value).lower()
    
    print("âœ… Password confirmation validation works!")


def test_date_range():
    """Test date range validation."""
    today = date.today()
    tomorrow = today + timedelta(days=1)
    yesterday = today - timedelta(days=1)
    
    # Valid - end after start
    range1 = DateRange(start_date=today, end_date=tomorrow)
    assert range1.end_date > range1.start_date
    
    # Invalid - end before start
    with pytest.raises(ValidationError) as exc:
        DateRange(start_date=today, end_date=yesterday)
    assert "after start_date" in str(exc.value)
    
    # Invalid - same date
    with pytest.raises(ValidationError) as exc:
        DateRange(start_date=today, end_date=today)
    assert "after start_date" in str(exc.value)
    
    print("âœ… Date range validation works!")


def test_event_dates():
    """Test complex event date validation."""
    today = date.today()
    
    # Valid event
    event = Event(
        name="Conference 2024",
        registration_start=today,
        registration_end=today + timedelta(days=30),
        event_start=today + timedelta(days=31),
        event_end=today + timedelta(days=33)
    )
    assert event.name == "Conference 2024"
    
    # Invalid - registration ends after event starts
    with pytest.raises(ValidationError) as exc:
        Event(
            name="Bad Event",
            registration_start=today,
            registration_end=today + timedelta(days=35),
            event_start=today + timedelta(days=30),
            event_end=today + timedelta(days=32)
        )
    assert "before event starts" in str(exc.value)
    
    print("âœ… Event date validation works!")


def test_conditional_shipping_address():
    """Test conditional shipping address requirement."""
    # Valid - delivery with address
    order1 = ShippingOrder(
        order_id="ORD-001",
        delivery_method="delivery",
        shipping_address="123 Main St"
    )
    assert order1.shipping_address is not None
    
    # Valid - pickup without address
    order2 = ShippingOrder(
        order_id="ORD-002",
        delivery_method="pickup"
    )
    assert order2.shipping_address is None
    
    # Invalid - delivery without address
    with pytest.raises(ValidationError) as exc:
        ShippingOrder(
            order_id="ORD-003",
            delivery_method="delivery"
        )
    assert "required for delivery" in str(exc.value)
    
    print("âœ… Conditional validation works!")


def test_business_account():
    """Test business account conditional fields."""
    # Valid personal account
    personal = BusinessAccount(account_type="personal")
    assert personal.company_name is None
    
    # Valid business account
    business = BusinessAccount(
        account_type="business",
        company_name="Acme Corp",
        tax_id="12-3456789"
    )
    assert business.company_name == "Acme Corp"
    
    # Invalid - business without company name
    with pytest.raises(ValidationError) as exc:
        BusinessAccount(
            account_type="business",
            tax_id="12-3456789"
        )
    assert "company name required" in str(exc.value).lower()
    
    print("âœ… Business account validation works!")


def test_price_range():
    """Test price range validation."""
    # Valid range
    range1 = PriceRange(min_price=10.0, max_price=100.0)
    assert range1.max_price > range1.min_price
    
    # Invalid - max not greater than min
    with pytest.raises(ValidationError) as exc:
        PriceRange(min_price=100.0, max_price=50.0)
    assert "greater than min_price" in str(exc.value)
    
    print("âœ… Price range validation works!")


def test_discount_calculation():
    """Test discount calculation and validation."""
    # Valid discount (auto-calculated)
    discount = Discount(
        original_price=100.0,
        discounted_price=80.0
    )
    assert discount.discount_percent == 20.0
    
    # Valid with matching percentage
    discount2 = Discount(
        original_price=100.0,
        discounted_price=75.0,
        discount_percent=25.0
    )
    assert discount2.discount_percent == 25.0
    
    # Invalid - discounted price >= original
    with pytest.raises(ValidationError) as exc:
        Discount(
            original_price=100.0,
            discounted_price=100.0
        )
    assert "less than original" in str(exc.value)
    
    # Invalid - percentage doesn't match
    with pytest.raises(ValidationError) as exc:
        Discount(
            original_price=100.0,
            discounted_price=80.0,
            discount_percent=30.0  # Should be 20%
        )
    assert "does not match" in str(exc.value)
    
    print("âœ… Discount validation works!")


def test_reservation():
    """Test hotel reservation validation."""
    today = date.today()
    
    # Valid reservation
    reservation = Reservation(
        check_in=today,
        check_out=today + timedelta(days=3),
        num_guests=2,
        num_rooms=1,
        room_type="double"
    )
    assert (reservation.check_out - reservation.check_in).days == 3
    
    # Invalid - too many guests for single room
    with pytest.raises(ValidationError) as exc:
        Reservation(
            check_in=today,
            check_out=today + timedelta(days=2),
            num_guests=2,
            num_rooms=1,
            room_type="single"
        )
    assert "1 guest per room" in str(exc.value)
    
    print("âœ… Reservation validation works!")


def test_bank_transfer():
    """Test bank transfer validation."""
    # Valid domestic transfer
    transfer = BankTransfer(
        from_account="ACC-001",
        to_account="ACC-002",
        amount=5000.0,
        currency="USD",
        transfer_type="domestic"
    )
    assert transfer.amount == 5000.0
    
    # Invalid - same account
    with pytest.raises(ValidationError) as exc:
        BankTransfer(
            from_account="ACC-001",
            to_account="ACC-001",
            amount=100.0,
            currency="USD",
            transfer_type="domestic"
        )
    assert "same account" in str(exc.value)
    
    # Invalid - exceeds domestic limit
    with pytest.raises(ValidationError) as exc:
        BankTransfer(
            from_account="ACC-001",
            to_account="ACC-002",
            amount=60000.0,
            currency="USD",
            transfer_type="domestic"
        )
    assert "50,000" in str(exc.value)
    
    print("âœ… Bank transfer validation works!")


def test_at_least_one_required():
    """Test at least one field required."""
    # Valid - has email
    contact1 = ContactInfo(email="user@example.com")
    assert contact1.email is not None
    
    # Valid - has phone
    contact2 = ContactInfo(phone="+1234567890")
    assert contact2.phone is not None
    
    # Invalid - no contact method
    with pytest.raises(ValidationError) as exc:
        ContactInfo()
    assert "at least one" in str(exc.value).lower()
    
    print("âœ… At least one required works!")


def test_mutually_exclusive():
    """Test mutually exclusive fields."""
    # Valid - only keyword
    search1 = SearchQuery(keyword="python")
    assert search1.keyword is not None
    
    # Valid - only category
    search2 = SearchQuery(category_id=5)
    assert search2.category_id is not None
    
    # Invalid - multiple methods
    with pytest.raises(ValidationError) as exc:
        SearchQuery(keyword="python", category_id=5)
    assert "only one" in str(exc.value).lower()
    
    # Invalid - no method
    with pytest.raises(ValidationError) as exc:
        SearchQuery()
    assert "at least one" in str(exc.value).lower()
    
    print("âœ… Mutually exclusive validation works!")


def test_address_normalization():
    """Test address normalization."""
    address = Address(
        street="123 Main St",
        city="boston",
        state="ma",
        postal_code="02101-1234",
        country="usa"
    )
    
    # Fields normalized
    assert address.state == "MA"
    assert address.country == "USA"
    assert address.city == "Boston"
    assert address.postal_code == "021011234"  # Cleaned
    
    print("âœ… Address normalization works!")


def test_computed_fields():
    """Test computed fields."""
    rect = Rectangle(width=10.0, height=5.0)
    
    # Area and perimeter computed
    assert rect.area == 50.0
    assert rect.perimeter == 30.0
    
    print("âœ… Computed fields work!")


def test_before_vs_after_mode():
    """Test before and after validation modes."""
    # Before mode - works with dict
    before = BeforeExample(
        username="john",
        email="  JOHN@EXAMPLE.COM  "
    )
    assert before.email == "john@example.com"  # Normalized
    
    # After mode - works with model instance
    after = AfterExample(
        first_name="John",
        last_name="Doe"
    )
    assert after.full_name == "John Doe"  # Computed
    
    print("âœ… Before and after modes work!")
```

---

## D. Connect & Apply

### How to Test It

```bash
pytest tests/test_model_validators.py -v -s
```

### Expected Result

```
tests/test_model_validators.py::test_password_confirmation PASSED
âœ… Password confirmation validation works!

tests/test_model_validators.py::test_date_range PASSED
âœ… Date range validation works!

... [all tests pass]

======================== 14 passed in 1.12s =========================
```

---

## E. Common Stumbling Blocks

### Problem 1: mode='before' vs mode='after'

```python
# mode='before' - receives dict, use for preprocessing
@model_validator(mode='before')
@classmethod
def preprocess(cls, data):
    # data is a dict
    return data

# mode='after' - receives model instance, use for cross-field validation
@model_validator(mode='after')
def validate(self) -> 'Model':
    # self is the model instance
    return self
```

---

### Problem 2: Forgot to Return Self

```python
# âŒ WRONG - Forgot to return self
@model_validator(mode='after')
def validate(self):
    if self.field1 > self.field2:
        raise ValueError('Invalid')
    # Missing return!

# âœ… CORRECT
@model_validator(mode='after')
def validate(self) -> 'ModelName':
    if self.field1 > self.field2:
        raise ValueError('Invalid')
    return self
```

---

## F. When to Use What

| Scenario | Use |
|----------|-----|
| Validate single field | `@field_validator` |
| Transform single field | `@field_validator` |
| Compare two fields | `@model_validator(mode='after')` |
| Conditional requirements | `@model_validator(mode='after')` |
| Compute derived fields | `@model_validator(mode='after')` |
| Preprocess dict data | `@model_validator(mode='before')` |

---

## G. What You've Learned

âœ… Model validators for cross-field validation  
âœ… `mode='before'` vs `mode='after'`  
âœ… Password confirmation patterns  
âœ… Date range validation  
âœ… Conditional field requirements  
âœ… Mutually exclusive fields  
âœ… At least one field required  
âœ… Computed fields  
âœ… Data normalization  
âœ… Complex business rules  

---

## H. What's Next?

In **Lesson 3.11 (Field Constraints)**, we'll explore:
- All built-in Field constraints
- Regex patterns
- Min/max values
- String patterns

You can now handle any validation scenario! ðŸŽ‰

---

**Ready for the next lesson?**
