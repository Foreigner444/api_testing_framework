# 3.6 Default Values and Field Defaults

## A. Concept Overview

### What & Why
Default values make fields optional by providing a fallback value when the field isn't provided. Pydantic's `Field()` function unlocks powerful default behaviors â€“ from simple static defaults to dynamic, computed values using factories. Mastering defaults makes your models flexible yet safe.

### Analogy
Think of default values like **pre-filled form fields** at a website.

When you visit a website, some fields might be pre-filled:
- **Country**: Pre-filled with your location (static default)
- **Date**: Pre-filled with today's date (dynamic default)
- **Preferences**: Pre-filled with recommended settings (computed default)

You can change these values, but if you don't, the defaults are used. Pydantic does the same for your data!

---

## B. Code Implementation

### File Path: `models/field_defaults.py`

```python
"""Comprehensive guide to default values in Pydantic."""
from datetime import datetime, date
from typing import List, Dict, Optional
from uuid import uuid4
from pydantic import BaseModel, Field


# ==================== Simple Defaults ====================

class SimpleDefaults(BaseModel):
    """Simple static default values."""
    # String defaults
    country: str = "US"
    language: str = "en"
    theme: str = Field(default="light")
    
    # Numeric defaults
    age: int = 18
    score: int = Field(default=0)
    
    # Boolean defaults
    is_active: bool = True
    newsletter: bool = Field(default=False)


# ==================== default_factory ====================

class DynamicDefaults(BaseModel):
    """Dynamic defaults using default_factory."""
    # Current timestamp
    created_at: datetime = Field(default_factory=datetime.now)
    
    # Unique ID
    id: str = Field(default_factory=lambda: str(uuid4()))
    
    # Empty mutable collections (CORRECT way!)
    tags: List[str] = Field(default_factory=list)
    metadata: Dict[str, str] = Field(default_factory=dict)
    
    # Today's date
    registered_date: date = Field(default_factory=date.today)


# ==================== Why default_factory Matters ====================

# âŒ WRONG - Don't do this!
class WrongDefaults(BaseModel):
    """ANTI-PATTERN: Mutable defaults are shared!"""
    tags: List[str] = []  # DANGER: Shared across all instances!


# âœ… RIGHT - Use default_factory
class CorrectDefaults(BaseModel):
    """Correct way to handle mutable defaults."""
    tags: List[str] = Field(default_factory=list)


# ==================== Field with Description ====================

class DocumentedModel(BaseModel):
    """Model with well-documented fields."""
    username: str = Field(
        default="anonymous",
        description="User's display name",
        examples=["john_doe", "alice_smith"]
    )
    
    age: int = Field(
        default=18,
        ge=18,
        le=150,
        description="User's age in years",
        examples=[25, 30, 45]
    )
    
    role: str = Field(
        default="user",
        description="User's role in the system",
        examples=["user", "admin", "moderator"]
    )


# ==================== Computed Defaults ====================

def generate_username() -> str:
    """Generate a random username."""
    from random import randint
    return f"user_{randint(1000, 9999)}"


def get_default_settings() -> Dict[str, bool]:
    """Get default settings dictionary."""
    return {
        "email_notifications": True,
        "push_notifications": False,
        "dark_mode": False
    }


class ComputedDefaults(BaseModel):
    """Defaults computed by functions."""
    username: str = Field(default_factory=generate_username)
    settings: Dict[str, bool] = Field(default_factory=get_default_settings)
    created_at: datetime = Field(default_factory=datetime.now)


# ==================== Optional with Defaults ====================

class OptionalWithDefaults(BaseModel):
    """Optional fields with non-None defaults."""
    # These are optional (can omit) but have specific defaults
    name: str = "Guest"
    country: str = "Unknown"
    age: Optional[int] = None  # Optional, defaults to None
    bio: Optional[str] = None  # Optional, defaults to None


# ==================== Real-World Example ====================

class BlogPost(BaseModel):
    """Blog post model with smart defaults."""
    # Required fields
    title: str = Field(min_length=1, max_length=200)
    content: str = Field(min_length=1)
    author_id: int
    
    # Auto-generated fields
    id: str = Field(default_factory=lambda: str(uuid4()))
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    
    # Optional with defaults
    status: str = Field(default="draft")
    is_published: bool = Field(default=False)
    view_count: int = Field(default=0, ge=0)
    
    # Optional collections
    tags: List[str] = Field(default_factory=list)
    comments: List[str] = Field(default_factory=list)
    
    # Fully optional
    published_at: Optional[datetime] = None
    featured_image: Optional[str] = None


class UserSettings(BaseModel):
    """User settings with comprehensive defaults."""
    # User identity (required)
    user_id: int
    
    # Display preferences (with defaults)
    theme: str = Field(default="light", pattern="^(light|dark|auto)$")
    language: str = Field(default="en", pattern="^[a-z]{2}$")
    timezone: str = Field(default="UTC")
    
    # Notification settings (with defaults)
    email_notifications: bool = Field(default=True)
    push_notifications: bool = Field(default=False)
    sms_notifications: bool = Field(default=False)
    
    # Privacy settings (with defaults)
    profile_public: bool = Field(default=True)
    show_email: bool = Field(default=False)
    allow_messages: bool = Field(default=True)
    
    # Auto-generated
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)


# ==================== API Response Defaults ====================

class APIResponse(BaseModel):
    """Generic API response with smart defaults."""
    # Always present
    success: bool
    message: str = Field(default="Operation completed successfully")
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Optional
    data: Optional[dict] = None
    errors: List[str] = Field(default_factory=list)
    metadata: Dict[str, str] = Field(default_factory=dict)
```

---

## C. Testing Defaults

### File Path: `tests/test_field_defaults.py`

```python
"""Tests demonstrating default value behaviors."""
import time
from datetime import datetime

import pytest

from models.field_defaults import (
    SimpleDefaults,
    DynamicDefaults,
    WrongDefaults,
    CorrectDefaults,
    BlogPost,
    UserSettings,
    APIResponse,
)


def test_simple_defaults():
    """Test simple static defaults."""
    model = SimpleDefaults()
    
    # All defaults are applied
    assert model.country == "US"
    assert model.language == "en"
    assert model.theme == "light"
    assert model.age == 18
    assert model.score == 0
    assert model.is_active is True
    assert model.newsletter is False
    
    print("âœ… Simple defaults work!")


def test_overriding_defaults():
    """Test that defaults can be overridden."""
    model = SimpleDefaults(
        country="UK",
        language="fr",
        age=25,
        is_active=False
    )
    
    assert model.country == "UK"
    assert model.language == "fr"
    assert model.age == 25
    assert model.is_active is False
    
    print("âœ… Defaults can be overridden!")


def test_dynamic_defaults():
    """Test default_factory for dynamic values."""
    model1 = DynamicDefaults()
    time.sleep(0.01)  # Small delay
    model2 = DynamicDefaults()
    
    # Each instance gets unique values
    assert model1.id != model2.id
    assert model1.created_at != model2.created_at
    
    # Empty collections are unique instances
    assert model1.tags is not model2.tags
    assert model1.metadata is not model2.metadata
    
    print("âœ… Dynamic defaults create unique values!")


def test_wrong_mutable_defaults():
    """Demonstrate the DANGER of mutable defaults."""
    # Create two instances
    instance1 = WrongDefaults()
    instance2 = WrongDefaults()
    
    # Modify instance1's tags
    instance1.tags.append("python")
    
    # âš ï¸ DANGER: instance2's tags are also affected!
    # This is because they share the same list object!
    assert "python" in instance2.tags  # This will pass (but shouldn't!)
    
    print("âš ï¸  WARNING: Mutable defaults are shared across instances!")


def test_correct_mutable_defaults():
    """Demonstrate the CORRECT way with default_factory."""
    # Create two instances
    instance1 = CorrectDefaults()
    instance2 = CorrectDefaults()
    
    # Modify instance1's tags
    instance1.tags.append("python")
    
    # âœ… instance2 is NOT affected - they have separate lists
    assert "python" not in instance2.tags
    assert instance1.tags is not instance2.tags
    
    print("âœ… default_factory creates separate instances!")


def test_blog_post_minimal():
    """Test creating a blog post with minimal required fields."""
    post = BlogPost(
        title="My First Post",
        content="This is the content of my post.",
        author_id=123
    )
    
    # Required fields
    assert post.title == "My First Post"
    assert post.content == "This is the content of my post."
    assert post.author_id == 123
    
    # Auto-generated fields
    assert post.id is not None
    assert len(post.id) > 0
    assert post.created_at is not None
    assert post.updated_at is not None
    
    # Defaults
    assert post.status == "draft"
    assert post.is_published is False
    assert post.view_count == 0
    assert post.tags == []
    assert post.comments == []
    
    # Optional
    assert post.published_at is None
    assert post.featured_image is None
    
    print("âœ… Blog post created with smart defaults!")


def test_blog_post_full():
    """Test creating a blog post with all fields."""
    now = datetime.now()
    
    post = BlogPost(
        title="Published Post",
        content="Full content here.",
        author_id=456,
        status="published",
        is_published=True,
        view_count=100,
        tags=["python", "testing"],
        published_at=now
    )
    
    assert post.status == "published"
    assert post.is_published is True
    assert post.view_count == 100
    assert len(post.tags) == 2
    assert post.published_at == now
    
    print("âœ… Blog post with custom values works!")


def test_user_settings_defaults():
    """Test user settings with comprehensive defaults."""
    settings = UserSettings(user_id=789)
    
    # All defaults applied
    assert settings.theme == "light"
    assert settings.language == "en"
    assert settings.timezone == "UTC"
    assert settings.email_notifications is True
    assert settings.push_notifications is False
    assert settings.profile_public is True
    assert settings.show_email is False
    
    print("âœ… User settings defaults work perfectly!")


def test_api_response_success():
    """Test API response success with defaults."""
    response = APIResponse(success=True)
    
    assert response.success is True
    assert response.message == "Operation completed successfully"
    assert response.timestamp is not None
    assert response.data is None
    assert response.errors == []
    assert response.metadata == {}
    
    print("âœ… API response success with defaults!")


def test_api_response_with_data():
    """Test API response with custom values."""
    response = APIResponse(
        success=True,
        message="User created successfully",
        data={"user_id": 123, "username": "john"},
        metadata={"request_id": "abc-123"}
    )
    
    assert response.message == "User created successfully"
    assert response.data == {"user_id": 123, "username": "john"}
    assert response.metadata == {"request_id": "abc-123"}
    
    print("âœ… API response with custom data!")


def test_default_factory_uniqueness():
    """Test that default_factory creates unique instances."""
    # Create 3 instances
    instances = [DynamicDefaults() for _ in range(3)]
    
    # All IDs are unique
    ids = [instance.id for instance in instances]
    assert len(ids) == len(set(ids))  # All unique
    
    # All tags lists are separate
    instances[0].tags.append("tag1")
    assert "tag1" not in instances[1].tags
    assert "tag1" not in instances[2].tags
    
    print("âœ… default_factory ensures uniqueness!")
```

---

## D. Connect & Apply

### How to Test It

```bash
# Run all tests
pytest tests/test_field_defaults.py -v

# Run specific test
pytest tests/test_field_defaults.py::test_blog_post_minimal -v -s
```

### Expected Result

```
tests/test_field_defaults.py::test_simple_defaults PASSED
âœ… Simple defaults work!

tests/test_field_defaults.py::test_dynamic_defaults PASSED
âœ… Dynamic defaults create unique values!

tests/test_field_defaults.py::test_wrong_mutable_defaults PASSED
âš ï¸  WARNING: Mutable defaults are shared across instances!

tests/test_field_defaults.py::test_correct_mutable_defaults PASSED
âœ… default_factory creates separate instances!

... [all tests pass]

======================== 11 passed in 0.89s =========================
```

---

## E. Common Stumbling Blocks

### Problem 1: The Mutable Default Trap

**âŒ WRONG:**
```python
class Model(BaseModel):
    items: List[str] = []  # DANGER! Shared across instances!
```

**âœ… CORRECT:**
```python
class Model(BaseModel):
    items: List[str] = Field(default_factory=list)
```

**Why this matters:** Python evaluates default values once at class definition time, not at instance creation time. Mutable objects (lists, dicts) will be shared!

---

### Problem 2: datetime.now() vs datetime.now

**âŒ WRONG:**
```python
class Model(BaseModel):
    created_at: datetime = datetime.now()  # Evaluated ONCE at class definition!
```

**âœ… CORRECT:**
```python
class Model(BaseModel):
    created_at: datetime = Field(default_factory=datetime.now)  # Evaluated per instance
```

---

### Problem 3: Lambda Functions

```python
# Both work, lambda is cleaner for simple cases
id: str = Field(default_factory=lambda: str(uuid4()))

# Or define a function
def generate_id() -> str:
    return str(uuid4())

id: str = Field(default_factory=generate_id)
```

---

## F. Default Value Patterns

### Pattern 1: Auto-Generated IDs
```python
from uuid import uuid4

id: str = Field(default_factory=lambda: str(uuid4()))
```

### Pattern 2: Current Timestamp
```python
from datetime import datetime

created_at: datetime = Field(default_factory=datetime.now)
```

### Pattern 3: Empty Collections
```python
tags: List[str] = Field(default_factory=list)
metadata: Dict[str, Any] = Field(default_factory=dict)
```

### Pattern 4: Static Defaults
```python
status: str = Field(default="active")
priority: int = Field(default=0)
```

### Pattern 5: Computed Defaults
```python
def get_default_settings():
    return {"theme": "light", "notifications": True}

settings: Dict[str, Any] = Field(default_factory=get_default_settings)
```

---

## G. When to Use Each Approach

| Situation | Use | Example |
|-----------|-----|---------|
| Simple static value | `field: type = value` | `status: str = "active"` |
| Needs documentation | `Field(default=...)` | `Field(default="active", description="...")` |
| Current time | `default_factory=datetime.now` | `created_at: datetime = Field(default_factory=datetime.now)` |
| Empty list/dict | `default_factory=list/dict` | `tags: List[str] = Field(default_factory=list)` |
| Unique per instance | `default_factory=lambda: ...` | `id: str = Field(default_factory=lambda: str(uuid4()))` |

---

## H. What You've Learned

âœ… Simple static defaults with `=`  
âœ… Dynamic defaults with `default_factory`  
âœ… Why mutable defaults are dangerous  
âœ… How to create unique IDs and timestamps  
âœ… The difference between `datetime.now()` and `datetime.now`  
âœ… Real-world patterns for common default scenarios  
âœ… When to use `Field()` vs simple assignment  

---

## I. What's Next?

In **Lesson 3.7 (Nested Pydantic Models)**, we'll explore:
- Creating complex nested structures
- Validating deeply nested data
- Best practices for model composition

You're now a defaults expert! ðŸŽ‰

---

**Does that make sense? Let me know if you'd like me to explain it in a different way.**

**Ready for the next lesson, or would you like to practice this a bit more?**
