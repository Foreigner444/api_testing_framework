# 3.2 Installing and Configuring Pydantic

## A. Concept Overview

### What & Why
Before we can use Pydantic's validation superpowers, we need to install it and set up our project structure properly. We'll install **Pydantic V2** (the latest version with massive performance improvements) along with optional dependencies for email validation.

### Analogy
Think of this as **setting up your toolbox before starting a project**. You need to gather the right tools (install Pydantic), organize your workspace (project structure), and make sure everything works (verification test) before you start building.

---

## B. Code Implementation

### Step 1: Install Pydantic and Dependencies

Open your terminal and run these commands:

```bash
# Install Pydantic V2 (the latest and greatest!)
pip install "pydantic>=2.0"

# Install email validation support (for EmailStr type)
pip install "pydantic[email]"

# If you don't have httpx yet, install it too
pip install "httpx>=0.24"

# Install pytest for testing
pip install "pytest>=7.0"
```

**Or install everything at once:**
```bash
pip install "pydantic>=2.0" "pydantic[email]" "httpx>=0.24" "pytest>=7.0"
```

### **What each package does:**
- **`pydantic>=2.0`** ‚Äì The core Pydantic library with validation magic
- **`pydantic[email]`** ‚Äì Adds email validation support (uses email-validator under the hood)
- **`httpx>=0.24`** ‚Äì Modern HTTP client for making API requests
- **`pytest>=7.0`** ‚Äì Testing framework for writing and running tests

---

### Step 2: Create Your Project Structure

Let's set up a clean project structure following best practices:

```
my_api_tests/
‚îú‚îÄ‚îÄ models/              # Pydantic models go here
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ user.py          # User-related models
‚îú‚îÄ‚îÄ tests/               # Your test files
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ test_users.py    # User API tests
‚îú‚îÄ‚îÄ requirements.txt     # Project dependencies
‚îî‚îÄ‚îÄ pytest.ini          # Pytest configuration
```

**Create the structure:**

```bash
# Create project directories
mkdir -p my_api_tests/models my_api_tests/tests

# Create __init__.py files to make them Python packages
touch my_api_tests/models/__init__.py
touch my_api_tests/tests/__init__.py
```

---

### Step 3: Create requirements.txt

### File Path: `my_api_tests/requirements.txt`

```txt
# HTTP Client
httpx>=0.24.0

# Data Validation
pydantic>=2.0.0
pydantic[email]>=2.0.0

# Testing Framework
pytest>=7.0.0
pytest-asyncio>=0.21.0
```

**Why requirements.txt?**
- **Version control** ‚Äì Document exactly which versions work
- **Easy installation** ‚Äì Others can run `pip install -r requirements.txt`
- **Reproducibility** ‚Äì Same environment on every machine

---

### Step 4: Create pytest.ini Configuration

### File Path: `my_api_tests/pytest.ini`

```ini
[pytest]
# Where pytest should look for tests
testpaths = tests

# Pattern for test files
python_files = test_*.py

# Pattern for test functions
python_functions = test_*

# Show more verbose output
addopts = 
    -v
    --tb=short
    --strict-markers

# Console output style
console_output_style = progress

# Minimum Python version
minversion = 3.10
```

**Line-by-Line Explanation:**
- **`testpaths = tests`** ‚Äì pytest will look for tests in the `tests/` directory
- **`python_files = test_*.py`** ‚Äì Test files must start with `test_`
- **`python_functions = test_*`** ‚Äì Test functions must start with `test_`
- **`-v`** ‚Äì Verbose output (shows test names)
- **`--tb=short`** ‚Äì Show shorter tracebacks for cleaner error messages
- **`--strict-markers`** ‚Äì Fail on unknown pytest markers (prevents typos)
- **`console_output_style = progress`** ‚Äì Show a progress bar during tests
- **`minversion = 3.10`** ‚Äì Require Python 3.10+ for modern syntax

---

### Step 5: Verify Installation

Let's create a quick verification test to make sure everything works!

### File Path: `my_api_tests/tests/test_installation.py`

```python
"""Verification test to ensure Pydantic and httpx are installed correctly."""
import httpx
import pytest
from pydantic import BaseModel, EmailStr, __version__ as pydantic_version


class SimpleModel(BaseModel):
    """A simple model to test Pydantic installation."""
    name: str
    age: int
    email: EmailStr


def test_pydantic_version():
    """Verify we're using Pydantic V2."""
    print(f"\n‚úÖ Pydantic version: {pydantic_version}")
    assert pydantic_version.startswith("2."), "You must use Pydantic V2!"


def test_pydantic_validation():
    """Verify Pydantic validation works."""
    # Valid data - should work
    user = SimpleModel(
        name="Alice",
        age=30,
        email="alice@example.com"
    )
    
    assert user.name == "Alice"
    assert user.age == 30
    assert user.email == "alice@example.com"
    print(f"‚úÖ Pydantic validation works! User: {user.name}")


def test_pydantic_validation_fails_correctly():
    """Verify Pydantic catches invalid data."""
    from pydantic import ValidationError
    
    # Invalid email - should fail
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel(
            name="Bob",
            age=25,
            email="not-an-email"  # Invalid email format!
        )
    
    # Check that the error is about the email field
    assert "email" in str(exc_info.value)
    print("‚úÖ Pydantic correctly rejects invalid email!")


def test_httpx_works():
    """Verify httpx can make requests."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    response = client.get("/users/1")
    
    assert response.status_code == 200
    assert "name" in response.json()
    print(f"‚úÖ httpx works! Fetched user: {response.json()['name']}")


def test_httpx_with_pydantic():
    """Verify httpx and Pydantic work together."""
    class User(BaseModel):
        id: int
        name: str
        email: EmailStr
    
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    # Parse response with Pydantic
    user = User.model_validate(response.json())
    
    assert user.id > 0
    assert len(user.name) > 0
    print(f"‚úÖ httpx + Pydantic integration works! User: {user.name}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Navigate to your project directory
cd my_api_tests

# Run the verification tests
pytest tests/test_installation.py -v

# Expected output:
# tests/test_installation.py::test_pydantic_version PASSED
# tests/test_installation.py::test_pydantic_validation PASSED
# tests/test_installation.py::test_pydantic_validation_fails_correctly PASSED
# tests/test_installation.py::test_httpx_works PASSED
# tests/test_installation.py::test_httpx_with_pydantic PASSED
```

### Expected Result

You should see output like this:

```
‚úÖ Pydantic version: 2.5.0
‚úÖ Pydantic validation works! User: Alice
‚úÖ Pydantic correctly rejects invalid email!
‚úÖ httpx works! Fetched user: Leanne Graham
‚úÖ httpx + Pydantic integration works! User: Leanne Graham

======================== 5 passed in 0.45s =========================
```

If all tests pass, **you're ready to start building with Pydantic!** üéâ

---

## D. Common Stumbling Blocks

### Problem 1: "ModuleNotFoundError: No module named 'pydantic'"

**Error message:**
```
ModuleNotFoundError: No module named 'pydantic'
```

**What it means:**  
Pydantic isn't installed in your current Python environment.

**The fix:**
```bash
# Make sure you're in the right environment, then install
pip install "pydantic>=2.0"
```

---

### Problem 2: "No module named 'email_validator'"

**Error message:**
```
ImportError: Pydantic requires 'email-validator' for EmailStr support
```

**What it means:**  
You're trying to use `EmailStr` but haven't installed the email validation dependency.

**The fix:**
```bash
pip install "pydantic[email]"
```

---

### Problem 3: Pydantic V1 vs V2 Differences

**Error message:**
```
AttributeError: 'User' object has no attribute 'model_validate'
```

**What it means:**  
You're using Pydantic V1 syntax, but we need V2. In V1, the method was `parse_obj()`, in V2 it's `model_validate()`.

**The fix:**
```bash
# Upgrade to Pydantic V2
pip install --upgrade "pydantic>=2.0"
```

**Key differences to know:**
| Pydantic V1 | Pydantic V2 |
|------------|------------|
| `parse_obj()` | `model_validate()` |
| `dict()` | `model_dump()` |
| `json()` | `model_dump_json()` |
| `@validator` | `@field_validator` |

**We'll use V2 syntax throughout this course!**

---

### Problem 4: httpx Not Found

**Error message:**
```
ModuleNotFoundError: No module named 'httpx'
```

**The fix:**
```bash
pip install "httpx>=0.24"
```

---

## E. Why This Setup Matters

### Professional Project Structure
- **Separation of concerns** ‚Äì Models separate from tests
- **Scalability** ‚Äì Easy to add more models and tests
- **Industry standard** ‚Äì This structure is used in production frameworks

### Version Pinning
- **Reproducibility** ‚Äì Same versions = same behavior
- **Stability** ‚Äì Avoid surprise breaking changes
- **Documentation** ‚Äì Others know exactly what to install

### pytest Configuration
- **Consistency** ‚Äì Same test behavior across machines
- **Clarity** ‚Äì Clear output helps debug failures
- **Standards** ‚Äì Enforces test naming conventions

---

## F. Quick Reference

### Installation Commands
```bash
# Core dependencies
pip install "pydantic>=2.0" "pydantic[email]" "httpx>=0.24" "pytest>=7.0"

# Or use requirements.txt
pip install -r requirements.txt
```

### Verify Installation
```bash
# Check Pydantic version
python -c "import pydantic; print(pydantic.__version__)"

# Check httpx version
python -c "import httpx; print(httpx.__version__)"

# Run verification tests
pytest tests/test_installation.py -v
```

---

## G. What's Next?

Now that you have Pydantic installed and verified, you're ready to create your first real Pydantic model!

In **Lesson 3.3 (Your First Pydantic Model)**, we'll:
- Create a complete User model for a real API
- Learn the anatomy of a Pydantic model
- Parse real API responses with validation

Great job setting up your environment! üëè

---

**Does that make sense? Let me know if you'd like me to explain it in a different way.**

**Ready for the next lesson, or would you like to practice this a bit more?**
