# 3.13 Model Validation in Tests

## A. Concept Overview

### What & Why
Using Pydantic models in tests creates **self-validating assertions**. Instead of writing dozens of individual assertions, the model validates everything automatically. Your tests become cleaner, more maintainable, and catch more issues with less code.

### Analogy
Think of it like **automated quality inspection vs. manual checking**.

**Manual approach** (without Pydantic):
- Check box 1: "Does it have a label?" âœ“
- Check box 2: "Is the label spelled correctly?" âœ“
- Check box 3: "Is there a barcode?" âœ“
- ... repeat 50 times for every field

**Automated approach** (with Pydantic):
- Run item through automated scanner
- Scanner validates everything instantly
- Only alerts you if something's wrong

Pydantic is your automated quality scanner for API responses!

---

## B. Code Implementation

### File Path: `tests/test_model_validation_patterns.py`

```python
"""Comprehensive test patterns using Pydantic models."""
import httpx
import pytest
from pydantic import ValidationError
from typing import List

# Assuming models from previous lessons
from models.api_models import User, Post, Comment


# ==================== Pattern 1: Basic Validation ====================

def test_user_endpoint_validates():
    """Test that user endpoint returns valid data."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    assert response.status_code == 200
    
    # If this doesn't raise, ALL validation passed!
    user = User.model_validate(response.json())
    
    # That one line validated:
    # - All required fields present
    # - All types correct
    # - Email format valid
    # - Nested structures correct
    
    print(f"âœ… User {user.name} fully validated!")


# ==================== Pattern 2: Specific Field Assertions ====================

def test_user_specific_fields():
    """Test specific fields after validation."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    user = User.model_validate(response.json())
    
    # After validation, assert specific business logic
    assert user.id == 1
    assert user.name == "Leanne Graham"
    assert user.email == "Sincere@april.biz"
    assert user.address.city == "Gwenborough"
    
    print("âœ… Specific assertions passed!")


# ==================== Pattern 3: List Validation ====================

def test_all_users_validate():
    """Test that all users in list are valid."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users")
    
    # Parse all users - will fail if ANY user is invalid
    users = [User.model_validate(u) for u in response.json()]
    
    # Now assert on the collection
    assert len(users) == 10
    assert all(isinstance(u, User) for u in users)
    assert all(u.id > 0 for u in users)
    assert all("@" in u.email for u in users)
    
    print(f"âœ… All {len(users)} users validated!")


# ==================== Pattern 4: Partial Validation ====================

def test_posts_for_user():
    """Test posts for a specific user."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/posts", params={"userId": 1})
    
    posts = [Post.model_validate(p) for p in response.json()]
    
    # All posts validated, now check business rules
    assert len(posts) > 0
    assert all(post.userId == 1 for post in posts)
    assert all(len(post.title) > 0 for post in posts)
    assert all(len(post.body) > 0 for post in posts)
    
    print(f"âœ… {len(posts)} posts validated for user 1!")


# ==================== Pattern 5: Nested Validation ====================

def test_nested_address_validation():
    """Test nested address structure."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    user = User.model_validate(response.json())
    
    # Nested validation already happened, now assert specifics
    assert user.address.city == "Gwenborough"
    assert user.address.geo.lat == "-37.3159"
    assert user.address.geo.lng == "81.1496"
    
    # Complex nested access works perfectly
    latitude = float(user.address.geo.lat)
    assert -90 <= latitude <= 90
    
    print("âœ… Nested address validation passed!")


# ==================== Pattern 6: Error Detection ====================

def test_detect_invalid_response():
    """Test that invalid responses are caught."""
    invalid_data = {
        "id": "not-a-number",  # Wrong type!
        "name": "John",
        "email": "invalid-email",  # Wrong format!
        # Missing required fields...
    }
    
    with pytest.raises(ValidationError) as exc_info:
        User.model_validate(invalid_data)
    
    errors = exc_info.value.errors()
    assert len(errors) > 0
    
    print(f"âœ… Caught {len(errors)} validation errors!")


# ==================== Pattern 7: Conditional Validation ====================

def test_completed_vs_incomplete_todos():
    """Test filtering validated todos."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/todos", params={"userId": 1})
    
    from models.api_models import Todo
    todos = [Todo.model_validate(t) for t in response.json()]
    
    # Filter after validation
    completed = [t for t in todos if t.completed]
    incomplete = [t for t in todos if not t.completed]
    
    assert len(completed) > 0
    assert len(incomplete) > 0
    assert len(completed) + len(incomplete) == len(todos)
    
    print(f"âœ… Completed: {len(completed)}, Incomplete: {len(incomplete)}")


# ==================== Pattern 8: Parametrized Tests ====================

@pytest.mark.parametrize("user_id", [1, 2, 3, 4, 5])
def test_multiple_users_parametrized(user_id):
    """Test multiple users using parametrization."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get(f"/users/{user_id}")
    
    user = User.model_validate(response.json())
    
    assert user.id == user_id
    assert len(user.name) > 0
    assert "@" in user.email
    
    print(f"âœ… User {user_id} validated: {user.name}")


# ==================== Pattern 9: Fixture-Based Testing ====================

@pytest.fixture
def http_client():
    """Reusable httpx client fixture."""
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        yield client


def test_with_fixture(http_client):
    """Test using client fixture."""
    response = http_client.get("/users/1")
    user = User.model_validate(response.json())
    
    assert user.id == 1
    print(f"âœ… Fixture test passed for {user.name}")


# ==================== Pattern 10: Collection Validation Helpers ====================

def validate_collection(items: list, model_class) -> list:
    """Helper to validate a collection of items."""
    validated = []
    errors = []
    
    for idx, item in enumerate(items):
        try:
            validated.append(model_class.model_validate(item))
        except ValidationError as e:
            errors.append((idx, e))
    
    return validated, errors


def test_bulk_validation_with_error_tracking():
    """Test bulk validation with error tracking."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/posts")
    
    posts, errors = validate_collection(response.json(), Post)
    
    assert len(posts) > 0
    assert len(errors) == 0  # All posts should be valid
    
    print(f"âœ… Validated {len(posts)} posts with {len(errors)} errors")


# ==================== Pattern 11: Assertion Helpers ====================

def assert_valid_user(user: User):
    """Reusable assertion helper for users."""
    assert user.id > 0, "User ID must be positive"
    assert len(user.name) > 0, "User name cannot be empty"
    assert "@" in user.email, "User email must contain @"
    assert len(user.username) > 0, "Username cannot be empty"


def test_with_assertion_helper():
    """Test using assertion helper."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    user = User.model_validate(response.json())
    assert_valid_user(user)
    
    print("âœ… Assertion helper passed!")


# ==================== Pattern 12: Testing Relationships ====================

def test_post_comments_relationship():
    """Test relationship between posts and comments."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Get a post
    post_response = client.get("/posts/1")
    post = Post.model_validate(post_response.json())
    
    # Get comments for that post
    comments_response = client.get(f"/posts/{post.id}/comments")
    comments = [Comment.model_validate(c) for c in comments_response.json()]
    
    # Validate relationship
    assert len(comments) > 0
    assert all(comment.postId == post.id for comment in comments)
    
    print(f"âœ… Post {post.id} has {len(comments)} comments")


# ==================== Pattern 13: Snapshot Testing ====================

def test_user_structure_snapshot():
    """Test that user structure matches expected snapshot."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users/1")
    
    user = User.model_validate(response.json())
    
    # Convert to dict for snapshot comparison
    user_dict = user.model_dump()
    
    # Check structure
    assert "id" in user_dict
    assert "name" in user_dict
    assert "email" in user_dict
    assert "address" in user_dict
    assert "geo" in user_dict["address"]
    
    print("âœ… User structure matches snapshot!")


# ==================== Pattern 14: Performance Testing ====================

def test_validation_performance():
    """Test that validation doesn't significantly impact performance."""
    import time
    
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    response = client.get("/users")
    data = response.json()
    
    # Measure validation time
    start = time.time()
    users = [User.model_validate(u) for u in data]
    end = time.time()
    
    validation_time = end - start
    
    assert len(users) == 10
    assert validation_time < 1.0  # Should be fast!
    
    print(f"âœ… Validated {len(users)} users in {validation_time:.4f}s")


# ==================== Pattern 15: Integration Test ====================

def test_complete_workflow():
    """Test complete workflow with multiple API calls."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # 1. Get a user
    user_response = client.get("/users/1")
    user = User.model_validate(user_response.json())
    assert user.id == 1
    
    # 2. Get their posts
    posts_response = client.get("/posts", params={"userId": user.id})
    posts = [Post.model_validate(p) for p in posts_response.json()]
    assert len(posts) > 0
    
    # 3. Get comments for first post
    if posts:
        comments_response = client.get(f"/posts/{posts[0].id}/comments")
        comments = [Comment.model_validate(c) for c in comments_response.json()]
        assert len(comments) > 0
    
    print(f"âœ… Complete workflow validated!")
    print(f"   User: {user.name}")
    print(f"   Posts: {len(posts)}")
    print(f"   Comments on first post: {len(comments)}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run all validation tests
pytest tests/test_model_validation_patterns.py -v -s

# Run specific pattern
pytest tests/test_model_validation_patterns.py::test_all_users_validate -v -s

# Run parametrized tests
pytest tests/test_model_validation_patterns.py::test_multiple_users_parametrized -v -s
```

### Expected Result

```
tests/test_model_validation_patterns.py::test_user_endpoint_validates PASSED
âœ… User Leanne Graham fully validated!

tests/test_model_validation_patterns.py::test_all_users_validate PASSED
âœ… All 10 users validated!

... [all tests pass]

======================== 18 passed in 4.23s =========================
```

---

## D. What You've Learned

âœ… Self-validating test patterns with Pydantic  
âœ… Collection validation strategies  
âœ… Nested validation assertions  
âœ… Error detection and handling  
âœ… Parametrized tests with models  
âœ… Reusable fixtures and helpers  
âœ… Relationship testing  
âœ… Performance considerations  
âœ… Complete workflow integration tests  

---

## E. What's Next?

In **Lesson 3.14 (Handling Validation Errors)**, we'll learn:
- Parsing validation error details
- Custom error messages
- Error recovery strategies
- Logging validation failures

You now know all the test patterns! ðŸŽ‰

---

**Ready for the next lesson?**
