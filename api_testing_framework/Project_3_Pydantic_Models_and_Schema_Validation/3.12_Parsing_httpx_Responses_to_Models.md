# 3.12 Parsing httpx Responses to Models

## A. Concept Overview

### What & Why
This is where everything comes together! **Parsing httpx responses to Pydantic models** transforms raw API JSON into validated, type-safe Python objects. Instead of manually checking dictionaries, you get automatic validation, IDE autocomplete, and clear error messages when APIs don't match your expectations.

### Analogy
Think of it like **a translator with a quality checker**.

When you travel to a foreign country:
- **httpx** is like speaking to locals (making API requests)
- **Raw JSON** is like hearing foreign words you don't fully understand
- **Pydantic models** are like a translator who not only translates but also verifies the message makes sense

If someone tells you they're "200 years old", the translator catches that error!

---

## B. Code Implementation

### File Path: `models/api_models.py`

```python
"""Pydantic models for API responses."""
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel, EmailStr, HttpUrl, Field


# ==================== JSONPlaceholder Models ====================

class Geo(BaseModel):
    """Geographic coordinates."""
    lat: str
    lng: str


class Address(BaseModel):
    """User address."""
    street: str
    suite: str
    city: str
    zipcode: str
    geo: Geo


class Company(BaseModel):
    """Company information."""
    name: str
    catchPhrase: str
    bs: str


class User(BaseModel):
    """User from JSONPlaceholder API."""
    id: int
    name: str
    username: str
    email: EmailStr
    address: Address
    phone: str
    website: str
    company: Company


class Post(BaseModel):
    """Blog post from JSONPlaceholder API."""
    userId: int
    id: int
    title: str
    body: str


class Comment(BaseModel):
    """Comment from JSONPlaceholder API."""
    postId: int
    id: int
    name: str
    email: EmailStr
    body: str


class Todo(BaseModel):
    """Todo item from JSONPlaceholder API."""
    userId: int
    id: int
    title: str
    completed: bool


# ==================== Pagination Models ====================

class PaginationMeta(BaseModel):
    """Pagination metadata."""
    page: int
    per_page: int
    total: int
    total_pages: int


class PaginatedResponse(BaseModel):
    """Generic paginated API response."""
    meta: PaginationMeta
    data: List[dict]


class PaginatedUsers(BaseModel):
    """Paginated users response."""
    meta: PaginationMeta
    data: List[User]


# ==================== Error Response Models ====================

class ErrorDetail(BaseModel):
    """Single error detail."""
    field: Optional[str] = None
    message: str
    code: Optional[str] = None


class ErrorResponse(BaseModel):
    """API error response."""
    success: bool = False
    error: str
    details: Optional[List[ErrorDetail]] = None
    status_code: int


# ==================== Generic API Response ====================

class APIResponse(BaseModel):
    """Generic API response wrapper."""
    success: bool
    message: str
    data: Optional[dict] = None
    timestamp: datetime = Field(default_factory=datetime.now)


# ==================== Real-World GitHub API Models ====================

class GitHubUser(BaseModel):
    """GitHub user model."""
    login: str
    id: int
    avatar_url: HttpUrl
    html_url: HttpUrl
    name: Optional[str] = None
    company: Optional[str] = None
    blog: Optional[str] = None
    location: Optional[str] = None
    email: Optional[EmailStr] = None
    bio: Optional[str] = None
    public_repos: int
    followers: int
    following: int
    created_at: datetime


class GitHubRepo(BaseModel):
    """GitHub repository model."""
    id: int
    name: str
    full_name: str
    private: bool
    html_url: HttpUrl
    description: Optional[str] = None
    fork: bool
    created_at: datetime
    updated_at: datetime
    stargazers_count: int
    watchers_count: int
    forks_count: int
    open_issues_count: int
    language: Optional[str] = None
```

---

### File Path: `tests/test_httpx_pydantic_integration.py`

```python
"""Integration tests for httpx + Pydantic."""
import httpx
import pytest
from pydantic import ValidationError

from models.api_models import (
    User,
    Post,
    Comment,
    Todo,
    GitHubUser,
    GitHubRepo,
)


# ==================== Basic httpx + Pydantic ====================

def test_parse_single_user():
    """Test parsing a single user from API."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Make request
    response = client.get("/users/1")
    assert response.status_code == 200
    
    # Parse to Pydantic model
    user = User.model_validate(response.json())
    
    # Now you have a fully validated User object!
    assert user.id == 1
    assert user.name == "Leanne Graham"
    assert user.email == "Sincere@april.biz"
    assert user.address.city == "Gwenborough"
    assert user.company.name == "Romaguera-Crona"
    
    # Access nested fields with IDE support
    latitude = user.address.geo.lat
    assert latitude == "-37.3159"
    
    print(f"âœ… Parsed user: {user.name}")
    print(f"   ğŸ“ Location: {user.address.city}")
    print(f"   ğŸ“§ Email: {user.email}")
    print(f"   ğŸ¢ Company: {user.company.name}")


def test_parse_list_of_users():
    """Test parsing a list of users from API."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    response = client.get("/users")
    assert response.status_code == 200
    
    # Parse list of users
    users_data = response.json()
    users = [User.model_validate(user_data) for user_data in users_data]
    
    # All users validated
    assert len(users) == 10
    assert all(isinstance(user, User) for user in users)
    
    # Access any user's data
    first_user = users[0]
    assert first_user.id == 1
    assert first_user.name == "Leanne Graham"
    
    print(f"âœ… Parsed {len(users)} users successfully!")
    for user in users[:3]:
        print(f"   - {user.name} ({user.email})")


def test_parse_posts():
    """Test parsing blog posts."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    response = client.get("/posts")
    assert response.status_code == 200
    
    # Parse all posts
    posts = [Post.model_validate(post) for post in response.json()]
    
    assert len(posts) == 100
    assert all(isinstance(post, Post) for post in posts)
    
    # Check first post
    first_post = posts[0]
    assert first_post.id == 1
    assert first_post.userId == 1
    assert len(first_post.title) > 0
    
    print(f"âœ… Parsed {len(posts)} posts!")


def test_parse_comments():
    """Test parsing comments for a post."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    response = client.get("/posts/1/comments")
    assert response.status_code == 200
    
    # Parse comments
    comments = [Comment.model_validate(c) for c in response.json()]
    
    assert len(comments) == 5
    
    # Each comment has valid email
    for comment in comments:
        assert isinstance(comment, Comment)
        assert "@" in comment.email
        assert comment.postId == 1
    
    print(f"âœ… Parsed {len(comments)} comments!")


def test_parse_todos():
    """Test parsing todo items."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    response = client.get("/todos", params={"userId": 1})
    assert response.status_code == 200
    
    # Parse todos
    todos = [Todo.model_validate(todo) for todo in response.json()]
    
    assert len(todos) > 0
    assert all(todo.userId == 1 for todo in todos)
    
    # Count completed vs incomplete
    completed = [t for t in todos if t.completed]
    incomplete = [t for t in todos if not t.completed]
    
    print(f"âœ… Parsed {len(todos)} todos!")
    print(f"   Completed: {len(completed)}")
    print(f"   Incomplete: {len(incomplete)}")


# ==================== Error Handling ====================

def test_validation_error_on_invalid_data():
    """Test that Pydantic catches invalid API responses."""
    # Simulate invalid API response
    invalid_user_data = {
        "id": "not-an-int",  # Should be int!
        "name": "John",
        "username": "john",
        "email": "not-an-email",  # Invalid email!
        # Missing required fields...
    }
    
    with pytest.raises(ValidationError) as exc:
        User.model_validate(invalid_user_data)
    
    errors = exc.value.errors()
    
    # Multiple validation errors caught
    assert len(errors) > 0
    
    # Check specific errors
    error_fields = [err["loc"][0] for err in errors]
    assert "id" in error_fields or "email" in error_fields
    
    print("âœ… Pydantic caught invalid API data!")
    print(f"   Found {len(errors)} validation errors")


def test_missing_required_fields():
    """Test handling of missing required fields."""
    incomplete_data = {
        "id": 1,
        "name": "John",
        # Missing many required fields!
    }
    
    with pytest.raises(ValidationError) as exc:
        User.model_validate(incomplete_data)
    
    errors = exc.value.errors()
    
    # Check for missing fields
    missing_fields = [err["loc"][0] for err in errors if err["type"] == "missing"]
    
    assert "username" in missing_fields
    assert "email" in missing_fields
    
    print("âœ… Pydantic caught missing required fields!")


# ==================== Reusable Helper Functions ====================

def fetch_and_parse(url: str, model_class):
    """Reusable helper to fetch and parse API data."""
    client = httpx.Client()
    response = client.get(url)
    response.raise_for_status()
    return model_class.model_validate(response.json())


def fetch_and_parse_list(url: str, model_class):
    """Reusable helper to fetch and parse list of items."""
    client = httpx.Client()
    response = client.get(url)
    response.raise_for_status()
    return [model_class.model_validate(item) for item in response.json()]


def test_helper_functions():
    """Test reusable helper functions."""
    # Fetch single user
    user = fetch_and_parse(
        "https://jsonplaceholder.typicode.com/users/1",
        User
    )
    assert user.id == 1
    
    # Fetch list of posts
    posts = fetch_and_parse_list(
        "https://jsonplaceholder.typicode.com/posts?userId=1",
        Post
    )
    assert len(posts) > 0
    assert all(post.userId == 1 for post in posts)
    
    print("âœ… Helper functions work great!")


# ==================== Real-World API: GitHub ====================

def test_github_user():
    """Test parsing real GitHub API user."""
    client = httpx.Client(base_url="https://api.github.com")
    
    # GitHub API requires User-Agent header
    headers = {"User-Agent": "Python-httpx-test"}
    
    response = client.get("/users/octocat", headers=headers)
    
    if response.status_code == 200:
        # Parse GitHub user
        user = GitHubUser.model_validate(response.json())
        
        assert user.login == "octocat"
        assert user.id > 0
        assert user.public_repos >= 0
        
        print(f"âœ… Parsed GitHub user: {user.login}")
        print(f"   Repos: {user.public_repos}")
        print(f"   Followers: {user.followers}")
    else:
        pytest.skip(f"GitHub API returned {response.status_code}")


def test_github_repos():
    """Test parsing GitHub repositories."""
    client = httpx.Client(base_url="https://api.github.com")
    headers = {"User-Agent": "Python-httpx-test"}
    
    response = client.get("/users/octocat/repos", headers=headers)
    
    if response.status_code == 200:
        # Parse repos
        repos = [GitHubRepo.model_validate(repo) for repo in response.json()]
        
        assert len(repos) > 0
        
        for repo in repos:
            assert isinstance(repo, GitHubRepo)
            assert repo.id > 0
            assert len(repo.name) > 0
        
        print(f"âœ… Parsed {len(repos)} GitHub repos!")
    else:
        pytest.skip(f"GitHub API returned {response.status_code}")


# ==================== Partial Responses ====================

def test_partial_data_with_optional_fields():
    """Test handling partial data with optional fields."""
    partial_user = {
        "login": "testuser",
        "id": 12345,
        "avatar_url": "https://example.com/avatar.jpg",
        "html_url": "https://github.com/testuser",
        "public_repos": 10,
        "followers": 5,
        "following": 3,
        "created_at": "2020-01-01T00:00:00Z"
        # Missing optional fields: name, company, bio, etc.
    }
    
    user = GitHubUser.model_validate(partial_user)
    
    assert user.login == "testuser"
    assert user.name is None  # Optional field
    assert user.bio is None   # Optional field
    
    print("âœ… Handled partial data correctly!")


# ==================== Response Status Validation ====================

def test_validate_response_status_before_parsing():
    """Test checking response status before parsing."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Valid endpoint
    response = client.get("/users/1")
    if response.status_code == 200:
        user = User.model_validate(response.json())
        assert user.id == 1
    
    # Invalid endpoint
    response = client.get("/users/99999")
    if response.status_code == 404:
        print("âœ… Correctly handled 404 response")
    else:
        # Still try to parse if 200
        user = User.model_validate(response.json())


# ==================== Context Manager Pattern ====================

def test_with_context_manager():
    """Test using httpx with context manager."""
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        response = client.get("/users/1")
        user = User.model_validate(response.json())
        assert user.id == 1
    
    print("âœ… Context manager pattern works!")


# ==================== Batch Requests ====================

def test_batch_requests():
    """Test fetching multiple resources in parallel."""
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        # Fetch multiple users
        user_ids = [1, 2, 3, 4, 5]
        users = []
        
        for user_id in user_ids:
            response = client.get(f"/users/{user_id}")
            if response.status_code == 200:
                user = User.model_validate(response.json())
                users.append(user)
        
        assert len(users) == 5
        assert users[0].id == 1
        assert users[4].id == 5
        
        print(f"âœ… Fetched and parsed {len(users)} users in batch!")


# ==================== Error Recovery ====================

def test_error_recovery_with_defaults():
    """Test recovering from validation errors with defaults."""
    # Data with some invalid fields
    messy_data = {
        "userId": 1,
        "id": 1,
        "title": "Test Post",
        "body": "This is a test",
        "extra_field": "ignored"  # Extra fields are ignored by default
    }
    
    post = Post.model_validate(messy_data)
    assert post.title == "Test Post"
    
    # Pydantic ignores extra fields by default
    assert not hasattr(post, "extra_field")
    
    print("âœ… Gracefully handled extra fields!")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run all integration tests
pytest tests/test_httpx_pydantic_integration.py -v -s

# Run specific test
pytest tests/test_httpx_pydantic_integration.py::test_parse_single_user -v -s
```

### Expected Result

```
tests/test_httpx_pydantic_integration.py::test_parse_single_user PASSED
âœ… Parsed user: Leanne Graham
   ğŸ“ Location: Gwenborough
   ğŸ“§ Email: Sincere@april.biz
   ğŸ¢ Company: Romaguera-Crona

tests/test_httpx_pydantic_integration.py::test_parse_list_of_users PASSED
âœ… Parsed 10 users successfully!

... [all tests pass]

======================== 15 passed in 3.45s =========================
```

---

## D. Common Stumbling Blocks

### Problem 1: Forgetting to Call .json()

```python
# âŒ WRONG - Passing response object
user = User.model_validate(response)

# âœ… CORRECT - Parse JSON first
user = User.model_validate(response.json())
```

---

### Problem 2: Not Checking Response Status

```python
# âŒ WRONG - Might try to parse error response
response = client.get("/users/1")
user = User.model_validate(response.json())

# âœ… CORRECT - Check status first
response = client.get("/users/1")
if response.status_code == 200:
    user = User.model_validate(response.json())
else:
    print(f"Error: {response.status_code}")
```

---

### Problem 3: Handling API Changes

When APIs change and don't match your model:
```python
try:
    user = User.model_validate(response.json())
except ValidationError as e:
    print(f"API response doesn't match expected structure:")
    print(e)
    # Log the error, alert the team, etc.
```

---

## E. Best Practices

### 1. **Always Check Response Status**
```python
response = client.get("/endpoint")
response.raise_for_status()  # Raises exception for 4xx/5xx
user = User.model_validate(response.json())
```

### 2. **Use Context Managers**
```python
with httpx.Client() as client:
    response = client.get("/endpoint")
    # Client automatically closed
```

### 3. **Create Reusable Helpers**
```python
def api_get(url: str, model_class):
    with httpx.Client() as client:
        response = client.get(url)
        response.raise_for_status()
        return model_class.model_validate(response.json())
```

### 4. **Handle Validation Errors Gracefully**
```python
try:
    user = User.model_validate(response.json())
except ValidationError as e:
    logger.error(f"Validation failed: {e}")
    # Handle error appropriately
```

---

## F. What You've Learned

âœ… Parsing httpx responses to Pydantic models  
âœ… Validating API responses automatically  
âœ… Handling lists of models  
âœ… Error handling and validation failures  
âœ… Reusable helper functions  
âœ… Real-world API integration (GitHub)  
âœ… Context managers with httpx  
âœ… Batch request patterns  

---

## G. What's Next?

In **Lesson 3.13 (Model Validation in Tests)**, we'll learn:
- Writing comprehensive API tests with Pydantic
- Assertion patterns for validated models
- Testing validation failures

This is where Pydantic shines for API testing! ğŸ‰

---

**Ready for the next lesson?**
