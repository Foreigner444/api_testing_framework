# 3.18 Best Practices for Pydantic Models

## A. Concept Overview

### What & Why
After learning all the Pydantic features, it's crucial to understand **best practices** that make your models maintainable, performant, and production-ready. These practices come from real-world experience and help you avoid common pitfalls while building robust API testing frameworks.

### Analogy
Think of best practices like **cooking from a master chef's playbook**.

You know all the techniques:
- âœ… How to chop vegetables
- âœ… How to sautÃ©
- âœ… How to season

But the master chef teaches you:
- ğŸŒŸ **When** to use each technique
- ğŸŒŸ **Why** certain combinations work
- ğŸŒŸ **How** to avoid common mistakes
- ğŸŒŸ **What** makes a dish production-ready

Best practices turn your knowledge into mastery!

---

## B. Best Practices Guide

### File Path: `docs/PYDANTIC_BEST_PRACTICES.md`

```markdown
# Pydantic Best Practices for API Testing

## 1. Model Organization

### âœ… DO: Organize by Domain
```python
# Good structure
models/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ user.py        # User-related models
â”œâ”€â”€ product.py     # Product-related models
â”œâ”€â”€ order.py       # Order-related models
â””â”€â”€ common.py      # Shared models
```

### âŒ DON'T: Put everything in one file
```python
# Bad - all models in models.py
# Becomes unmanageable quickly
```

---

## 2. Model Naming

### âœ… DO: Use clear, descriptive names
```python
class UserResponse(BaseModel):
    """User data from GET /users endpoint."""
    pass

class UserCreateRequest(BaseModel):
    """Request body for POST /users endpoint."""
    pass

class UserUpdateRequest(BaseModel):
    """Request body for PATCH /users endpoint."""
    pass
```

### âŒ DON'T: Use ambiguous names
```python
class User1(BaseModel):  # Which user?
    pass

class UserData(BaseModel):  # What kind of data?
    pass
```

---

## 3. Field Documentation

### âœ… DO: Document fields thoroughly
```python
class Product(BaseModel):
    """Product information."""
    id: int = Field(description="Unique product identifier")
    name: str = Field(
        min_length=1,
        max_length=200,
        description="Product name",
        examples=["Laptop", "Phone"]
    )
    price: Decimal = Field(
        gt=0,
        decimal_places=2,
        description="Product price in USD"
    )
```

### âŒ DON'T: Leave fields undocumented
```python
class Product(BaseModel):
    id: int
    name: str
    price: float  # No context!
```

---

## 4. Use Appropriate Types

### âœ… DO: Use specific types
```python
from pydantic import EmailStr, HttpUrl
from decimal import Decimal

class User(BaseModel):
    email: EmailStr  # Validates email format
    website: HttpUrl  # Validates URL
    balance: Decimal  # Precise for money
```

### âŒ DON'T: Use generic types
```python
class User(BaseModel):
    email: str  # No validation
    website: str  # No validation
    balance: float  # Imprecise for money
```

---

## 5. Default Values

### âœ… DO: Use default_factory for mutables
```python
from pydantic import Field

class User(BaseModel):
    tags: List[str] = Field(default_factory=list)
    metadata: Dict[str, str] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.now)
```

### âŒ DON'T: Use mutable defaults directly
```python
class User(BaseModel):
    tags: List[str] = []  # DANGER! Shared across instances!
    metadata: Dict[str, str] = {}  # DANGER!
```

---

## 6. Optional vs Required

### âœ… DO: Be explicit about optionality
```python
class User(BaseModel):
    # Required
    username: str
    email: EmailStr
    
    # Optional with explicit None default
    bio: Optional[str] = None
    avatar_url: Optional[HttpUrl] = None
```

### âŒ DON'T: Make everything optional
```python
class User(BaseModel):
    username: Optional[str] = None  # Should username be optional?
    email: Optional[EmailStr] = None  # What about email?
    # Everything optional = no contract!
```

---

## 7. Model Reusability

### âœ… DO: Compose models
```python
class Address(BaseModel):
    """Reusable address model."""
    street: str
    city: str
    country: str

class User(BaseModel):
    name: str
    address: Address  # Reuse!

class Company(BaseModel):
    name: str
    address: Address  # Reuse again!
```

### âŒ DON'T: Duplicate model definitions
```python
class User(BaseModel):
    name: str
    street: str
    city: str
    country: str

class Company(BaseModel):
    name: str
    street: str  # Duplicated!
    city: str    # Duplicated!
    country: str # Duplicated!
```

---

## 8. Validation Strategy

### âœ… DO: Use field validators for field-specific logic
```python
class User(BaseModel):
    username: str
    
    @field_validator('username')
    @classmethod
    def validate_username(cls, v: str) -> str:
        """Validate single field."""
        if not v.isalnum():
            raise ValueError('Username must be alphanumeric')
        return v.lower()
```

### âœ… DO: Use model validators for cross-field logic
```python
class DateRange(BaseModel):
    start_date: date
    end_date: date
    
    @model_validator(mode='after')
    def validate_date_range(self) -> 'DateRange':
        """Validate relationship between fields."""
        if self.end_date <= self.start_date:
            raise ValueError('end_date must be after start_date')
        return self
```

---

## 9. Error Handling

### âœ… DO: Handle validation errors gracefully
```python
try:
    user = User.model_validate(response.json())
except ValidationError as e:
    logger.error(f"Validation failed: {e}")
    # Log details, report to monitoring, etc.
    raise
```

### âŒ DON'T: Ignore validation errors
```python
user = User.model_validate(response.json())  # Might crash!
```

---

## 10. Performance Considerations

### âœ… DO: Use model_validate() for dicts
```python
# Fast - direct validation
user = User.model_validate(data_dict)
```

### âŒ DON'T: Use model_validate_json() for dicts
```python
# Slow - unnecessary JSON serialization
user = User.model_validate_json(json.dumps(data_dict))
```

### âœ… DO: Validate once, use many times
```python
# Validate once
users = [User.model_validate(u) for u in user_data]

# Use validated objects
for user in users:
    assert user.id > 0
    assert "@" in user.email
```

---

## 11. Testing Models

### âœ… DO: Test your models
```python
def test_user_model():
    """Test user model validation."""
    user = User(
        username="johndoe",
        email="john@example.com",
        age=30
    )
    assert user.username == "johndoe"

def test_user_validation_fails():
    """Test validation catches errors."""
    with pytest.raises(ValidationError):
        User(
            username="john@doe",  # Invalid!
            email="john@example.com",
            age=30
        )
```

---

## 12. Config Class

### âœ… DO: Use ConfigDict for model configuration
```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        str_strip_whitespace=True,  # Auto-strip strings
        validate_assignment=True,    # Validate on assignment
        populate_by_name=True        # Allow field aliases
    )
    
    name: str
    email: EmailStr
```

---

## 13. Aliases for API Compatibility

### âœ… DO: Use aliases for camelCase APIs
```python
class User(BaseModel):
    model_config = ConfigDict(populate_by_name=True)
    
    first_name: str = Field(alias="firstName")
    last_name: str = Field(alias="lastName")
```

Now works with both:
```python
# camelCase (from API)
user = User.model_validate({"firstName": "John", "lastName": "Doe"})

# snake_case (Python)
user = User(first_name="John", last_name="Doe")
```

---

## 14. Model Inheritance

### âœ… DO: Use inheritance for common patterns
```python
class TimestampedModel(BaseModel):
    """Base model with timestamps."""
    created_at: datetime
    updated_at: datetime

class User(TimestampedModel):
    """User inherits timestamps."""
    name: str
    email: EmailStr
    # Automatically has created_at and updated_at
```

---

## 15. Version Your Models

### âœ… DO: Version models for API changes
```python
# Old API version
class UserV1(BaseModel):
    name: str
    email: EmailStr

# New API version
class UserV2(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    phone: Optional[str] = None
```

---

## 16. Separate Request/Response Models

### âœ… DO: Different models for different purposes
```python
class UserCreateRequest(BaseModel):
    """Creating a user - no ID."""
    username: str
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    """User from API - has ID, no password."""
    id: int
    username: str
    email: EmailStr
    created_at: datetime

class UserUpdateRequest(BaseModel):
    """Updating user - all fields optional."""
    username: Optional[str] = None
    email: Optional[EmailStr] = None
```

---

## 17. Use Type Hints Everywhere

### âœ… DO: Full type coverage
```python
from typing import List, Optional, Dict

def get_users(user_ids: List[int]) -> List[User]:
    """Fully typed function."""
    pass

def find_user(username: str) -> Optional[User]:
    """Returns User or None."""
    pass
```

---

## 18. Model Methods

### âœ… DO: Add helper methods to models
```python
class User(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    
    def full_name(self) -> str:
        """Get full name."""
        return f"{self.first_name} {self.last_name}"
    
    def email_domain(self) -> str:
        """Get email domain."""
        return self.email.split("@")[1]
```

---

## 19. Environment-Specific Validation

### âœ… DO: Adjust validation for environments
```python
import os

class User(BaseModel):
    email: EmailStr
    
    @field_validator('email')
    @classmethod
    def validate_email_domain(cls, v: EmailStr) -> EmailStr:
        """In production, only allow company emails."""
        if os.getenv("ENV") == "production":
            if not v.endswith("@company.com"):
                raise ValueError("Must use company email in production")
        return v
```

---

## 20. Keep Models Simple

### âœ… DO: One responsibility per model
```python
class User(BaseModel):
    """Just user data."""
    id: int
    name: str
    email: EmailStr

class UserWithPosts(BaseModel):
    """User with related posts."""
    user: User
    posts: List[Post]
```

### âŒ DON'T: Mix concerns
```python
class User(BaseModel):
    """User with everything!"""
    # User data
    id: int
    name: str
    # Auth data
    password_hash: str
    last_login: datetime
    # Preferences
    theme: str
    language: str
    # Analytics
    page_views: int
    # Too much!
```

---

## Summary Checklist

Before deploying your models, check:

- [ ] Models organized by domain
- [ ] Clear naming conventions
- [ ] Fields documented with descriptions
- [ ] Appropriate types used (EmailStr, HttpUrl, Decimal)
- [ ] Mutable defaults use default_factory
- [ ] Optional fields explicitly marked
- [ ] Models composed for reusability
- [ ] Validation errors handled gracefully
- [ ] Performance optimized
- [ ] Models tested
- [ ] Type hints everywhere
- [ ] Separate request/response models
- [ ] Version models when needed

Follow these practices for production-ready Pydantic models! ğŸ‰
```

---

## C. Common Pitfalls

### File Path: `docs/COMMON_PITFALLS.md`

```markdown
# Common Pydantic Pitfalls and How to Avoid Them

## Pitfall 1: Mutable Defaults

### âŒ Problem
```python
class User(BaseModel):
    tags: List[str] = []  # DANGER!

user1 = User()
user1.tags.append("admin")

user2 = User()
print(user2.tags)  # ['admin'] - WTF?!
```

### âœ… Solution
```python
class User(BaseModel):
    tags: List[str] = Field(default_factory=list)
```

---

## Pitfall 2: Forgetting @classmethod

### âŒ Problem
```python
@field_validator('username')
def validate_username(cls, v):  # Missing @classmethod!
    return v
```

### âœ… Solution
```python
@field_validator('username')
@classmethod
def validate_username(cls, v: str) -> str:
    return v
```

---

## Pitfall 3: Optional Confusion

### âŒ Problem
```python
field: Optional[str]  # Required! Must provide (can be None)
```

### âœ… Solution
```python
field: Optional[str] = None  # Optional! Can omit entirely
```

---

## Pitfall 4: Float for Money

### âŒ Problem
```python
price: float  # Loses precision: 19.99 â†’ 19.989999999
```

### âœ… Solution
```python
from decimal import Decimal
price: Decimal  # Exact: 19.99 stays 19.99
```

---

## Pitfall 5: Not Checking Response Status

### âŒ Problem
```python
response = client.get("/users/1")
user = User.model_validate(response.json())  # Might be error response!
```

### âœ… Solution
```python
response = client.get("/users/1")
if response.status_code == 200:
    user = User.model_validate(response.json())
else:
    handle_error(response)
```

---

## Pitfall 6: Overly Strict Models

### âŒ Problem
```python
class APIResponse(BaseModel):
    # API might add fields in future!
    model_config = ConfigDict(extra='forbid')  # Breaks on new fields
```

### âœ… Solution
```python
class APIResponse(BaseModel):
    # Allow extra fields for forward compatibility
    model_config = ConfigDict(extra='ignore')  # Or 'allow'
```

---

## Pitfall 7: Not Using Type Hints

### âŒ Problem
```python
def get_user(id):  # What type? What returns?
    pass
```

### âœ… Solution
```python
def get_user(id: int) -> User:
    pass
```

---

##Pitfall 8: datetime.now() vs datetime.now

### âŒ Problem
```python
created_at: datetime = datetime.now()  # Evaluated once at class definition!
```

### âœ… Solution
```python
created_at: datetime = Field(default_factory=datetime.now)  # Evaluated per instance
```

---

## Pitfall 9: Not Testing Models

### âŒ Problem
```python
# Model with no tests - breaks in production!
```

### âœ… Solution
```python
def test_user_model():
    user = User(name="Test", email="test@example.com")
    assert user.name == "Test"

def test_user_validation():
    with pytest.raises(ValidationError):
        User(name="Test", email="invalid")
```

---

## Pitfall 10: Ignoring Validation Errors

### âŒ Problem
```python
try:
    user = User.model_validate(data)
except:
    pass  # Silently fails!
```

### âœ… Solution
```python
try:
    user = User.model_validate(data)
except ValidationError as e:
    logger.error(f"Validation failed: {e}")
    raise  # Re-raise or handle appropriately
```
```

---

## D. What You've Learned in Project 3

### ğŸ“ Complete Skill Set

âœ… Why Pydantic for API testing  
âœ… Installing and configuring Pydantic  
âœ… Creating Pydantic models  
âœ… All field types and validation  
âœ… Required vs optional fields  
âœ… Default values and field defaults  
âœ… Nested Pydantic models  
âœ… Lists and collections  
âœ… Custom validators with field_validator  
âœ… Model validators for complex logic  
âœ… Field constraints (min, max, regex)  
âœ… Parsing httpx responses to models  
âœ… Model validation in tests  
âœ… Handling validation errors  
âœ… JSON schema generation  
âœ… Pydantic with async httpx  
âœ… Response model factories  
âœ… Best practices for production  

---

## E. Project Completion! ğŸ‰

**Congratulations!** You've completed **Project 3: Pydantic Models & Schema Validation**!

You now have the skills to:
- Build type-safe API tests
- Validate complex data structures
- Create maintainable test frameworks
- Handle errors gracefully
- Generate test data with factories
- Work with async httpx
- Follow industry best practices

### What's Next?

Continue to:
- **Project 4**: Test Data Generation with Faker
- **Project 5**: Configuration Management & Multi-Environment Testing
- **Project 6**: Authentication & Authorization Testing
- **Project 7**: Building Your Production Test Framework
- **Project 8**: Allure Reporting & Advanced Patterns
- **Project 9**: CI/CD Integration & Production Deployment

---

## F. Final Tips

1. **Practice**: Build models for real APIs
2. **Refactor**: Improve existing models using best practices
3. **Share**: Help others learn Pydantic
4. **Contribute**: Share your patterns with the community

You're now a **Pydantic expert**! ğŸš€

Keep building, keep learning, keep testing! ğŸ’ª

---

**Congratulations on completing Project 3!** ğŸ‰ğŸ‰ğŸ‰
