# 3.3 Your First Pydantic Model

## A. Concept Overview

### What & Why
A **Pydantic model** is a Python class that defines the structure and validation rules for your data. When you create a model, you're essentially creating a contract that says "this is what valid data looks like." Pydantic automatically enforces that contract, catching any violations instantly.

### Analogy
Think of a Pydantic model like a **custom order form at a restaurant**. 

The form has specific fields:
- **Name** (required, must be text)
- **Table number** (required, must be a number)
- **Dish** (required, must be text)
- **Spice level** (optional, must be 1-5)

When a waiter fills out the form, the form itself validates the input. If they write "ABC" for table number, the form rejects it. If they forget the dish name, the form won't accept the order. The Pydantic model is your data's order form ‚Äì it ensures everything is correct before processing.

---

## B. Code Implementation

Let's create our first real Pydantic model for the JSONPlaceholder API's user endpoint!

### File Path: `models/user.py`

```python
"""Pydantic models for User API endpoints."""
from pydantic import BaseModel, EmailStr, Field
from typing import Optional


class Geo(BaseModel):
    """Geographical location model."""
    lat: str
    lng: str


class Address(BaseModel):
    """User address model with nested geo location."""
    street: str
    suite: str
    city: str
    zipcode: str
    geo: Geo


class Company(BaseModel):
    """User company information model."""
    name: str
    catchPhrase: str
    bs: str


class User(BaseModel):
    """Complete user model from JSONPlaceholder API."""
    id: int
    name: str
    username: str
    email: EmailStr
    address: Address
    phone: str
    website: str
    company: Company


class UserCreate(BaseModel):
    """Model for creating a new user (request body)."""
    name: str = Field(..., min_length=1, max_length=100)
    email: EmailStr
    username: str = Field(..., min_length=3, max_length=50)
    phone: Optional[str] = None
    website: Optional[str] = None
```

### **Line-by-Line Explanation:**

1. **`from pydantic import BaseModel, EmailStr, Field`**
   - `BaseModel`: The base class all Pydantic models inherit from
   - `EmailStr`: Special type that validates email format
   - `Field`: Allows additional validation constraints

2. **`from typing import Optional`**
   - `Optional[str]`: Means the field can be a string OR None (optional field)

3. **`class Geo(BaseModel):`**
   - Every Pydantic model inherits from `BaseModel`
   - This gives it validation superpowers

4. **`lat: str`**
   - Type hints define the expected data type
   - If you try to assign a number, Pydantic will try to convert it to string
   - If conversion fails, you get a validation error

5. **`class Address(BaseModel):`**
   - **Nested models** ‚Äì Address contains a Geo object
   - Pydantic validates the entire hierarchy automatically

6. **`geo: Geo`**
   - This field expects a Geo object
   - Pydantic will validate the nested structure recursively

7. **`email: EmailStr`**
   - Validates the email format (requires pydantic[email])
   - Rejects invalid emails like "notanemail" or "missing@domain"

8. **`name: str = Field(..., min_length=1, max_length=100)`**
   - `Field(...)`: The `...` means "required field"
   - `min_length=1`: Name must have at least 1 character
   - `max_length=100`: Name can't exceed 100 characters

9. **`phone: Optional[str] = None`**
   - Optional field (can be omitted or set to None)
   - If provided, must be a string

---

## C. Using Your Model

Now let's use our User model in a real test!

### File Path: `tests/test_users.py`

```python
"""Test user API endpoints with Pydantic validation."""
import httpx
import pytest
from models.user import User, UserCreate
from pydantic import ValidationError


def test_get_single_user():
    """Test fetching a single user and validating with Pydantic."""
    # Create httpx client
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Make GET request
    response = client.get("/users/1")
    
    # Verify status code
    assert response.status_code == 200
    
    # Parse and validate response with Pydantic
    user = User.model_validate(response.json())
    
    # Now we have a validated User object with IDE support!
    assert user.id == 1
    assert user.name == "Leanne Graham"
    assert user.email == "Sincere@april.biz"
    assert user.address.city == "Gwenborough"
    assert user.address.geo.lat == "-37.3159"
    assert user.company.name == "Romaguera-Crona"
    
    print(f"‚úÖ Validated user: {user.name} from {user.address.city}")
    print(f"üìß Email: {user.email}")
    print(f"üè¢ Company: {user.company.name}")


def test_get_all_users():
    """Test fetching multiple users and validating each."""
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    response = client.get("/users")
    assert response.status_code == 200
    
    # Validate a list of users
    users_data = response.json()
    users = [User.model_validate(user_data) for user_data in users_data]
    
    # All 10 users should be valid
    assert len(users) == 10
    
    # Check first user
    assert users[0].id == 1
    assert users[0].name == "Leanne Graham"
    
    print(f"‚úÖ Validated {len(users)} users!")
    for user in users[:3]:  # Print first 3
        print(f"  - {user.name} ({user.email})")


def test_create_user_validation():
    """Test that our UserCreate model validates request data."""
    # Valid user data
    valid_user = UserCreate(
        name="John Doe",
        email="john@example.com",
        username="johndoe"
    )
    
    assert valid_user.name == "John Doe"
    assert valid_user.email == "john@example.com"
    assert valid_user.phone is None  # Optional field
    
    print(f"‚úÖ Valid user created: {valid_user.name}")


def test_invalid_email_rejected():
    """Test that Pydantic rejects invalid email addresses."""
    with pytest.raises(ValidationError) as exc_info:
        UserCreate(
            name="Jane Doe",
            email="not-an-email",  # Invalid email!
            username="janedoe"
        )
    
    # Check the error details
    errors = exc_info.value.errors()
    assert len(errors) == 1
    assert errors[0]["loc"] == ("email",)
    assert "email" in errors[0]["type"]
    
    print(f"‚úÖ Pydantic correctly rejected invalid email!")
    print(f"   Error: {errors[0]['msg']}")


def test_missing_required_field():
    """Test that Pydantic catches missing required fields."""
    with pytest.raises(ValidationError) as exc_info:
        UserCreate(
            name="Bob Smith",
            # Missing 'email' and 'username' - required fields!
        )
    
    errors = exc_info.value.errors()
    assert len(errors) == 2  # Two missing fields
    
    missing_fields = [error["loc"][0] for error in errors]
    assert "email" in missing_fields
    assert "username" in missing_fields
    
    print(f"‚úÖ Pydantic caught {len(errors)} missing required fields!")


def test_field_constraints():
    """Test that Field constraints are enforced."""
    # Name too long
    with pytest.raises(ValidationError) as exc_info:
        UserCreate(
            name="A" * 101,  # 101 characters - exceeds max_length=100
            email="test@example.com",
            username="testuser"
        )
    
    errors = exc_info.value.errors()
    assert errors[0]["loc"] == ("name",)
    assert "at most 100 characters" in errors[0]["msg"]
    
    print("‚úÖ Field constraints working correctly!")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run all user tests
pytest tests/test_users.py -v

# Run a specific test
pytest tests/test_users.py::test_get_single_user -v

# Run with detailed output
pytest tests/test_users.py -v -s
```

### Expected Result

```
tests/test_users.py::test_get_single_user PASSED
‚úÖ Validated user: Leanne Graham from Gwenborough
üìß Email: Sincere@april.biz
üè¢ Company: Romaguera-Crona

tests/test_users.py::test_get_all_users PASSED
‚úÖ Validated 10 users!
  - Leanne Graham (Sincere@april.biz)
  - Ervin Howell (Shanna@melissa.tv)
  - Clementine Bauch (Nathan@yesenia.net)

tests/test_users.py::test_create_user_validation PASSED
‚úÖ Valid user created: John Doe

tests/test_users.py::test_invalid_email_rejected PASSED
‚úÖ Pydantic correctly rejected invalid email!
   Error: value is not a valid email address

tests/test_users.py::test_missing_required_field PASSED
‚úÖ Pydantic caught 2 missing required fields!

tests/test_users.py::test_field_constraints PASSED
‚úÖ Field constraints working correctly!

======================== 6 passed in 1.23s =========================
```

---

## D. Common Stumbling Blocks

### Problem 1: "ValidationError: 1 validation error for User"

**Error message:**
```
pydantic_core._pydantic_core.ValidationError: 1 validation error for User
email
  value is not a valid email address [type=value_error, input_value='notanemail', input_type=str]
```

**What it means:**  
The API returned data that doesn't match your model. In this case, the email field has an invalid format.

**The fix:**
1. Check if the API actually returns what you expect
2. Verify your model matches the API's structure
3. If the API is correct, your model might be too strict
4. If the API is wrong, your test caught a bug! üéâ

---

### Problem 2: "Can't import models.user"

**Error message:**
```
ModuleNotFoundError: No module named 'models'
```

**What it means:**  
Python can't find your models module. This usually happens if you're running pytest from the wrong directory.

**The fix:**
```bash
# Make sure you're in the project root directory
cd my_api_tests

# Run pytest from the root
pytest tests/test_users.py -v
```

**Or add the project root to PYTHONPATH:**
```bash
export PYTHONPATH="${PYTHONPATH}:$(pwd)"
```

---

### Problem 3: Optional vs Required Fields

**Common mistake:**
```python
# Wrong - field is required but can be None
class User(BaseModel):
    name: str | None  # This is required! You MUST provide it (can be None)

# Right - field is optional (can be omitted)
class User(BaseModel):
    name: Optional[str] = None  # This is optional, can be omitted
```

**Key difference:**
- **`str | None`** or **`Optional[str]`** without default: Field is **required** but accepts None
- **`Optional[str] = None`**: Field is **optional** (can be omitted entirely)

---

### Problem 4: CamelCase vs snake_case

**Issue:**  
APIs often use camelCase (`firstName`) but Python uses snake_case (`first_name`).

**The solution (we'll cover this in detail later):**
```python
from pydantic import BaseModel, Field

class User(BaseModel):
    # Use 'alias' to map Python names to API names
    first_name: str = Field(alias="firstName")
    last_name: str = Field(alias="lastName")
```

---

## E. Why This Model Structure?

### 1. **Nested Models**
Real APIs return complex nested data. By creating separate models (Geo, Address, Company), we:
- Keep models focused and reusable
- Make validation clear and organized
- Get better error messages (e.g., "error in address.geo.lat")

### 2. **Separate Request/Response Models**
- **`User`**: Full response model (includes ID, all fields)
- **`UserCreate`**: Request model (no ID, some optional fields)

This separation is important because:
- Responses include fields you don't send (like auto-generated IDs)
- Requests might have different validation rules
- It's clearer what the API expects vs. what it returns

### 3. **Type Hints**
Type hints aren't just for Pydantic ‚Äì they:
- Enable IDE autocomplete
- Catch typos before running tests
- Serve as documentation
- Enable static type checking with mypy

---

## F. Pro Tips

### 1. **Print the Model**
```python
user = User.model_validate(response.json())
print(user)  # Nicely formatted output
```

### 2. **Convert Back to Dictionary**
```python
user_dict = user.model_dump()  # Pydantic V2
# Or: user.dict() in Pydantic V1
```

### 3. **Convert to JSON**
```python
user_json = user.model_dump_json()  # Pydantic V2
# Or: user.json() in Pydantic V1
```

### 4. **Access Nested Fields**
```python
# Clean, readable access with IDE support
city = user.address.city
latitude = user.address.geo.lat
```

---

## G. What You've Learned

‚úÖ How to create a Pydantic model with `BaseModel`  
‚úÖ How to define field types with type hints  
‚úÖ How to create nested models for complex data  
‚úÖ How to use `EmailStr` for email validation  
‚úÖ How to use `Field()` for additional constraints  
‚úÖ How to validate API responses with `model_validate()`  
‚úÖ How to handle validation errors with pytest  
‚úÖ The difference between required and optional fields  

---

## H. What's Next?

In **Lesson 3.4 (Field Types and Validation)**, we'll explore:
- All the built-in Pydantic field types
- How Pydantic handles type coercion
- Special types for URLs, dates, UUIDs, and more

You've just created your first production-quality Pydantic model! üéâ

---

**Does that make sense? Let me know if you'd like me to explain it in a different way.**

**Ready for the next lesson, or would you like to practice this a bit more?**
