# 3.8 Lists and Collections in Models

## A. Concept Overview

### What & Why
APIs often return collections of data ‚Äì lists of users, arrays of products, sets of tags. Pydantic provides powerful validation for collections, including constraints on size, uniqueness, and content. Mastering collection validation ensures your tests catch data quality issues that could break your application.

### Analogy
Think of collection validation like **quality control for a shipping container**.

- **List[str]**: A container that holds strings, allows duplicates, maintains order
- **Set[str]**: A container that automatically removes duplicates
- **Tuple[int, int]**: A fixed-size container ‚Äì exactly 2 integers, no more, no less
- **List constraints**: Rules like "must contain 1-10 items" or "each item must be positive"

Just like a shipping inspector checks container contents, Pydantic validates your collections!

---

## B. Code Implementation

### File Path: `models/collections.py`

```python
"""Comprehensive guide to lists and collections in Pydantic."""
from typing import List, Set, Tuple, Dict, FrozenSet, Deque
from collections import deque
from pydantic import BaseModel, Field, conlist


# ==================== Basic Lists ====================

class BasicLists(BaseModel):
    """Basic list types."""
    # Simple lists
    tags: List[str]                    # List of strings
    scores: List[int]                  # List of integers
    prices: List[float]                # List of floats
    flags: List[bool]                  # List of booleans
    
    # Empty lists allowed by default
    optional_tags: List[str] = Field(default_factory=list)


# ==================== List Constraints ====================

class ConstrainedLists(BaseModel):
    """Lists with size and content constraints."""
    # Min/max length
    at_least_one: List[str] = Field(min_length=1)
    one_to_ten: List[str] = Field(min_length=1, max_length=10)
    exactly_five: List[int] = Field(min_length=5, max_length=5)
    
    # Using conlist (alternative syntax)
    usernames: conlist(str, min_length=1, max_length=100)
    
    # Constrained items
    positive_numbers: List[int] = Field(default_factory=list)
    # Each item validated as int


class ItemConstraints(BaseModel):
    """Constraints on list items themselves."""
    # List of positive integers
    ages: List[int] = Field(default_factory=list)
    
    # List of strings with min length
    names: List[str] = Field(default_factory=list)
    
    # Validate each item's constraints in validators (next lesson!)


# ==================== Sets (Unique Values) ====================

class SetTypes(BaseModel):
    """Sets automatically ensure uniqueness."""
    # Set of strings (duplicates removed)
    unique_tags: Set[str]
    
    # Set of integers
    unique_ids: Set[int] = Field(default_factory=set)
    
    # FrozenSet (immutable set)
    immutable_tags: FrozenSet[str] = frozenset()


# ==================== Tuples (Fixed-Length) ====================

class TupleTypes(BaseModel):
    """Tuples have fixed length and types."""
    # Exactly 2 floats (latitude, longitude)
    coordinates: Tuple[float, float]
    
    # Exactly 3 ints (RGB color)
    rgb_color: Tuple[int, int, int]
    
    # Mixed types in tuple
    person_info: Tuple[str, int, bool]  # (name, age, is_active)
    
    # Variable-length tuple (like a list but immutable)
    var_tuple: Tuple[int, ...]  # Any number of ints


# ==================== Dictionaries ====================

class DictTypes(BaseModel):
    """Dictionary validation."""
    # String keys, any values
    metadata: Dict[str, any] = Field(default_factory=dict)
    
    # String keys and values
    labels: Dict[str, str] = Field(default_factory=dict)
    
    # Integer keys, string values
    id_to_name: Dict[int, str] = Field(default_factory=dict)
    
    # Nested values
    settings: Dict[str, List[str]] = Field(default_factory=dict)


# ==================== Nested Collections ====================

class NestedCollections(BaseModel):
    """Collections within collections."""
    # List of lists
    matrix: List[List[int]]
    
    # List of tuples
    coordinate_list: List[Tuple[float, float]]
    
    # Dict of lists
    categories: Dict[str, List[str]] = Field(default_factory=dict)
    
    # Set of tuples (for unique coordinate pairs)
    unique_coordinates: Set[Tuple[float, float]] = Field(default_factory=set)


# ==================== Lists of Nested Models ====================

class Tag(BaseModel):
    """Simple tag model."""
    id: int
    name: str
    color: str = "blue"


class Product(BaseModel):
    """Product model."""
    id: int
    name: str
    price: float


class ShoppingCart(BaseModel):
    """Shopping cart with list of products."""
    user_id: int
    products: List[Product] = Field(default_factory=list)
    tags: List[Tag] = Field(default_factory=list)
    
    # Constrained list of models
    featured_products: List[Product] = Field(
        default_factory=list,
        min_length=0,
        max_length=5,
        description="Maximum 5 featured products"
    )


# ==================== Real-World Examples ====================

class BlogPost(BaseModel):
    """Blog post with various collection types."""
    id: int
    title: str
    content: str
    
    # List: ordered, allows duplicates
    tags: List[str] = Field(min_length=1, max_length=10)
    
    # Set: unique categories (no duplicates)
    categories: Set[str] = Field(default_factory=set)
    
    # List of comment IDs
    comment_ids: List[int] = Field(default_factory=list)
    
    # Metadata as dict
    metadata: Dict[str, str] = Field(default_factory=dict)


class SearchResults(BaseModel):
    """Search results with pagination."""
    query: str
    total: int
    page: int
    per_page: int = 20
    
    # List of results (can be empty)
    results: List[Dict[str, any]] = Field(default_factory=list)
    
    # Available filters as dict
    filters: Dict[str, List[str]] = Field(default_factory=dict)


class UserPermissions(BaseModel):
    """User permissions using sets."""
    user_id: int
    
    # Sets ensure no duplicate permissions
    roles: Set[str] = Field(default_factory=set)
    permissions: Set[str] = Field(default_factory=set)
    
    # List of granted resources (order matters)
    granted_resources: List[str] = Field(default_factory=list)


class Matrix(BaseModel):
    """2D matrix representation."""
    rows: int = Field(gt=0)
    cols: int = Field(gt=0)
    data: List[List[float]]  # Nested lists


class DataPoint(BaseModel):
    """Single data point."""
    x: float
    y: float
    label: str


class Dataset(BaseModel):
    """Dataset with multiple collection types."""
    name: str
    
    # List of data points (ordered)
    points: List[DataPoint] = Field(min_length=1)
    
    # Unique labels
    unique_labels: Set[str] = Field(default_factory=set)
    
    # Feature ranges as tuples
    x_range: Tuple[float, float]  # (min, max)
    y_range: Tuple[float, float]  # (min, max)
    
    # Statistics
    stats: Dict[str, float] = Field(default_factory=dict)


class APIBatchRequest(BaseModel):
    """Batch API request."""
    # List of IDs to process (1-100 items)
    ids: List[int] = Field(min_length=1, max_length=100)
    
    # Operations to perform (at least one)
    operations: List[str] = Field(min_length=1)
    
    # Options as dict
    options: Dict[str, any] = Field(default_factory=dict)


class ColorPalette(BaseModel):
    """Color palette using tuples."""
    name: str
    
    # List of RGB colors (each color is a tuple)
    colors: List[Tuple[int, int, int]] = Field(min_length=1, max_length=10)
    
    # Primary color (single tuple)
    primary: Tuple[int, int, int]
    
    # Unique color names
    color_names: Set[str] = Field(default_factory=set)
```

---

## C. Testing Collections

### File Path: `tests/test_collections.py`

```python
"""Tests demonstrating collection validation in Pydantic."""
import pytest
from pydantic import ValidationError

from models.collections import (
    BasicLists,
    ConstrainedLists,
    SetTypes,
    TupleTypes,
    DictTypes,
    NestedCollections,
    ShoppingCart,
    Product,
    Tag,
    BlogPost,
    UserPermissions,
    Dataset,
    DataPoint,
    ColorPalette,
    APIBatchRequest,
)


def test_basic_lists():
    """Test basic list validation."""
    data = BasicLists(
        tags=["python", "testing", "api"],
        scores=[85, 90, 78, 92],
        prices=[19.99, 29.99, 9.99],
        flags=[True, False, True]
    )
    
    assert len(data.tags) == 3
    assert data.scores[0] == 85
    assert data.prices[2] == 9.99
    assert data.flags[1] is False
    assert data.optional_tags == []  # Default empty list
    
    print("‚úÖ Basic lists validated!")


def test_list_type_validation():
    """Test that list items are type-validated."""
    # Valid - strings converted to ints if possible
    data = BasicLists(
        tags=["a", "b"],
        scores=[1, 2, "3"],  # "3" converted to 3
        prices=[1.5, 2.5],
        flags=[True, False]
    )
    assert data.scores[2] == 3
    
    # Invalid - can't convert "abc" to int
    with pytest.raises(ValidationError):
        BasicLists(
            tags=["a"],
            scores=[1, "abc"],  # Can't convert!
            prices=[1.5],
            flags=[True]
        )
    
    print("‚úÖ List item types validated!")


def test_list_constraints():
    """Test list size constraints."""
    # Valid - meets constraints
    data = ConstrainedLists(
        at_least_one=["item"],
        one_to_ten=["a", "b", "c"],
        exactly_five=[1, 2, 3, 4, 5],
        usernames=["user1", "user2"]
    )
    assert len(data.exactly_five) == 5
    
    # Invalid - empty list (min_length=1)
    with pytest.raises(ValidationError) as exc:
        ConstrainedLists(
            at_least_one=[],  # Too few!
            one_to_ten=["a"],
            exactly_five=[1, 2, 3, 4, 5],
            usernames=["user1"]
        )
    assert "at_least_one" in str(exc.value)
    
    # Invalid - too many items
    with pytest.raises(ValidationError):
        ConstrainedLists(
            at_least_one=["item"],
            one_to_ten=["a"] * 11,  # Too many! (11 > 10)
            exactly_five=[1, 2, 3, 4, 5],
            usernames=["user1"]
        )
    
    print("‚úÖ List constraints enforced!")


def test_sets_remove_duplicates():
    """Test that sets automatically remove duplicates."""
    data = SetTypes(
        unique_tags=["python", "testing", "python", "api", "testing"]
        # Duplicates will be removed!
    )
    
    # Only unique values remain
    assert len(data.unique_tags) == 3
    assert "python" in data.unique_tags
    assert "testing" in data.unique_tags
    assert "api" in data.unique_tags
    
    print("‚úÖ Sets remove duplicates automatically!")


def test_tuples_fixed_length():
    """Test tuple fixed-length validation."""
    # Valid - correct lengths
    data = TupleTypes(
        coordinates=(42.3601, -71.0589),
        rgb_color=(255, 128, 0),
        person_info=("John", 30, True)
    )
    
    assert data.coordinates[0] == 42.3601
    assert data.rgb_color == (255, 128, 0)
    assert data.person_info[0] == "John"
    
    # Invalid - wrong length
    with pytest.raises(ValidationError):
        TupleTypes(
            coordinates=(42.3601,),  # Only 1 item, need 2!
            rgb_color=(255, 128, 0),
            person_info=("John", 30, True)
        )
    
    # Invalid - wrong type
    with pytest.raises(ValidationError):
        TupleTypes(
            coordinates=(42.3601, -71.0589),
            rgb_color=("red", "green", "blue"),  # Need ints!
            person_info=("John", 30, True)
        )
    
    print("‚úÖ Tuple length and types validated!")


def test_dictionaries():
    """Test dictionary validation."""
    data = DictTypes(
        metadata={"key1": "value1", "key2": 123, "key3": True},
        labels={"type": "admin", "status": "active"},
        id_to_name={1: "Alice", 2: "Bob", 3: "Charlie"},
        settings={"colors": ["red", "blue"], "sizes": ["S", "M", "L"]}
    )
    
    assert data.metadata["key2"] == 123
    assert data.labels["type"] == "admin"
    assert data.id_to_name[1] == "Alice"
    assert "red" in data.settings["colors"]
    
    print("‚úÖ Dictionaries validated!")


def test_nested_collections():
    """Test nested collections."""
    data = NestedCollections(
        matrix=[[1, 2, 3], [4, 5, 6], [7, 8, 9]],
        coordinate_list=[(1.0, 2.0), (3.0, 4.0)],
        categories={"colors": ["red", "blue"], "sizes": ["S", "M"]},
        unique_coordinates={(1.0, 2.0), (3.0, 4.0), (1.0, 2.0)}  # Duplicate removed
    )
    
    assert data.matrix[1][2] == 6
    assert data.coordinate_list[0] == (1.0, 2.0)
    assert len(data.unique_coordinates) == 2  # Duplicate removed
    
    print("‚úÖ Nested collections validated!")


def test_list_of_models():
    """Test list of Pydantic models."""
    cart = ShoppingCart(
        user_id=123,
        products=[
            {"id": 1, "name": "Python Book", "price": 29.99},
            {"id": 2, "name": "Laptop", "price": 999.99}
        ],
        tags=[
            {"id": 1, "name": "programming"},
            {"id": 2, "name": "electronics", "color": "red"}
        ]
    )
    
    assert len(cart.products) == 2
    assert isinstance(cart.products[0], Product)
    assert cart.products[0].name == "Python Book"
    assert cart.tags[0].color == "blue"  # Default value
    assert cart.tags[1].color == "red"   # Custom value
    
    print("‚úÖ List of models validated!")


def test_list_of_models_constraint():
    """Test constrained list of models."""
    # Valid - within limit
    cart = ShoppingCart(
        user_id=123,
        featured_products=[
            {"id": i, "name": f"Product {i}", "price": 10.0}
            for i in range(5)  # Exactly 5 items
        ]
    )
    assert len(cart.featured_products) == 5
    
    # Invalid - too many
    with pytest.raises(ValidationError):
        ShoppingCart(
            user_id=123,
            featured_products=[
                {"id": i, "name": f"Product {i}", "price": 10.0}
                for i in range(6)  # 6 items > max 5
            ]
        )
    
    print("‚úÖ List of models constraint enforced!")


def test_blog_post_collections():
    """Test real-world blog post with mixed collections."""
    post = BlogPost(
        id=1,
        title="My Post",
        content="Content here",
        tags=["python", "testing"],
        categories={"programming", "tutorial", "programming"},  # Duplicate removed
        comment_ids=[10, 20, 30]
    )
    
    assert len(post.tags) == 2
    assert len(post.categories) == 2  # Duplicate "programming" removed
    assert post.comment_ids[1] == 20
    
    print("‚úÖ Blog post collections validated!")


def test_user_permissions():
    """Test permission sets."""
    user = UserPermissions(
        user_id=456,
        roles={"admin", "editor", "admin"},  # Duplicate removed
        permissions={"read", "write", "delete"}
    )
    
    assert len(user.roles) == 2  # "admin" appears once
    assert "admin" in user.roles
    assert "write" in user.permissions
    
    print("‚úÖ Permission sets validated!")


def test_dataset_with_points():
    """Test dataset with list of models."""
    dataset = Dataset(
        name="Test Dataset",
        points=[
            DataPoint(x=1.0, y=2.0, label="A"),
            DataPoint(x=3.0, y=4.0, label="B"),
            DataPoint(x=5.0, y=6.0, label="A")  # Duplicate label
        ],
        unique_labels={"A", "B", "A"},  # Duplicate removed
        x_range=(0.0, 10.0),
        y_range=(0.0, 10.0)
    )
    
    assert len(dataset.points) == 3
    assert len(dataset.unique_labels) == 2  # Only A and B
    assert dataset.points[1].y == 4.0
    
    print("‚úÖ Dataset with points validated!")


def test_color_palette():
    """Test color palette with RGB tuples."""
    palette = ColorPalette(
        name="Ocean",
        colors=[
            (0, 119, 182),    # Blue
            (0, 180, 216),    # Light blue
            (144, 224, 239)   # Sky blue
        ],
        primary=(0, 119, 182),
        color_names={"blue", "light-blue", "sky-blue"}
    )
    
    assert len(palette.colors) == 3
    assert palette.colors[0] == (0, 119, 182)
    assert palette.primary == (0, 119, 182)
    assert "blue" in palette.color_names
    
    print("‚úÖ Color palette validated!")


def test_api_batch_request():
    """Test batch request with constraints."""
    # Valid
    request = APIBatchRequest(
        ids=[1, 2, 3, 4, 5],
        operations=["update", "delete"]
    )
    assert len(request.ids) == 5
    
    # Invalid - too many IDs (max 100)
    with pytest.raises(ValidationError):
        APIBatchRequest(
            ids=list(range(101)),  # 101 items!
            operations=["update"]
        )
    
    # Invalid - no operations (min 1)
    with pytest.raises(ValidationError):
        APIBatchRequest(
            ids=[1, 2],
            operations=[]  # Empty!
        )
    
    print("‚úÖ Batch request constraints enforced!")


def test_empty_vs_none():
    """Test difference between empty collections and None."""
    # Empty list (valid)
    data1 = BasicLists(
        tags=[],  # Empty list is valid
        scores=[],
        prices=[],
        flags=[]
    )
    assert data1.tags == []
    
    # None not allowed (field expects list)
    with pytest.raises(ValidationError):
        BasicLists(
            tags=None,  # Can't be None!
            scores=[],
            prices=[],
            flags=[]
        )
    
    print("‚úÖ Empty list vs None understood!")
```

---

## D. Connect & Apply

### How to Test It

```bash
# Run all tests
pytest tests/test_collections.py -v

# Run with output
pytest tests/test_collections.py -v -s
```

### Expected Result

```
tests/test_collections.py::test_basic_lists PASSED
‚úÖ Basic lists validated!

tests/test_collections.py::test_sets_remove_duplicates PASSED
‚úÖ Sets remove duplicates automatically!

tests/test_collections.py::test_list_constraints PASSED
‚úÖ List constraints enforced!

======================== 16 passed in 0.95s =========================
```

---

## E. Common Stumbling Blocks

### Problem 1: Lists vs Sets vs Tuples

| Type | Ordered? | Duplicates? | Mutable? | Use Case |
|------|----------|-------------|----------|----------|
| `List[T]` | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | Ordered collections |
| `Set[T]` | ‚ùå No | ‚ùå No | ‚úÖ Yes | Unique values |
| `Tuple[T, ...]` | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | Fixed-length |

---

### Problem 2: Mutable Default Collections

```python
# ‚ùå WRONG
class Model(BaseModel):
    items: List[str] = []

# ‚úÖ CORRECT
class Model(BaseModel):
    items: List[str] = Field(default_factory=list)
```

---

### Problem 3: Type Coercion in Lists

Pydantic tries to coerce list items:
```python
scores: List[int] = [1, "2", 3.0]  # All become int: [1, 2, 3]
scores: List[int] = [1, "abc"]     # ValidationError - can't convert "abc"
```

---

## F. Quick Reference

### Collection Types
```python
# Lists
items: List[str]                              # Any length
items: List[str] = Field(min_length=1)       # At least 1
items: List[str] = Field(max_length=10)      # At most 10

# Sets
unique: Set[str]                              # Unique values

# Tuples
pair: Tuple[int, int]                         # Exactly 2 ints
coords: Tuple[float, float, float]           # Exactly 3 floats

# Dicts
data: Dict[str, Any]                          # String keys, any values
```

---

## G. What You've Learned

‚úÖ List validation with type checking  
‚úÖ List constraints (min/max length)  
‚úÖ Sets for automatic deduplication  
‚úÖ Tuples for fixed-length collections  
‚úÖ Dictionary validation  
‚úÖ Nested collections  
‚úÖ Lists of Pydantic models  
‚úÖ Real-world collection patterns  

---

## H. What's Next?

In **Lesson 3.9 (Custom Validators with field_validator)**, we'll learn:
- Writing custom validation logic
- The `@field_validator` decorator
- Validating individual fields
- Cross-field validation

You're now a collection validation expert! üéâ

---

**Does that make sense? Let me know if you'd like me to explain it in a different way.**

**Ready for the next lesson, or would you like to practice this a bit more?**
