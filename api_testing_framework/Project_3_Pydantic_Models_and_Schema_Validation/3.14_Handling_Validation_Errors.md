# 3.14 Handling Validation Errors

## A. Concept Overview

### What & Why
Validation errors aren't failures ‚Äì they're **valuable information**! When Pydantic catches invalid data, it provides detailed error messages showing exactly what's wrong. Learning to handle these errors properly helps you debug API issues, log meaningful information, and build robust test frameworks.

### Analogy
Think of validation errors like **a detailed inspection report from a mechanic**.

When your car fails inspection, the mechanic doesn't just say "broken." They give you a detailed report:
- **Location**: "Front left tire"
- **Problem**: "Tread depth below minimum"
- **Expected**: "4mm minimum"
- **Actual**: "2mm"

Pydantic's validation errors work the same way ‚Äì precise, actionable information!

---

## B. Code Implementation

### File Path: `utils/error_handlers.py`

```python
"""Utilities for handling Pydantic validation errors."""
from typing import List, Dict, Any
from pydantic import ValidationError


def format_validation_error(error: ValidationError) -> str:
    """Format validation error into readable string."""
    lines = ["Validation Error:"]
    
    for err in error.errors():
        location = " -> ".join(str(loc) for loc in err["loc"])
        lines.append(f"  Field: {location}")
        lines.append(f"    Error: {err['msg']}")
        lines.append(f"    Type: {err['type']}")
        if "input" in err:
            lines.append(f"    Input: {err['input']}")
        lines.append("")
    
    return "\n".join(lines)


def get_error_fields(error: ValidationError) -> List[str]:
    """Extract list of fields that failed validation."""
    return [str(err["loc"][0]) if err["loc"] else "unknown" for err in error.errors()]


def get_error_dict(error: ValidationError) -> Dict[str, List[str]]:
    """Convert validation error to dictionary mapping fields to error messages."""
    error_dict = {}
    
    for err in error.errors():
        field = " -> ".join(str(loc) for loc in err["loc"])
        if field not in error_dict:
            error_dict[field] = []
        error_dict[field].append(err["msg"])
    
    return error_dict


def is_missing_field_error(error: ValidationError, field: str) -> bool:
    """Check if error is due to a missing required field."""
    for err in error.errors():
        if err["type"] == "missing" and field in [str(loc) for loc in err["loc"]]:
            return True
    return False


def is_type_error(error: ValidationError, field: str) -> bool:
    """Check if error is due to wrong type."""
    for err in error.errors():
        if "type" in err["type"] and field in [str(loc) for loc in err["loc"]]:
            return True
    return False


class ValidationErrorLogger:
    """Logger for validation errors with context."""
    
    def __init__(self):
        self.errors = []
    
    def log(self, context: str, error: ValidationError, data: Any = None):
        """Log a validation error with context."""
        self.errors.append({
            "context": context,
            "error": error,
            "data": data,
            "error_count": len(error.errors()),
            "fields": get_error_fields(error)
        })
    
    def has_errors(self) -> bool:
        """Check if any errors were logged."""
        return len(self.errors) > 0
    
    def get_summary(self) -> Dict[str, Any]:
        """Get summary of all logged errors."""
        return {
            "total_errors": len(self.errors),
            "contexts": [e["context"] for e in self.errors],
            "affected_fields": list(set(
                field for e in self.errors for field in e["fields"]
            ))
        }
    
    def print_report(self):
        """Print detailed error report."""
        if not self.errors:
            print("No validation errors logged.")
            return
        
        print(f"\n{'='*60}")
        print(f"VALIDATION ERROR REPORT")
        print(f"{'='*60}")
        print(f"Total Errors: {len(self.errors)}\n")
        
        for idx, error_info in enumerate(self.errors, 1):
            print(f"{idx}. {error_info['context']}")
            print(f"   Fields affected: {', '.join(error_info['fields'])}")
            print(f"   Error count: {error_info['error_count']}")
            print()
```

---

### File Path: `tests/test_error_handling.py`

```python
"""Tests for handling validation errors."""
import httpx
import pytest
from pydantic import ValidationError, BaseModel, EmailStr, Field

from utils.error_handlers import (
    format_validation_error,
    get_error_fields,
    get_error_dict,
    is_missing_field_error,
    is_type_error,
    ValidationErrorLogger
)


# ==================== Understanding Error Structure ====================

class SimpleModel(BaseModel):
    name: str
    age: int = Field(ge=0, le=150)
    email: EmailStr


def test_examine_error_structure():
    """Examine the structure of validation errors."""
    invalid_data = {
        "name": "",
        "age": 200,  # Too high
        "email": "not-an-email"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(invalid_data)
    
    error = exc_info.value
    
    # errors() returns list of error dictionaries
    errors = error.errors()
    
    print(f"\n{'='*60}")
    print(f"Total errors: {len(errors)}")
    
    for err in errors:
        print(f"\n  Location: {err['loc']}")
        print(f"  Type: {err['type']}")
        print(f"  Message: {err['msg']}")
        if "input" in err:
            print(f"  Input: {err['input']}")
    
    assert len(errors) >= 2  # At least age and email errors
    print(f"\n‚úÖ Examined error structure")


# ==================== Catching Specific Errors ====================

def test_catch_missing_field_error():
    """Test catching missing required field errors."""
    incomplete_data = {
        "name": "John",
        # Missing age and email
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(incomplete_data)
    
    error = exc_info.value
    missing_fields = [
        err["loc"][0] for err in error.errors() if err["type"] == "missing"
    ]
    
    assert "age" in missing_fields
    assert "email" in missing_fields
    
    print(f"‚úÖ Caught missing fields: {missing_fields}")


def test_catch_type_error():
    """Test catching type validation errors."""
    wrong_type_data = {
        "name": "John",
        "age": "not-a-number",  # Should be int
        "email": "john@example.com"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(wrong_type_data)
    
    error = exc_info.value
    type_errors = [
        err["loc"][0] for err in error.errors() if "int_parsing" in err["type"]
    ]
    
    assert "age" in type_errors
    
    print(f"‚úÖ Caught type errors: {type_errors}")


def test_catch_value_error():
    """Test catching value constraint errors."""
    invalid_value_data = {
        "name": "John",
        "age": 200,  # Exceeds max of 150
        "email": "john@example.com"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(invalid_value_data)
    
    error = exc_info.value
    errors = error.errors()
    
    # Check for constraint violation
    age_error = next(err for err in errors if err["loc"][0] == "age")
    assert "less than or equal to" in age_error["msg"]
    
    print(f"‚úÖ Caught value constraint error")


# ==================== Using Error Handlers ====================

def test_format_validation_error():
    """Test formatting validation errors."""
    invalid_data = {
        "name": "John",
        "age": -5,
        "email": "invalid"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(invalid_data)
    
    formatted = format_validation_error(exc_info.value)
    
    assert "Validation Error:" in formatted
    assert "Field:" in formatted
    assert "Error:" in formatted
    
    print("\n" + formatted)
    print("‚úÖ Formatted error successfully")


def test_get_error_fields():
    """Test extracting error fields."""
    invalid_data = {
        "name": "John",
        "age": -5,
        "email": "invalid"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(invalid_data)
    
    fields = get_error_fields(exc_info.value)
    
    assert "age" in fields
    assert "email" in fields
    
    print(f"‚úÖ Error fields: {fields}")


def test_get_error_dict():
    """Test converting errors to dictionary."""
    invalid_data = {
        "name": "John",
        "age": -5,
        "email": "invalid"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(invalid_data)
    
    error_dict = get_error_dict(exc_info.value)
    
    assert "age" in error_dict
    assert "email" in error_dict
    assert isinstance(error_dict["age"], list)
    
    print(f"\n‚úÖ Error dictionary:")
    for field, messages in error_dict.items():
        print(f"  {field}: {messages}")


def test_is_missing_field_error():
    """Test checking for missing field errors."""
    incomplete_data = {"name": "John"}
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(incomplete_data)
    
    assert is_missing_field_error(exc_info.value, "age")
    assert is_missing_field_error(exc_info.value, "email")
    assert not is_missing_field_error(exc_info.value, "name")
    
    print("‚úÖ Missing field detection works")


# ==================== Error Logger ====================

def test_validation_error_logger():
    """Test validation error logger."""
    logger = ValidationErrorLogger()
    
    # Log some errors
    invalid_data_1 = {"name": "John", "age": -5, "email": "invalid"}
    invalid_data_2 = {"name": "Jane"}  # Missing fields
    
    try:
        SimpleModel.model_validate(invalid_data_1)
    except ValidationError as e:
        logger.log("User 1 validation", e, invalid_data_1)
    
    try:
        SimpleModel.model_validate(invalid_data_2)
    except ValidationError as e:
        logger.log("User 2 validation", e, invalid_data_2)
    
    assert logger.has_errors()
    
    summary = logger.get_summary()
    assert summary["total_errors"] == 2
    assert "age" in summary["affected_fields"]
    assert "email" in summary["affected_fields"]
    
    print("\n")
    logger.print_report()
    print("‚úÖ Error logger works!")


# ==================== Graceful Degradation ====================

def test_partial_validation_with_error_tracking():
    """Test validating multiple items with error tracking."""
    from models.api_models import User
    
    items = [
        {
            "id": 1,
            "name": "Valid User",
            "username": "validuser",
            "email": "valid@example.com",
            "address": {
                "street": "123 Main",
                "suite": "Apt 1",
                "city": "City",
                "zipcode": "12345",
                "geo": {"lat": "0", "lng": "0"}
            },
            "phone": "123-456-7890",
            "website": "example.com",
            "company": {
                "name": "Company",
                "catchPhrase": "Phrase",
                "bs": "BS"
            }
        },
        {
            "id": "invalid",  # Wrong type
            "name": "Invalid User"
        },
        {
            "id": 3,
            "email": "not-an-email"  # Invalid format
        }
    ]
    
    valid_items = []
    errors = []
    
    for idx, item in enumerate(items):
        try:
            validated = User.model_validate(item)
            valid_items.append(validated)
        except ValidationError as e:
            errors.append((idx, e))
    
    assert len(valid_items) == 1
    assert len(errors) == 2
    
    print(f"‚úÖ Validated: {len(valid_items)}, Errors: {len(errors)}")


# ==================== API Error Handling Pattern ====================

def test_api_error_handling_pattern():
    """Test real-world API error handling."""
    from models.api_models import User
    
    client = httpx.Client(base_url="https://jsonplaceholder.typicode.com")
    
    # Valid endpoint
    response = client.get("/users/1")
    
    try:
        user = User.model_validate(response.json())
        print(f"‚úÖ Successfully validated user: {user.name}")
    except ValidationError as e:
        print(f"‚ùå Validation failed:")
        print(format_validation_error(e))
        pytest.fail("API response validation failed")


# ==================== Custom Error Messages ====================

class CustomErrorModel(BaseModel):
    username: str = Field(min_length=3, description="Username must be at least 3 characters")
    age: int = Field(ge=13, le=120, description="Age must be between 13 and 120")


def test_custom_error_messages():
    """Test models with descriptive field descriptions."""
    invalid_data = {
        "username": "ab",  # Too short
        "age": 10  # Too young
    }
    
    with pytest.raises(ValidationError) as exc_info:
        CustomErrorModel.model_validate(invalid_data)
    
    error = exc_info.value
    
    # Field descriptions are part of the schema
    print("\n" + format_validation_error(error))
    print("‚úÖ Custom error messages work")


# ==================== Error Recovery ====================

def test_error_recovery_with_defaults():
    """Test recovering from validation errors with safe defaults."""
    class FlexibleModel(BaseModel):
        name: str = "Unknown"
        age: int = 0
        email: str = "no-email@example.com"
    
    # Even with partial data, we get a valid object
    partial_data = {"name": "John"}
    
    model = FlexibleModel.model_validate(partial_data)
    
    assert model.name == "John"
    assert model.age == 0  # Default used
    assert model.email == "no-email@example.com"  # Default used
    
    print("‚úÖ Error recovery with defaults works")


# ==================== Logging Validation Failures ====================

def test_log_validation_failures():
    """Test logging validation failures for debugging."""
    import logging
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    invalid_data = {
        "name": "John",
        "age": 200,
        "email": "invalid"
    }
    
    try:
        SimpleModel.model_validate(invalid_data)
    except ValidationError as e:
        # Log detailed error information
        logger.error("Validation failed")
        logger.error(f"Errors: {len(e.errors())}")
        logger.error(f"Fields: {get_error_fields(e)}")
        
        for err in e.errors():
            logger.error(f"  {err['loc']}: {err['msg']}")
    
    print("‚úÖ Validation failures logged")


# ==================== Testing Error Messages ====================

def test_error_message_content():
    """Test that error messages contain expected information."""
    invalid_data = {
        "name": "John",
        "age": 200,
        "email": "john@example.com"
    }
    
    with pytest.raises(ValidationError) as exc_info:
        SimpleModel.model_validate(invalid_data)
    
    errors = exc_info.value.errors()
    age_error = next(err for err in errors if err["loc"][0] == "age")
    
    # Check error message contains useful info
    assert "150" in age_error["msg"]  # Max value mentioned
    
    print(f"‚úÖ Error message: {age_error['msg']}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run all error handling tests
pytest tests/test_error_handling.py -v -s
```

### Expected Result

```
tests/test_error_handling.py::test_examine_error_structure PASSED
Total errors: 2
‚úÖ Examined error structure

tests/test_error_handling.py::test_format_validation_error PASSED
Validation Error:
  Field: age
    Error: Input should be less than or equal to 150
‚úÖ Formatted error successfully

... [all tests pass]

======================== 16 passed in 2.34s =========================
```

---

## D. Common Error Types

| Error Type | Meaning | Example |
|------------|---------|---------|
| `missing` | Required field not provided | Missing `email` field |
| `string_type` | Expected string, got other type | `name` is int instead of str |
| `int_parsing` | Can't convert to integer | `age` is "abc" |
| `value_error` | Value doesn't meet constraint | `age` is 200 (max 150) |
| `email` | Invalid email format | `email` is "notanemail" |

---

## E. What You've Learned

‚úÖ Understanding validation error structure  
‚úÖ Catching specific error types  
‚úÖ Formatting errors for readability  
‚úÖ Extracting error information  
‚úÖ Building error loggers  
‚úÖ Graceful degradation patterns  
‚úÖ API error handling strategies  
‚úÖ Error recovery with defaults  
‚úÖ Logging validation failures  

---

## F. What's Next?

In **Lesson 3.15 (JSON Schema Generation)**, we'll learn:
- Generating JSON schemas from models
- Schema validation
- OpenAPI integration

Almost done with Project 3! üéâ

---

**Ready for the next lesson?**
