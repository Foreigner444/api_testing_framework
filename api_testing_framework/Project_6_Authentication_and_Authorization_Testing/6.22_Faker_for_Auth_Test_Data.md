# Lesson 6.23: Best Practices for Auth Testing

## A. Concept Overview

### What & Why
**Authentication and authorization testing best practices** consolidate proven patterns for secure, comprehensive auth testing. This lesson synthesizes everything you've learned into actionable guidelines for production-ready test frameworks.

### Analogy
Best practices are like a pilot's checklistâ€”individual lessons taught how to fly (specific auth methods), but the checklist ensures you never miss critical steps (comprehensive auth testing) before takeoff (production deployment).

---

## B. Code Implementation

### Complete Auth Testing Framework

**File Path:** `auth/auth_manager.py`

```python
from typing import Optional
from pydantic import SecretStr
from pydantic_settings import BaseSettings, SettingsConfigDict
import httpx
from httpx import Auth, Request
import jwt


class AuthConfig(BaseSettings):
    """Complete authentication configuration."""
    
    # API Key Auth
    api_key: Optional[SecretStr] = None
    api_key_header: str = "X-API-Key"
    
    # Bearer Token Auth
    bearer_token: Optional[SecretStr] = None
    
    # Basic Auth
    basic_username: Optional[str] = None
    basic_password: Optional[SecretStr] = None
    
    # OAuth
    oauth_client_id: Optional[str] = None
    oauth_client_secret: Optional[SecretStr] = None
    oauth_token_url: Optional[str] = None
    
    # JWT
    jwt_secret: Optional[SecretStr] = None
    jwt_algorithm: str = "HS256"
    
    # Auth type selection
    auth_type: str = "bearer"  # api_key, bearer, basic, oauth
    
    model_config = SettingsConfigDict(
        env_file=".env",
        env_prefix="AUTH_",
        case_sensitive=False
    )


class MultiAuth(Auth):
    """Authentication supporting multiple methods."""
    
    def __init__(self, config: AuthConfig):
        self.config = config
    
    def auth_flow(self, request: Request):
        """Apply authentication based on configured method."""
        
        if self.config.auth_type == "api_key" and self.config.api_key:
            request.headers[self.config.api_key_header] = self.config.api_key.get_secret_value()
        
        elif self.config.auth_type == "bearer" and self.config.bearer_token:
            request.headers["Authorization"] = f"Bearer {self.config.bearer_token.get_secret_value()}"
        
        elif self.config.auth_type == "basic" and self.config.basic_username:
            import base64
            creds = f"{self.config.basic_username}:{self.config.basic_password.get_secret_value()}"
            encoded = base64.b64encode(creds.encode()).decode()
            request.headers["Authorization"] = f"Basic {encoded}"
        
        yield request


def create_authenticated_client(config: AuthConfig) -> httpx.Client:
    """Create httpx client with configured authentication."""
    
    auth = MultiAuth(config)
    
    return httpx.Client(
        base_url="https://api.example.com",
        auth=auth
    )
```

---

### Complete Auth Test Suite

**File Path:** `tests/test_auth_complete.py`

```python
import httpx
import pytest
from auth.auth_manager import AuthConfig, create_authenticated_client


class TestAuthentication:
    """Comprehensive authentication tests."""
    
    def test_no_auth_fails(self):
        """Test unauthenticated requests fail."""
        client = httpx.Client(base_url="https://api.example.com")
        response = client.get("/protected")
        assert response.status_code == 401
    
    def test_invalid_credentials_fail(self):
        """Test invalid credentials are rejected."""
        config = AuthConfig(
            auth_type="bearer",
            bearer_token="invalid_token"
        )
        client = create_authenticated_client(config)
        response = client.get("/protected")
        assert response.status_code == 401
    
    def test_valid_auth_succeeds(self):
        """Test valid authentication grants access."""
        config = AuthConfig(
            auth_type="bearer",
            bearer_token="valid_token_from_env"
        )
        client = create_authenticated_client(config)
        response = client.get("/protected")
        assert response.status_code == 200


class TestAuthorization:
    """Comprehensive authorization tests."""
    
    @pytest.mark.parametrize("role,endpoint,expected_status", [
        ("admin", "/admin/users", 200),
        ("user", "/admin/users", 403),
        ("admin", "/users/123", 200),
        ("user", "/users/123", 403),
        ("user", "/profile", 200),
    ])
    def test_role_based_access(self, role, endpoint, expected_status):
        """Test role-based access control."""
        tokens = {
            "admin": "admin_token",
            "user": "user_token"
        }
        
        config = AuthConfig(
            auth_type="bearer",
            bearer_token=tokens[role]
        )
        
        client = create_authenticated_client(config)
        response = client.get(endpoint)
        
        assert response.status_code == expected_status


class TestSecurityBestPractices:
    """Security-focused tests."""
    
    def test_passwords_not_logged(self):
        """Test passwords never appear in logs/responses."""
        client = httpx.Client(base_url="https://api.example.com")
        
        response = client.post(
            "/login",
            json={"username": "test", "password": "secret123"}
        )
        
        # Password should not be in response
        response_text = response.text.lower()
        assert "secret123" not in response_text
    
    def test_rate_limiting_on_auth_endpoints(self):
        """Test rate limiting protects auth endpoints."""
        client = httpx.Client(base_url="https://api.example.com")
        
        # Rapid login attempts
        for i in range(20):
            response = client.post(
                "/login",
                json={"username": "test", "password": "wrong"}
            )
        
        # Should be rate limited
        assert response.status_code == 429
    
    def test_https_required_for_auth(self):
        """Test authentication requires HTTPS."""
        # HTTP should be rejected or redirected
        client = httpx.Client(base_url="http://api.example.com")
        
        response = client.post(
            "/login",
            json={"username": "test", "password": "secret"}
        )
        
        # Should reject or redirect to HTTPS
        assert response.status_code in [301, 302, 403]
```

---

## C. Connect & Apply

Run complete auth test suite with all best practices implemented.

---

## D. Common Stumbling Blocks

**Mistake:** Only testing happy paths
**Fix:** Test failures, edge cases, security scenarios

---

## ðŸŽ¯ Key Takeaways

âœ… Test both authentication AND authorization  
âœ… Test all roles and permissions  
âœ… Test security (rate limiting, HTTPS, etc.)  
âœ… Never log credentials  
âœ… Use configuration for environment-specific auth  
âœ… Comprehensive test coverage prevents security issues  

---

## ðŸŽ‰ Congratulations!

You've completed **Project 6: Authentication & Authorization Testing**!

You've mastered:
- Authentication vs Authorization
- API Keys, Bearer tokens, Basic auth, OAuth 2.0
- JWT validation with Pydantic
- Session and cookie authentication
- Role-based and permission-based testing
- Security testing fundamentals
- Rate limiting and token refresh
- Faker for auth test data

**You're now ready to build production-ready auth testing frameworks!** ðŸš€

---

## What's Next?

Ready to continue your journey?

1. **Project 7:** Building Your Production Test Framework (3-layer architecture)
2. **Project 8:** Allure Reporting & Advanced Patterns
3. **Project 9:** CI/CD Integration & Production Deployment
4. **Review:** Revisit lessons from Project 5 or 6

**What would you like to do next?** ðŸŽ¯
