# Lesson 6.13: Pydantic Models for JWT Claims

## A. Concept Overview

### What & Why
**Pydantic models for JWT claims** provide type-safe validation of token payloads, ensuring JWTs contain expected fields with correct types. Essential for robust testingâ€”catch invalid tokens immediately with validation errors.

### Analogy
Pydantic JWT models are like customs forms at airportsâ€”every field must be filled correctly (type validation), certain fields are required (required claims), and forms are rejected if invalid (validation errors).

---

## B. Code Implementation

```python
from pydantic import BaseModel, Field, field_validator
from datetime import datetime
from typing import List, Optional
import jwt


class JWTClaims(BaseModel):
    """Type-safe model for JWT payload claims."""
    
    # Standard claims
    sub: str = Field(..., description="Subject (user ID)")
    iat: int = Field(..., description="Issued at (timestamp)")
    exp: int = Field(..., description="Expiration (timestamp)")
    
    # Optional standard claims
    iss: Optional[str] = Field(None, description="Issuer")
    aud: Optional[str] = Field(None, description="Audience")
    
    # Custom claims
    email: str
    roles: List[str] = Field(default_factory=list)
    permissions: List[str] = Field(default_factory=list)
    
    @field_validator("exp")
    @classmethod
    def validate_not_expired(cls, v: int) -> int:
        """Validate token hasn't expired."""
        if v < int(datetime.utcnow().timestamp()):
            raise ValueError("Token has expired")
        return v
    
    @property
    def is_admin(self) -> bool:
        """Check if user has admin role."""
        return "admin" in self.roles


# Validate JWT using Pydantic
def validate_jwt_with_pydantic(token: str, secret: str) -> JWTClaims:
    """Decode JWT and validate with Pydantic model."""
    
    # Decode JWT
    payload = jwt.decode(token, secret, algorithms=["HS256"])
    
    # Validate with Pydantic
    claims = JWTClaims(**payload)
    
    return claims


# Testing
def test_valid_jwt_claims():
    """Test JWT with valid claims."""
    import jwt
    from datetime import timedelta
    
    payload = {
        "sub": "user123",
        "iat": int(datetime.utcnow().timestamp()),
        "exp": int((datetime.utcnow() + timedelta(hours=1)).timestamp()),
        "email": "test@example.com",
        "roles": ["user", "admin"]
    }
    
    token = jwt.encode(payload, "secret", algorithm="HS256")
    claims = validate_jwt_with_pydantic(token, "secret")
    
    assert claims.sub == "user123"
    assert claims.email == "test@example.com"
    assert claims.is_admin == True


def test_missing_required_claim():
    """Test JWT missing required claim fails validation."""
    from pydantic import ValidationError
    
    payload = {
        "sub": "user123",
        # Missing: iat, exp, email
    }
    
    with pytest.raises(ValidationError):
        claims = JWTClaims(**payload)
```

---

## C. Connect & Apply

```python
# Create and validate JWT
payload = {
    "sub": "user123",
    "iat": int(datetime.utcnow().timestamp()),
    "exp": int((datetime.utcnow() + timedelta(hours=1)).timestamp()),
    "email": "test@example.com",
    "roles": ["admin"]
}

token = jwt.encode(payload, "secret", algorithm="HS256")
claims = validate_jwt_with_pydantic(token, "secret")

print(f"User: {claims.email}")
print(f"Is admin: {claims.is_admin}")
```

---

## D. Common Stumbling Blocks

**Mistake:** Not validating claim types
**Fix:** Use Pydantic models for automatic type validation

---

## ðŸŽ¯ Key Takeaways

âœ… Pydantic models validate JWT claims  
âœ… Type safety for token payloads  
âœ… Custom validators for business logic  
âœ… Properties for derived fields  

---

## What's Next?

Next: **Session Based Authentication**!

**Ready to continue?** ðŸš€
