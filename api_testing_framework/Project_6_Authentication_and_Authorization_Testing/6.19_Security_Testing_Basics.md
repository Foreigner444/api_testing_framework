# Lesson 6.19: Security Testing Basics

## A. Concept Overview

### What & Why
**Security testing for authentication** validates that auth mechanisms resist common attacks (brute force, token tampering, credential stuffing). Essential for production APIsâ€”one security flaw can compromise entire systems.

### Analogy
Security testing is like testing a lockâ€”not just whether it opens with the right key (functional testing), but also whether it resists picking, drilling, and brute force (security testing).

---

## B. Code Implementation

```python
import httpx
import pytest


def test_brute_force_protection():
    """Test API has brute force protection."""
    client = httpx.Client(base_url="https://api.example.com")
    
    # Attempt multiple failed logins
    for i in range(10):
        response = client.post(
            "/login",
            json={"username": "test", "password": f"wrong_pass_{i}"}
        )
    
    # After multiple failures, should be rate limited or locked
    assert response.status_code in [429, 403]
    assert "rate limit" in response.text.lower() or "locked" in response.text.lower()


def test_token_tampering_detection():
    """Test API rejects tampered tokens."""
    import jwt
    
    # Create valid token
    token = jwt.encode({"sub": "user123", "role": "user"}, "secret", algorithm="HS256")
    
    # Tamper with token (change payload without re-signing)
    parts = token.split('.')
    # Modify payload
    tampered_token = f"{parts[0]}.modified_payload.{parts[2]}"
    
    client = httpx.Client(
        base_url="https://api.example.com",
        headers={"Authorization": f"Bearer {tampered_token}"}
    )
    
    response = client.get("/protected")
    assert response.status_code == 401  # Invalid signature


def test_sql_injection_in_login():
    """Test login is protected against SQL injection."""
    client = httpx.Client(base_url="https://api.example.com")
    
    # SQL injection attempt
    response = client.post(
        "/login",
        json={
            "username": "admin' OR '1'='1",
            "password": "anything"
        }
    )
    
    # Should fail authentication (not bypass via SQL injection)
    assert response.status_code == 401


def test_password_not_returned_in_response():
    """Test API never returns passwords."""
    client = httpx.Client(
        base_url="https://api.example.com",
        headers={"Authorization": "Bearer valid_token"}
    )
    
    response = client.get("/profile")
    data = response.json()
    
    # Password should never be in response
    assert "password" not in data
    assert "password_hash" not in data


def test_insecure_http_rejected():
    """Test API requires HTTPS for authentication."""
    # HTTP (insecure)
    try:
        client = httpx.Client(base_url="http://api.example.com")
        response = client.post("/login", json={"user": "test", "pass": "secret"})
        
        # Production APIs should reject or redirect to HTTPS
        assert response.status_code in [301, 302, 403]
    except httpx.ConnectError:
        # Or refuse connection entirely on HTTP
        pass
```

---

## C. Connect & Apply

Test security: brute force protection, token tampering, injection attacks.

---

## D. Common Stumbling Blocks

**Mistake:** Only testing happy paths
**Fix:** Test attack scenarios and edge cases

---

## ðŸŽ¯ Key Takeaways

âœ… Test brute force protection  
âœ… Verify token tampering detection  
âœ… Check injection attack prevention  
âœ… Ensure passwords never returned  
âœ… Require HTTPS for auth endpoints  

---

## What's Next?

Next: **Rate Limiting Tests with httpx**!

**Ready to continue?** ðŸš€
