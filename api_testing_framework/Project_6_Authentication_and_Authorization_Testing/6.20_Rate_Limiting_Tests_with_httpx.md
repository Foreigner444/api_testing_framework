# Lesson 6.20: Rate Limiting Tests with httpx

## A. Concept Overview

### What & Why
**Rate limiting testing** validates that APIs enforce request limits to prevent abuse and ensure fair usage. Essential for production APIsâ€”verify rate limits work correctly and provide appropriate error responses.

### Analogy
Rate limiting is like a buffet with a "one plate at a time" ruleâ€”you can eat as much as you want, but must finish one plate before getting another. Prevents one person from hoarding all the food (API resources).

---

## B. Code Implementation

```python
import httpx
import pytest
import time
from datetime import datetime


def test_rate_limit_enforced():
    """Test API enforces rate limits."""
    client = httpx.Client(
        base_url="https://api.example.com",
        headers={"Authorization": "Bearer test_token"}
    )
    
    # Make requests rapidly
    responses = []
    for i in range(100):
        response = client.get("/data")
        responses.append(response)
        
        # Stop if rate limited
        if response.status_code == 429:
            break
    
    # Should hit rate limit
    rate_limited_responses = [r for r in responses if r.status_code == 429]
    assert len(rate_limited_responses) > 0, "No rate limiting detected"
    
    # Check rate limit headers
    last_response = responses[-1]
    assert "X-RateLimit-Limit" in last_response.headers
    assert "X-RateLimit-Remaining" in last_response.headers
    assert "Retry-After" in last_response.headers


def test_rate_limit_headers():
    """Test rate limit information in response headers."""
    client = httpx.Client(
        base_url="https://api.example.com",
        headers={"Authorization": "Bearer test_token"}
    )
    
    response = client.get("/data")
    
    # Standard rate limit headers
    limit = int(response.headers.get("X-RateLimit-Limit", 0))
    remaining = int(response.headers.get("X-RateLimit-Remaining", 0))
    
    assert limit > 0, "Rate limit not configured"
    assert remaining <= limit, "Remaining should be <= limit"
    
    print(f"Rate limit: {remaining}/{limit} requests remaining")


def test_rate_limit_reset():
    """Test rate limit resets after time window."""
    client = httpx.Client(base_url="https://api.example.com")
    
    # Hit rate limit
    for i in range(100):
        response = client.get("/data")
        if response.status_code == 429:
            retry_after = int(response.headers.get("Retry-After", 60))
            print(f"Rate limited. Retry after: {retry_after}s")
            
            # Wait for reset
            time.sleep(retry_after + 1)
            
            # Should work again
            response = client.get("/data")
            assert response.status_code == 200
            break


def test_different_rate_limits_per_endpoint():
    """Test different endpoints may have different limits."""
    client = httpx.Client(base_url="https://api.example.com")
    
    # Expensive endpoint (lower limit)
    response1 = client.get("/expensive-operation")
    expensive_limit = int(response1.headers.get("X-RateLimit-Limit", 0))
    
    # Cheap endpoint (higher limit)
    response2 = client.get("/cheap-operation")
    cheap_limit = int(response2.headers.get("X-RateLimit-Limit", 0))
    
    assert cheap_limit > expensive_limit
```

---

## C. Connect & Apply

Test rate limiting by making rapid requests and verifying 429 responses.

---

## D. Common Stumbling Blocks

**Mistake:** Not respecting Retry-After header in tests
**Fix:** Check Retry-After and implement backoff

---

## ðŸŽ¯ Key Takeaways

âœ… 429 Too Many Requests for rate limits  
âœ… X-RateLimit headers for limit info  
âœ… Retry-After for reset timing  
âœ… Different limits per endpoint  
âœ… Test limit enforcement and reset  

---

## What's Next?

Next: **Token Expiration and Refresh**!

**Ready to continue?** ðŸš€
