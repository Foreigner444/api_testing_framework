# Lesson 2.17: Best Practices for Async Testing

## ðŸŽ‰ Project 2 Complete!

## A. Async Testing Best Practices

### 1. Use Async for Independent Operations Only

âœ… **Good**:
```python
@pytest.mark.asyncio
async def test_good():
    async with httpx.AsyncClient() as client:
        # Independent operations
        responses = await asyncio.gather(
            client.get("/users/1"),
            client.get("/posts/1"),
            client.get("/comments/1")
        )
```

âŒ **Bad**:
```python
@pytest.mark.asyncio
async def test_bad():
    async with httpx.AsyncClient() as client:
        # Sequential dependencies - should be sync!
        user = await client.post("/users", json={...})
        await client.get(f"/users/{user['id']}")
```

---

### 2. Configure Appropriate Concurrency Limits

```python
@pytest.mark.asyncio
async def test_with_limits():
    limits = httpx.Limits(
        max_keepalive_connections=20,
        max_connections=100  # Don't overwhelm server
    )
    
    async with httpx.AsyncClient(limits=limits) as client:
        # Limit concurrent connections
        tasks = [client.get(f"https://api.example.com/users/{i}") for i in range(200)]
        responses = await asyncio.gather(*tasks)
```

---

### 3. Use Fixtures for AsyncClient

```python
# conftest.py
@pytest.fixture
async def api_client():
    async with httpx.AsyncClient(base_url="https://api.example.com") as client:
        yield client

# tests
@pytest.mark.asyncio
async def test_with_fixture(api_client):
    response = await api_client.get("/users/1")
    assert response.status_code == 200
```

---

### 4. Handle Errors Gracefully

```python
@pytest.mark.asyncio
async def test_with_error_handling(api_client):
    results = await asyncio.gather(
        api_client.get("/users/1"),
        api_client.get("/invalid"),
        return_exceptions=True  # Don't fail all if one fails
    )
    
    successes = [r for r in results if isinstance(r, httpx.Response)]
    assert len(successes) >= 1
```

---

### 5. Set Reasonable Timeouts

```python
@pytest.mark.asyncio
async def test_with_timeout():
    async with httpx.AsyncClient(timeout=10.0) as client:
        response = await client.get("https://api.example.com/slow-endpoint")
        assert response.status_code == 200
```

---

### 6. Test Both Success and Failure Paths

```python
@pytest.mark.asyncio
async def test_comprehensive(api_client):
    # Test success
    success_response = await api_client.get("/users/1")
    assert success_response.status_code == 200
    
    # Test failure
    error_response = await api_client.get("/users/99999")
    assert error_response.status_code == 404
```

---

### 7. Keep Tests Independent

```python
# âœ… Good - independent
@pytest.mark.asyncio
async def test_get_user_1(api_client):
    response = await api_client.get("/users/1")
    assert response.status_code == 200

@pytest.mark.asyncio
async def test_get_user_2(api_client):
    response = await api_client.get("/users/2")
    assert response.status_code == 200

# These can run in any order, even concurrently
```

---

### 8. Document Async Dependencies

```python
@pytest.mark.asyncio
async def test_user_workflow(api_client):
    """
    Test user workflow.
    
    Note: Steps must run sequentially, not suitable for gather().
    Uses async for consistency but no concurrency benefit here.
    """
    # Create (must be first)
    user = await api_client.post("/users", json={...})
    
    # Read (depends on creation)
    fetched = await api_client.get(f"/users/{user['id']}")
    
    # These two CAN be concurrent
    posts, comments = await asyncio.gather(
        api_client.get(f"/users/{user['id']}/posts"),
        api_client.get(f"/users/{user['id']}/comments")
    )
```

---

## B. Configuration Best Practices

### pytest.ini for Async

```ini
[pytest]
asyncio_mode = auto
testpaths = tests
addopts = -v --tb=short -ra
markers =
    asyncio: Async tests
    slow: Slow tests
```

---

### requirements.txt

```
pytest>=8.0.0
pytest-asyncio>=0.21.0
httpx[http2]>=0.27.0
```

---

## C. Project Structure

```
tests/
â”œâ”€â”€ conftest.py           # Async fixtures
â”œâ”€â”€ test_users_async.py   # Async user tests
â”œâ”€â”€ test_posts_async.py   # Async post tests
â””â”€â”€ test_mixed.py         # Mix of sync and async
```

---

## D. Common Patterns Summary

### Pattern 1: Batch GET Requests

```python
@pytest.mark.asyncio
async def pattern_batch_get(api_client):
    tasks = [api_client.get(f"/resource/{i}") for i in range(1, 51)]
    responses = await asyncio.gather(*tasks)
    assert all(r.status_code == 200 for r in responses)
```

---

### Pattern 2: Multiple Endpoints

```python
@pytest.mark.asyncio
async def pattern_multiple_endpoints(api_client):
    users, posts, comments = await asyncio.gather(
        api_client.get("/users"),
        api_client.get("/posts"),
        api_client.get("/comments")
    )
```

---

### Pattern 3: Hybrid Sequential + Concurrent

```python
@pytest.mark.asyncio
async def pattern_hybrid(api_client):
    # Step 1: Create (must be first)
    user = await api_client.post("/users", json={...})
    
    # Step 2: Fetch related data concurrently
    profile, posts, comments = await asyncio.gather(
        api_client.get(f"/users/{user['id']}"),
        api_client.get(f"/users/{user['id']}/posts"),
        api_client.get(f"/users/{user['id']}/comments")
    )
```

---

## E. Congratulations! ðŸŽ‰

**You've completed Project 2: Async API Testing!**

You now master:

âœ… Async/await fundamentals  
âœ… httpx.AsyncClient  
âœ… pytest-asyncio  
âœ… Concurrent test execution  
âœ… asyncio.gather()  
âœ… Async fixtures  
âœ… Error handling  
âœ… Performance optimization  
âœ… Async best practices  

---

## F. Skills Unlocked

You can now:
- Write async API tests
- Run tests 10-50x faster
- Use AsyncClient effectively
- Create async fixtures
- Handle async errors
- Mix sync and async appropriately
- Build high-performance test suites

---

## G. What's Next?

### Project 3: Pydantic Models & Schema Validation
- Type-safe API testing
- Automatic validation
- Schema generation
- Integration with httpx (sync & async!)

### Project 4: Test Data Generation with Faker
- Realistic test data
- Factory patterns
- Dynamic generation

### Projects 5-9: Production Framework
- Configuration management
- Authentication testing
- Framework architecture
- Allure reporting
- CI/CD deployment

---

## H. Final Challenge

Before moving to Project 3, try this:

**Build a high-performance async test suite**:
1. Choose a public API
2. Write 50+ async tests
3. Run them concurrently
4. Measure sync vs async performance
5. Document the speedup!

---

## I. Key Takeaways - Project 2 Complete

ðŸ”‘ **Async = Speed**: 10-50x faster for independent tests  
ðŸ”‘ **AsyncClient**: Core tool for async testing  
ðŸ”‘ **pytest-asyncio**: Makes async tests work  
ðŸ”‘ **asyncio.gather()**: Run tasks concurrently  
ðŸ”‘ **Best for**: Independent operations, large suites  
ðŸ”‘ **Not for**: Sequential workflows, dependencies  
ðŸ”‘ **Mix both**: Use sync and async appropriately  
ðŸ”‘ **Production ready**: You can build real frameworks now  

---

## J. Celebrate Your Achievement! ðŸŽŠ

You've mastered async API testing! This is a **significant accomplishment** that many testers never achieve. You can now:
- Build blazing-fast test suites
- Optimize CI/CD pipelines
- Handle concurrent operations
- Write production-grade async code

**Take a moment to appreciate how far you've come!**

From knowing nothing about API testing (Project 1 start) to writing high-performance async tests (Project 2 complete)â€”that's incredible growth! ðŸš€

---

## K. Ready for Project 3?

**Project 3: Pydantic Models & Schema Validation**

Learn to validate API responses automatically with type-safe models!

**Let's build something amazing together!** ðŸ’ª
