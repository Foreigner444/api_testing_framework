# Lesson 2.7: Async Context Managers

## A. Concept Overview

### What & Why
**Async context managers** (using `async with`) properly manage async resources like HTTP clients, database connections, and file handles. They're important because they ensure resources are correctly initialized and cleaned up, even if errors occur.

### Analogy
Context managers are like hotel check-in/check-out. When you arrive (enter context), you get a room key (resource). When you leave (exit context), the room is automatically cleaned and key returned‚Äîeven if you leave early due to emergency (exception). Async context managers do this for async resources!

---

## B. Sync vs Async Context Managers

### Sync Context Manager

```python
# Synchronous context manager
with httpx.Client() as client:
    response = client.get(url)
    # Client automatically closed after this block
```

**Under the hood**:
1. `__enter__()` method called ‚Üí Returns client
2. Your code runs
3. `__exit__()` method called ‚Üí Closes client

---

### Async Context Manager

```python
# Asynchronous context manager
async with httpx.AsyncClient() as client:
    response = await client.get(url)
    # Client automatically closed after this block
```

**Under the hood**:
1. `__aenter__()` method called ‚Üí Returns client
2. Your code runs
3. `__aexit__()` method called ‚Üí Closes client

**Key difference**: `async with` instead of `with`

---

## C. Why Use Async Context Managers?

### Problem Without Context Manager

```python
# ‚ùå Manual resource management (error-prone)
@pytest.mark.asyncio
async def test_manual_cleanup():
    client = httpx.AsyncClient()
    
    try:
        response = await client.get("https://jsonplaceholder.typicode.com/users/1")
        assert response.status_code == 200
    finally:
        await client.aclose()  # Must manually close!
```

**Problems**:
- Easy to forget cleanup
- Verbose and repetitive
- Error-prone
- Connection leaks if forgotten

---

### Solution With Context Manager

```python
# ‚úÖ Automatic resource management (safe)
@pytest.mark.asyncio
async def test_with_context_manager():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://jsonplaceholder.typicode.com/users/1")
        assert response.status_code == 200
    # Client automatically closed, even if test fails!
```

**Benefits**:
- ‚úÖ Automatic cleanup
- ‚úÖ Clean, readable code
- ‚úÖ Exception-safe
- ‚úÖ No connection leaks

---

## D. httpx AsyncClient Lifecycle

### What Happens Behind the Scenes

```python
async with httpx.AsyncClient() as client:
    # 1. __aenter__ called
    #    - Connection pool created
    #    - Resources initialized
    #    - Client ready to use
    
    response = await client.get(url)
    
    # 2. __aexit__ called (even if exception occurs)
    #    - Active connections closed
    #    - Connection pool cleared
    #    - Resources freed
```

---

## E. Nested Async Context Managers

You can nest async context managers:

File: `tests/test_nested_async_context.py`
```python
\"\"\"Test nested async context managers.\"\"\"
import pytest
import httpx
import asyncio


@pytest.mark.asyncio
async def test_multiple_clients():
    \"\"\"Use multiple async clients (not recommended pattern, just demonstration).\"\"\"
    # Two separate clients
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client1:
        async with httpx.AsyncClient(base_url="https://httpbin.org") as client2:
            # Use both clients
            user_response = await client1.get("/users/1")
            echo_response = await client2.get("/get")
            
            assert user_response.status_code == 200
            assert echo_response.status_code == 200


@pytest.mark.asyncio
async def test_concurrent_with_single_client():
    \"\"\"Better: Use one client for concurrent requests.\"\"\"
    async with httpx.AsyncClient() as client:
        # One client, multiple concurrent requests
        responses = await asyncio.gather(
            client.get("https://jsonplaceholder.typicode.com/users/1"),
            client.get("https://httpbin.org/get")
        )
        
        assert all(r.status_code == 200 for r in responses)
```

**Best Practice**: Use **one** AsyncClient for multiple concurrent requests, not multiple clients!

---

## F. Error Handling in Async Context Managers

### Context Manager Handles Exceptions

```python
@pytest.mark.asyncio
async def test_exception_in_context():
    \"\"\"Test that context manager handles exceptions.\"\"\"
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get("https://jsonplaceholder.typicode.com/users/1")
            
            # Simulate error
            raise ValueError("Something went wrong!")
            
            # This won't execute
            await client.get("/users/2")
    
    except ValueError:
        # Context manager still closed client properly!
        pass
    
    # Client is closed despite exception ‚úÖ
```

---

### Manual Exception Handling

```python
@pytest.mark.asyncio
async def test_handle_request_error():
    \"\"\"Handle specific httpx errors.\"\"\"
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(
                "https://jsonplaceholder.typicode.com/delay/10",
                timeout=1.0
            )
        except httpx.TimeoutException:
            # Expected timeout
            assert True
        except httpx.HTTPError as e:
            # Other HTTP errors
            pytest.fail(f"Unexpected HTTP error: {e}")
```

---

## G. Custom Async Context Managers

You can create your own! (Advanced)

```python
class APIClient:
    \"\"\"Custom async context manager for API testing.\"\"\"
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.client = None
    
    async def __aenter__(self):
        \"\"\"Setup - called when entering context.\"\"\"
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=10.0
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        \"\"\"Teardown - called when exiting context.\"\"\"
        if self.client:
            await self.client.aclose()
    
    async def get_user(self, user_id):
        \"\"\"Helper method.\"\"\"
        return await self.client.get(f"/users/{user_id}")


@pytest.mark.asyncio
async def test_custom_context_manager():
    \"\"\"Use custom async context manager.\"\"\"
    async with APIClient("https://jsonplaceholder.typicode.com") as api:
        response = await api.get_user(1)
        assert response.status_code == 200
```

**Use cases for custom context managers**:
- Wrapping common setup/teardown
- Adding logging
- Managing multiple resources
- Framework building (Project 7!)

---

## H. Common Patterns

### Pattern 1: Single Client for All Tests

```python
@pytest.mark.asyncio
async def test_multiple_operations():
    \"\"\"Use one client for all operations.\"\"\"
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        # Sequential operations
        user = await client.get("/users/1")
        posts = await client.get("/posts?userId=1")
        
        # Concurrent operations
        comments, todos = await asyncio.gather(
            client.get("/comments?postId=1"),
            client.get("/todos?userId=1")
        )
        
        assert user.status_code == 200
        assert posts.status_code == 200
        assert comments.status_code == 200
        assert todos.status_code == 200
```

---

### Pattern 2: Client as Fixture (Coming in 2.8!)

```python
@pytest.fixture
async def async_client():
    \"\"\"Async client fixture.\"\"\"
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        yield client


@pytest.mark.asyncio
async def test_with_fixture(async_client):
    \"\"\"Use async client fixture.\"\"\"
    response = await async_client.get("/users/1")
    assert response.status_code == 200
```

---

## I. AsyncClient Configuration Deep Dive

### Base URL Configuration

```python
@pytest.mark.asyncio
async def test_base_url():
    \"\"\"Test base URL configuration.\"\"\"
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        # Use relative URLs
        response1 = await client.get("/users")
        response2 = await client.get("/posts")
        
        # Verify full URLs
        assert "jsonplaceholder.typicode.com/users" in str(response1.url)
        assert "jsonplaceholder.typicode.com/posts" in str(response2.url)
```

---

### Timeout Configuration

```python
@pytest.mark.asyncio
async def test_timeout_configuration():
    \"\"\"Test timeout configuration.\"\"\"
    timeout = httpx.Timeout(
        connect=5.0,
        read=10.0,
        write=5.0,
        pool=5.0
    )
    
    async with httpx.AsyncClient(timeout=timeout) as client:
        response = await client.get("https://httpbin.org/delay/2")
        assert response.status_code == 200
```

---

### Headers Configuration

```python
@pytest.mark.asyncio
async def test_default_headers():
    \"\"\"Test default headers on AsyncClient.\"\"\"
    headers = {
        "User-Agent": "AsyncTestSuite/1.0",
        "Accept": "application/json",
        "X-API-Key": "test-key"
    }
    
    async with httpx.AsyncClient(headers=headers) as client:
        response = await client.get("https://httpbin.org/headers")
        
        data = response.json()
        assert "AsyncTestSuite" in data["headers"]["User-Agent"]
        assert data["headers"]["X-Api-Key"] == "test-key"
```

---

## J. Connection Pooling

AsyncClient automatically manages connection pool:

```python
@pytest.mark.asyncio
async def test_connection_reuse():
    \"\"\"Test that AsyncClient reuses connections.\"\"\"
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        # All requests reuse connections from pool
        responses = await asyncio.gather(*[
            client.get(f"/users/{i}")
            for i in range(1, 11)
        ])
        
        # All should succeed
        assert all(r.status_code == 200 for r in responses)
        
        # Connections were pooled and reused (faster!)
```

---

## K. Common Mistakes

### Mistake 1: Forgetting async with

```python
# ‚ùå Wrong
client = httpx.AsyncClient()
response = await client.get(url)
# Forgot to close!

# ‚úÖ Correct
async with httpx.AsyncClient() as client:
    response = await client.get(url)
```

---

### Mistake 2: Using sync with for AsyncClient

```python
# ‚ùå Wrong
with httpx.AsyncClient() as client:  # Should be async with!
    response = await client.get(url)

# ‚úÖ Correct
async with httpx.AsyncClient() as client:
    response = await client.get(url)
```

---

## L. Key Takeaways

üîë **async with**: Required for AsyncClient  
üîë **Automatic cleanup**: Resources freed properly  
üîë **Exception safe**: Cleanup even on errors  
üîë **Configuration**: Same options as sync Client  
üîë **Connection pooling**: Automatic and efficient  
üîë **One client**: Reuse for multiple requests  

---

## M. What's Next?

Lesson 2.8: Async Fixtures in pytest - Reuse async setup across tests!

Ready? üöÄ
