# Lesson 2.3: When to Use Async Tests

## A. Concept Overview

### What & Why
**Choosing between sync and async** is a critical decision that affects test performance, complexity, and maintainability. It's important because using async incorrectly adds unnecessary complexity, while missing async opportunities means slow tests.

### Analogy
Choosing sync vs async is like choosing transportation:
- **Sync (Car)**: Perfect for short trips, simple routes, solo journeys
- **Async (Train/Bus)**: Better for long distances, multiple destinations, group travel

Wrong choice = wasted time or unnecessary hassle!

---

## B. Decision Tree

```
Do you need to test multiple independent operations?
â”‚
â”œâ”€ NO â†’ Use SYNC
â”‚       Examples:
â”‚       - Single endpoint test
â”‚       - Sequential workflow (create â†’ read â†’ update â†’ delete)
â”‚       - Learning basics
â”‚       - Simple scripts
â”‚
â””â”€ YES â†’ Ask: Are operations truly independent?
         â”‚
         â”œâ”€ NO (operations depend on each other) â†’ Use SYNC
         â”‚       Examples:
         â”‚       - Create user, then get that user
         â”‚       - Update post, then verify update
         â”‚       - Multi-step workflows
         â”‚
         â””â”€ YES â†’ Ask: Is performance important?
                  â”‚
                  â”œâ”€ NO (small test suite, <10 tests) â†’ Use SYNC
                  â”‚       Async overhead not worth it
                  â”‚
                  â””â”€ YES â†’ Use ASYNC! âœ…
                           - Large test suite (50+ tests)
                           - CI/CD pipelines
                           - Smoke tests across services
                           - Performance testing
```

---

## C. Scenarios: Sync vs Async

### Scenario 1: Testing Single Endpoint

**Test**: Verify GET /users/1 returns correct data

**Decision**: âœ… **Use SYNC**

**Why**: 
- Single operation
- No benefit from async
- Simpler code
- Easier to debug

**Code**:
```python
def test_get_user_sync():
    """Simple single endpoint test - sync is perfect."""
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
    assert response.json()["id"] == 1
```

---

### Scenario 2: Testing 50 User Endpoints

**Test**: Verify GET /users/1 through /users/50 all work

**Decision**: âœ… **Use ASYNC**

**Why**:
- 50 independent operations
- No dependencies between requests
- Massive time savings (50s â†’ 2-3s)
- Worth the async complexity

**Code**:
```python
@pytest.mark.asyncio
async def test_fifty_users_async():
    """50 independent requests - async is perfect."""
    async with httpx.AsyncClient(base_url="https://api.example.com") as client:
        tasks = [client.get(f"/users/{i}") for i in range(1, 51)]
        responses = await asyncio.gather(*tasks)
        
        for response in responses:
            assert response.status_code == 200
```

**Performance**:
- Sync: ~50 seconds
- Async: ~2-3 seconds
- **Speedup: 15-25x**

---

### Scenario 3: Sequential User Lifecycle

**Test**: Create user â†’ Get user â†’ Update user â†’ Delete user

**Decision**: âœ… **Use SYNC**

**Why**:
- Operations must happen in order
- Each step depends on previous
- No concurrency possible
- Async adds complexity without benefit

**Code**:
```python
def test_user_lifecycle_sync():
    """Sequential workflow - sync is correct choice."""
    # Step 1: Create
    create_response = httpx.post("https://api.example.com/users", json={...})
    user_id = create_response.json()["id"]
    
    # Step 2: Get (needs user_id from step 1)
    get_response = httpx.get(f"https://api.example.com/users/{user_id}")
    assert get_response.status_code == 200
    
    # Step 3: Update (needs user_id from step 1)
    update_response = httpx.patch(
        f"https://api.example.com/users/{user_id}",
        json={"name": "Updated"}
    )
    assert update_response.status_code == 200
    
    # Step 4: Delete (needs user_id from step 1)
    delete_response = httpx.delete(f"https://api.example.com/users/{user_id}")
    assert delete_response.status_code in [200, 204]
```

---

### Scenario 4: Smoke Tests Across Services

**Test**: Check health of users, posts, comments, todos services

**Decision**: âœ… **Use ASYNC**

**Why**:
- Independent health checks
- All can run simultaneously
- Fast feedback (all services checked in 1s instead of 4s)
- Perfect use case for async

**Code**:
```python
@pytest.mark.asyncio
async def test_all_services_health_async():
    """Smoke test multiple services - async is perfect."""
    base_url = "https://jsonplaceholder.typicode.com"
    
    async with httpx.AsyncClient(base_url=base_url) as client:
        # Check all services concurrently
        responses = await asyncio.gather(
            client.get("/users"),      # Users service
            client.get("/posts"),      # Posts service
            client.get("/comments"),   # Comments service
            client.get("/todos"),      # Todos service
            client.get("/albums")      # Albums service
        )
        
        # All should be healthy
        for response in responses:
            assert response.status_code == 200
```

**Performance**:
- Sync: ~5 seconds
- Async: ~1 second
- **Speedup: 5x**

---

### Scenario 5: Testing Search with Different Parameters

**Test**: Search users with various filters

**Decision**: âœ… **Use ASYNC**

**Why**:
- Independent search queries
- Can run concurrently
- Faster test execution

**Code**:
```python
@pytest.mark.asyncio
async def test_user_search_variations_async():
    """Multiple search queries - async is efficient."""
    async with httpx.AsyncClient(base_url="https://api.example.com") as client:
        # Test different search parameters concurrently
        responses = await asyncio.gather(
            client.get("/users?role=admin"),
            client.get("/users?status=active"),
            client.get("/users?country=US"),
            client.get("/users?created_after=2024-01-01"),
            return_exceptions=True  # Don't fail all if one fails
        )
        
        for response in responses:
            if isinstance(response, httpx.Response):
                assert response.status_code == 200
```

---

### Scenario 6: Integration Test with Dependencies

**Test**: Create order â†’ Process payment â†’ Send confirmation email

**Decision**: âœ… **Use SYNC**

**Why**:
- Steps must be sequential
- Payment needs order ID
- Email needs payment confirmation
- Dependencies prevent concurrency

**Code**:
```python
def test_order_workflow_sync():
    """Integration test with dependencies - sync required."""
    # Step 1: Create order
    order = httpx.post("https://api.example.com/orders", json={...}).json()
    
    # Step 2: Process payment (needs order ID)
    payment = httpx.post(
        f"https://api.example.com/orders/{order['id']}/payment",
        json={...}
    ).json()
    
    # Step 3: Send confirmation (needs payment ID)
    confirmation = httpx.post(
        f"https://api.example.com/emails/confirmation",
        json={"payment_id": payment["id"]}
    )
    
    assert confirmation.status_code == 200
```

---

## D. Performance Analysis

### Calculate Expected Speedup

**Formula**:
```
Speedup = (Number of independent operations) / (Concurrency bottlenecks + 1)

For truly independent operations:
Speedup â‰ˆ Number of operations (up to limits)
```

**Examples**:

| Tests | Avg Time Each | Sync Total | Async Total | Speedup |
|-------|---------------|------------|-------------|---------|
| 5 independent | 1s | 5s | ~1s | 5x |
| 10 independent | 1s | 10s | ~1-2s | 5-10x |
| 50 independent | 500ms | 25s | ~2s | 12x |
| 100 independent | 500ms | 50s | ~3-5s | 10-15x |
| 10 sequential | 1s | 10s | 10s | 1x (no gain) |

---

## E. Trade-offs to Consider

### Benefits of Async

âœ… **Much faster** for independent operations (5-50x)  
âœ… **Better resource utilization**  
âœ… **Scales well** with more tests  
âœ… **Faster CI/CD** pipelines  
âœ… **Modern approach** (industry standard)  
âœ… **Handles high concurrency** naturally  

### Costs of Async

âŒ **More complex** code (async/await, gather)  
âŒ **Harder debugging** (stack traces more complex)  
âŒ **Learning curve** for beginners  
âŒ **Overhead** for small test suites  
âŒ **Not suitable** for sequential operations  

### The Balance

**Rule of Thumb**:
- **< 10 tests**: Sync probably fine
- **10-50 tests**: Async starts paying off
- **50+ tests**: Async definitely worth it
- **Sequential workflow**: Always sync
- **Independent operations**: Consider async

---

## F. Real-World Decision Examples

### Example 1: Startup with 20 API Tests

**Context**:
- Small API
- 20 total tests
- Tests run in 10 seconds (sync)
- Team of 3 developers

**Decision**: âš ï¸ **Stick with SYNC** (for now)

**Reasoning**:
- 10 seconds is acceptable
- Team familiar with sync
- Async adds complexity
- Can migrate later if needed

**When to reconsider**: When test suite grows to 50+ tests

---

### Example 2: E-commerce with 200 API Tests

**Context**:
- Large API
- 200 total tests
- Tests run in 100 seconds (sync)
- CI/CD runs on every commit
- 50+ commits per day

**Decision**: âœ… **USE ASYNC**

**Reasoning**:
- 100 seconds too slow for frequent runs
- Async could reduce to 5-10 seconds
- Saves 90 seconds Ã— 50 runs = 75 minutes daily!
- Worth the async investment
- Better developer experience

**Expected outcome**: 10-20x speedup

---

### Example 3: Microservices Health Checks

**Context**:
- 20 microservices
- Need to check all are healthy
- Run every 5 minutes

**Decision**: âœ… **USE ASYNC**

**Reasoning**:
- Perfect async use case
- All checks independent
- Need fast feedback
- Sequential would take too long

**Code Pattern**:
```python
@pytest.mark.asyncio
async def test_all_services_healthy():
    async with httpx.AsyncClient() as client:
        services = [
            "users", "posts", "orders", "payments",
            "inventory", "shipping", "notifications", "analytics",
            # ... 20 services total
        ]
        
        tasks = [
            client.get(f"https://{service}.api.com/health")
            for service in services
        ]
        
        responses = await asyncio.gather(*tasks)
        
        for service, response in zip(services, responses):
            assert response.status_code == 200, f"{service} is down!"
```

---

## G. Migration Strategy

### When to Migrate from Sync to Async

**Triggers**:
1. Test suite takes > 30 seconds
2. Running tests becomes painful
3. CI/CD is too slow
4. Team ready for async patterns

### How to Migrate

**Step 1: Start small**
```python
# Keep existing sync tests
def test_user_sync():
    pass

# Add new async tests alongside
@pytest.mark.asyncio
async def test_users_batch_async():
    pass
```

**Step 2: Identify independent tests**
```python
# These can be async
test_get_user_1()  â† Independent
test_get_user_2()  â† Independent
test_get_user_3()  â† Independent

# These must stay sync
test_create_then_read_user()  â† Depends on creation
```

**Step 3: Convert in batches**
- Convert smoke tests first (biggest wins)
- Convert GET tests next (safe, independent)
- Keep sequential workflows sync
- Measure performance improvements

**Step 4: Optimize**
- Use connection pooling
- Limit concurrency if needed
- Add retries for flaky tests

---

## H. Complexity vs Performance Matrix

| Test Count | Independent? | Sync Time | Async Gain | Verdict |
|------------|--------------|-----------|------------|---------|
| 1-5 | Yes | <5s | Minimal | **SYNC** âœ… |
| 1-5 | No (sequential) | <5s | None | **SYNC** âœ… |
| 10-30 | Yes | 10-30s | Moderate | **ASYNC** if performance matters |
| 10-30 | No (sequential) | 10-30s | None | **SYNC** âœ… |
| 50+ | Yes | 50s+ | Large | **ASYNC** âœ… |
| 50+ | No (sequential) | 50s+ | None | **SYNC** âœ… |

**Key Insight**: Async only helps with **independent, I/O-bound operations**!

---

## I. Code Patterns for Common Scenarios

### Pattern 1: Test All CRUD Operations (Sync)

```python
def test_user_crud():
    """CRUD must be sequential - use sync."""
    # Create
    user = httpx.post("https://api.example.com/users", json={...}).json()
    
    # Read
    fetched = httpx.get(f"https://api.example.com/users/{user['id']}").json()
    assert fetched["id"] == user["id"]
    
    # Update
    updated = httpx.patch(
        f"https://api.example.com/users/{user['id']}",
        json={"name": "New Name"}
    ).json()
    assert updated["name"] == "New Name"
    
    # Delete
    delete_response = httpx.delete(f"https://api.example.com/users/{user['id']}")
    assert delete_response.status_code in [200, 204]
```

---

### Pattern 2: Test Multiple Independent GETs (Async)

```python
@pytest.mark.asyncio
async def test_multiple_users_async():
    """Multiple GETs - async is perfect."""
    async with httpx.AsyncClient(base_url="https://api.example.com") as client:
        user_ids = range(1, 51)  # 50 users
        tasks = [client.get(f"/users/{uid}") for uid in user_ids]
        responses = await asyncio.gather(*tasks)
        
        assert all(r.status_code == 200 for r in responses)
```

**Time saved**: 48 seconds (50s â†’ 2s)

---

### Pattern 3: Hybrid Approach (Mixed)

```python
@pytest.mark.asyncio
async def test_user_with_related_data_hybrid():
    """Mix sync and async appropriately."""
    # Step 1: Create user (must be first) - SYNC part
    async with httpx.AsyncClient(base_url="https://api.example.com") as client:
        create_response = await client.post("/users", json={...})
        user_id = create_response.json()["id"]
        
        # Step 2: Fetch related data CONCURRENTLY - ASYNC part
        user, posts, comments = await asyncio.gather(
            client.get(f"/users/{user_id}"),
            client.get(f"/users/{user_id}/posts"),
            client.get(f"/users/{user_id}/comments")
        )
        
        # All three GET requests happen simultaneously!
        assert user.status_code == 200
        assert posts.status_code == 200
        assert comments.status_code == 200
```

**Time saved**: 2 seconds (3s â†’ 1s for the GET operations)

---

## J. Performance Benchmarking

### How to Measure

```python
import time

def measure_sync():
    """Measure sync performance."""
    start = time.time()
    
    # Your sync tests here
    for i in range(1, 21):
        response = httpx.get(f"https://api.example.com/users/{i}")
    
    return time.time() - start


async def measure_async():
    """Measure async performance."""
    start = time.time()
    
    async with httpx.AsyncClient() as client:
        tasks = [client.get(f"https://api.example.com/users/{i}") for i in range(1, 21)]
        await asyncio.gather(*tasks)
    
    return time.time() - start


# Compare
sync_time = measure_sync()
async_time = asyncio.run(measure_async())

print(f"Sync: {sync_time:.2f}s")
print(f"Async: {async_time:.2f}s")
print(f"Speedup: {sync_time / async_time:.1f}x")
```

---

## K. When Async Doesn't Help

### Case 1: CPU-Bound Operations

```python
# âŒ Async doesn't help here
async def test_heavy_computation():
    async with httpx.AsyncClient() as client:
        response = await client.get("/data")
        data = response.json()
        
        # This is CPU-bound, not I/O-bound
        # Async provides no benefit
        for item in data:
            complex_calculation(item)  # Blocks CPU
```

**Solution**: Use threading/multiprocessing for CPU-bound work, not async.

---

### Case 2: Sequential Dependencies

```python
# âŒ Async adds complexity without benefit
@pytest.mark.asyncio
async def test_unnecessary_async():
    async with httpx.AsyncClient() as client:
        # These MUST be sequential
        user = await client.post("/users", json={...})
        order = await client.post("/orders", json={"user_id": user["id"]})
        payment = await client.post("/payment", json={"order_id": order["id"]})
    
    # âœ… Better as sync - same result, simpler code
```

---

### Case 3: Single Request

```python
# âŒ Overkill
@pytest.mark.asyncio
async def test_single_request():
    async with httpx.AsyncClient() as client:
        response = await client.get("/users/1")
        assert response.status_code == 200

# âœ… Better - simpler
def test_single_request():
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
```

---

## L. Decision Flowchart Summary

```
START: Need to write API tests
â”‚
â”œâ”€â†’ Is performance critical? (CI/CD, large suite, slow APIs)
â”‚   â”œâ”€â†’ NO â†’ How many tests?
â”‚   â”‚        â”œâ”€â†’ <20 tests â†’ SYNC âœ…
â”‚   â”‚        â””â”€â†’ 20+ tests â†’ Consider ASYNC
â”‚   â”‚
â”‚   â””â”€â†’ YES â†’ Are operations independent?
â”‚            â”œâ”€â†’ NO (sequential) â†’ SYNC âœ…
â”‚            â””â”€â†’ YES (parallel) â†’ ASYNC âœ…
â”‚
â””â”€â†’ Learning/Prototyping?
     â†’ Start with SYNC, migrate to ASYNC later âœ…
```

---

## M. Team Considerations

### Team Factors

**Use Sync if**:
- Team new to Python
- Team unfamiliar with async
- Small test suite
- Simple APIs

**Use Async if**:
- Team comfortable with async Python
- Large test suite
- Performance critical
- Modern microservices architecture

---

## N. Key Takeaways

ğŸ”‘ **Independent operations**: Async shines  
ğŸ”‘ **Sequential operations**: Stick with sync  
ğŸ”‘ **Large test suites** (50+): Async worth it  
ğŸ”‘ **Small test suites** (<10): Sync is fine  
ğŸ”‘ **CI/CD pipelines**: Async speeds feedback  
ğŸ”‘ **Learning**: Start sync, add async later  
ğŸ”‘ **Measure first**: Benchmark before migrating  
ğŸ”‘ **Hybrid approach**: Mix both as needed  

---

## O. Quick Decision Checklist

Ask yourself:

- [ ] Do I have 20+ independent tests?
- [ ] Are operations truly independent (no dependencies)?
- [ ] Is test execution time a problem (>30s)?
- [ ] Is the team comfortable with async Python?
- [ ] Do I need faster CI/CD feedback?

**If 3+ checked** â†’ Consider async  
**If <3 checked** â†’ Stick with sync

---

## P. What's Next?

In **Lesson 2.4: Installing pytest-asyncio**, we'll:
- Install pytest-asyncio
- Configure pytest for async tests
- Verify installation
- Understand configuration options
- Set up your first async test environment

You now know WHEN to use async! Let's learn HOW to set it up. ğŸš€

**Ready for lesson 2.4?**
