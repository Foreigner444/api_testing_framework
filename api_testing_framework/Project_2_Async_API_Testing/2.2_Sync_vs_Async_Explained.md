# Lesson 2.2: Sync vs Async Explained

## A. Concept Overview

### What & Why
**Understanding the difference between synchronous and asynchronous code** is fundamental to writing async tests. Sync code executes one operation at a time (blocking), while async code can juggle multiple operations (non-blocking). This distinction is crucial because it determines how fast your tests run and how you structure your code.

### Analogy
**Sync (Synchronous)**: Like washing dishes one at a time. Pick up plate, wash it, dry it, put it away. Then start the next plate. If you have 10 plates, you're standing there for 10 minutes doing nothing but dishes sequentially.

**Async (Asynchronous)**: Like a dishwasher. Load all 10 plates, start the machine, go do other things while it runs. The dishwasher handles multiple plates "concurrently" while you accomplish other tasks. Total time to clean 10 plates: same as 1 plate!

---

## B. Synchronous Code Deep Dive

### How Sync Works

```python
import httpx
import time

def fetch_user_sync(user_id):
    """Synchronous function - blocks until complete."""
    print(f"Starting request for user {user_id}")
    response = httpx.get(f"https://jsonplaceholder.typicode.com/users/{user_id}")
    print(f"Finished request for user {user_id}")
    return response.json()

# Execute synchronously
start = time.time()

user1 = fetch_user_sync(1)  # Blocks here, waits ~1 second
user2 = fetch_user_sync(2)  # Then blocks here, waits ~1 second
user3 = fetch_user_sync(3)  # Then blocks here, waits ~1 second

end = time.time()
print(f"Total time: {end - start:.2f} seconds")  # ~3 seconds
```

**Output**:
```
Starting request for user 1
Finished request for user 1
Starting request for user 2
Finished request for user 2
Starting request for user 3
Finished request for user 3
Total time: 3.00 seconds
```

**What happens**:
1. Call `fetch_user_sync(1)` â†’ Wait for response â†’ Continue
2. Call `fetch_user_sync(2)` â†’ Wait for response â†’ Continue
3. Call `fetch_user_sync(3)` â†’ Wait for response â†’ Continue
4. Total time = Sum of all waits

---

## C. Asynchronous Code Deep Dive

### How Async Works

```python
import httpx
import asyncio
import time

async def fetch_user_async(client, user_id):
    """Asynchronous function - non-blocking."""
    print(f"Starting request for user {user_id}")
    response = await client.get(f"https://jsonplaceholder.typicode.com/users/{user_id}")
    print(f"Finished request for user {user_id}")
    return response.json()

async def main():
    """Main async function."""
    start = time.time()
    
    async with httpx.AsyncClient() as client:
        # Create tasks (doesn't execute yet)
        task1 = fetch_user_async(client, 1)
        task2 = fetch_user_async(client, 2)
        task3 = fetch_user_async(client, 3)
        
        # Execute all concurrently
        user1, user2, user3 = await asyncio.gather(task1, task2, task3)
    
    end = time.time()
    print(f"Total time: {end - start:.2f} seconds")  # ~1 second!

# Run async function
asyncio.run(main())
```

**Output**:
```
Starting request for user 1
Starting request for user 2
Starting request for user 3
Finished request for user 1
Finished request for user 2
Finished request for user 3
Total time: 1.05 seconds
```

**What happens**:
1. All three `fetch_user_async()` calls start **immediately**
2. While waiting for responses, event loop switches between them
3. Responses arrive and are processed
4. Total time = Time of **slowest** request (not sum!)

---

## D. Side-by-Side Comparison

### Visual Timeline

**Synchronous (3 seconds total)**:
```
Time: 0s         1s         2s         3s
      |----------|----------|----------|
      [Request 1]
                 [Request 2]
                            [Request 3]
```

**Asynchronous (1 second total)**:
```
Time: 0s         1s
      |----------|
      [Request 1]
      [Request 2]
      [Request 3]
```

All three requests happen "at the same time" (concurrently)!

---

## E. Code Comparison

### Sync Version

File: `examples/sync_example.py`
```python
"""Synchronous API testing example."""
import httpx
import time


def test_three_users_sync():
    """Fetch 3 users synchronously."""
    start = time.time()
    
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        # One at a time
        response1 = client.get("/users/1")  # Wait...
        response2 = client.get("/users/2")  # Wait...
        response3 = client.get("/users/3")  # Wait...
        
        # Verify
        assert response1.status_code == 200
        assert response2.status_code == 200
        assert response3.status_code == 200
    
    end = time.time()
    elapsed = end - start
    print(f"Sync time: {elapsed:.2f}s")
    return elapsed


if __name__ == "__main__":
    sync_time = test_three_users_sync()
    print(f"Total: {sync_time:.2f} seconds")
```

---

### Async Version

File: `examples/async_example.py`
```python
"""Asynchronous API testing example."""
import httpx
import asyncio
import time


async def test_three_users_async():
    """Fetch 3 users asynchronously."""
    start = time.time()
    
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        # All at once!
        responses = await asyncio.gather(
            client.get("/users/1"),
            client.get("/users/2"),
            client.get("/users/3")
        )
        
        # Verify
        for response in responses:
            assert response.status_code == 200
    
    end = time.time()
    elapsed = end - start
    print(f"Async time: {elapsed:.2f}s")
    return elapsed


if __name__ == "__main__":
    async_time = asyncio.run(test_three_users_async())
    print(f"Total: {async_time:.2f} seconds")
```

**Speed Comparison**:
- Sync: ~3 seconds
- Async: ~1 second
- **Speedup: 3x faster!**

---

## F. Key Differences Explained

### 1. Function Definition

**Sync**:
```python
def my_function():
    return result
```

**Async**:
```python
async def my_function():  # Note: async keyword
    return result
```

---

### 2. Calling Functions

**Sync**:
```python
result = my_function()  # Direct call
```

**Async**:
```python
result = await my_function()  # Must use await
```

**Important**: Can only use `await` inside `async` functions!

---

### 3. Running Async Code

**Sync**: Just call it
```python
test_something_sync()
```

**Async**: Need event loop
```python
# In script
asyncio.run(test_something_async())

# In pytest with pytest-asyncio
@pytest.mark.asyncio
async def test_something_async():
    # pytest-asyncio handles event loop
    pass
```

---

### 4. HTTP Client

**Sync**:
```python
import httpx

# Synchronous client
with httpx.Client() as client:
    response = client.get(url)
```

**Async**:
```python
import httpx

# Asynchronous client
async with httpx.AsyncClient() as client:
    response = await client.get(url)  # Must await!
```

---

### 5. Context Managers

**Sync**:
```python
with httpx.Client() as client:
    response = client.get(url)
```

**Async**:
```python
async with httpx.AsyncClient() as client:  # async with
    response = await client.get(url)
```

---

## G. When to Use Each

### Use Synchronous When:

âœ… **Single operations**: One API call at a time
```python
def test_single_user():
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
```

âœ… **Sequential workflows**: Order matters
```python
def test_user_lifecycle():
    # Must be sequential
    user = create_user()
    update_user(user["id"])
    delete_user(user["id"])
```

âœ… **Simple tests**: Complexity not worth it
âœ… **Learning**: Easier to understand
âœ… **Debugging**: Simpler error traces

---

### Use Asynchronous When:

âœ… **Multiple independent operations**: Can run together
```python
async def test_multiple_users():
    async with httpx.AsyncClient() as client:
        # All run concurrently
        await asyncio.gather(
            client.get("/users/1"),
            client.get("/users/2"),
            client.get("/users/3")
        )
```

âœ… **Large test suites**: Many tests
âœ… **Performance critical**: Speed matters
âœ… **Smoke tests**: Check many endpoints
âœ… **Load testing**: Simulate concurrent users

---

## H. The Event Loop Explained Simply

### What is the Event Loop?

The event loop is Python's async task manager. It:
1. Keeps track of async tasks
2. Switches between them when waiting
3. Processes results as they arrive

**Analogy**: Like a restaurant manager:
- Takes order from table 1 (starts request 1)
- While kitchen cooks, takes order from table 2 (starts request 2)
- When food ready for table 1, delivers it (processes response 1)
- Continues juggling all tables efficiently

### You Don't Need to Manage It!

```python
# âŒ Don't do this manually
loop = asyncio.get_event_loop()
loop.run_until_complete(my_async_function())

# âœ… Do this instead
asyncio.run(my_async_function())  # In scripts

# âœ… Or use pytest-asyncio
@pytest.mark.asyncio
async def test_something():
    # pytest handles event loop
    pass
```

---

## I. Common Patterns Comparison

### Pattern 1: Multiple API Calls

**Sync (Sequential)**:
```python
def test_sync():
    response1 = httpx.get("https://api.example.com/users/1")
    response2 = httpx.get("https://api.example.com/users/2")
    response3 = httpx.get("https://api.example.com/users/3")
    # Time: 3 seconds
```

**Async (Concurrent)**:
```python
async def test_async():
    async with httpx.AsyncClient() as client:
        responses = await asyncio.gather(
            client.get("https://api.example.com/users/1"),
            client.get("https://api.example.com/users/2"),
            client.get("https://api.example.com/users/3")
        )
    # Time: 1 second
```

---

### Pattern 2: Loop Over Items

**Sync**:
```python
def test_all_users_sync():
    for user_id in range(1, 11):
        response = httpx.get(f"https://api.example.com/users/{user_id}")
        assert response.status_code == 200
    # Time: 10 seconds
```

**Async**:
```python
async def test_all_users_async():
    async with httpx.AsyncClient() as client:
        tasks = [
            client.get(f"https://api.example.com/users/{user_id}")
            for user_id in range(1, 11)
        ]
        responses = await asyncio.gather(*tasks)
        
        for response in responses:
            assert response.status_code == 200
    # Time: 1-2 seconds
```

---

### Pattern 3: Different Endpoints

**Sync**:
```python
def test_multiple_endpoints_sync():
    users = httpx.get("https://api.example.com/users").json()
    posts = httpx.get("https://api.example.com/posts").json()
    comments = httpx.get("https://api.example.com/comments").json()
    # Time: Sum of all
```

**Async**:
```python
async def test_multiple_endpoints_async():
    async with httpx.AsyncClient() as client:
        users, posts, comments = await asyncio.gather(
            client.get("https://api.example.com/users"),
            client.get("https://api.example.com/posts"),
            client.get("https://api.example.com/comments")
        )
    # Time: Time of slowest
```

---

## J. Syntax Differences Summary

| Aspect | Synchronous | Asynchronous |
|--------|-------------|--------------|
| **Define function** | `def func():` | `async def func():` |
| **Call function** | `result = func()` | `result = await func()` |
| **HTTP Client** | `httpx.Client()` | `httpx.AsyncClient()` |
| **Context manager** | `with client:` | `async with client:` |
| **HTTP request** | `client.get(url)` | `await client.get(url)` |
| **Run in script** | `func()` | `asyncio.run(func())` |
| **pytest marker** | None needed | `@pytest.mark.asyncio` |

---

## K. Real-World Example

Let's test fetching user data and their posts:

### Sync Version (Slow)

```python
import httpx

def test_user_with_posts_sync():
    """Fetch user and their posts synchronously."""
    base_url = "https://jsonplaceholder.typicode.com"
    
    # Step 1: Get user (wait 1s)
    user_response = httpx.get(f"{base_url}/users/1")
    user = user_response.json()
    
    # Step 2: Get user's posts (wait 1s)
    posts_response = httpx.get(f"{base_url}/posts?userId={user['id']}")
    posts = posts_response.json()
    
    # Step 3: Get first post's comments (wait 1s)
    comments_response = httpx.get(f"{base_url}/posts/{posts[0]['id']}/comments")
    comments = comments_response.json()
    
    # Total: ~3 seconds
    assert user["id"] == 1
    assert len(posts) > 0
    assert len(comments) > 0
```

---

### Async Version (Fast)

```python
import httpx
import asyncio

async def test_user_with_posts_async():
    """Fetch user and their posts asynchronously."""
    base_url = "https://jsonplaceholder.typicode.com"
    
    async with httpx.AsyncClient(base_url=base_url) as client:
        # Step 1: Get user (necessary first step)
        user_response = await client.get("/users/1")
        user = user_response.json()
        
        # Step 2 & 3: Get posts and comments CONCURRENTLY!
        posts_response, comments_response = await asyncio.gather(
            client.get(f"/posts?userId={user['id']}"),
            client.get("/posts/1/comments")
        )
        
        posts = posts_response.json()
        comments = comments_response.json()
    
    # Total: ~2 seconds (instead of 3)
    assert user["id"] == 1
    assert len(posts) > 0
    assert len(comments) > 0
```

**Note**: Step 1 must finish first (we need user ID), but steps 2 and 3 can run together!

---

## L. The await Keyword

### What does await do?

```python
# Without await (wrong!)
async def test_wrong():
    response = client.get(url)  # Returns coroutine object, not response!
    # âŒ Error: 'coroutine' object has no attribute 'status_code'

# With await (correct!)
async def test_correct():
    response = await client.get(url)  # Waits for and returns response
    # âœ… response is httpx.Response object
```

**await** means:
- "Start this async operation"
- "Switch to other tasks while waiting"
- "Come back when result is ready"
- "Give me the actual result"

---

## M. Common Misconceptions

### Misconception 1: "Async makes code run faster"

**Wrong**: Async doesn't make individual operations faster.

**Right**: Async lets you do many things **at the same time**, reducing **total** time.

**Example**:
```python
# Single request
sync_time = 1 second
async_time = 1 second  # Same!

# 10 requests
sync_total = 10 seconds (one after another)
async_total = 1-2 seconds (all together)  # Much faster!
```

---

### Misconception 2: "Async is multi-threaded"

**Wrong**: Async Python is single-threaded.

**Right**: One thread switches between tasks (cooperative multitasking).

**Visual**:
```
Sync (Single Thread):
[Task1] â†’ [Task2] â†’ [Task3]

Multi-Threading (Multiple Threads):
[Task1]
[Task2]  â† All running simultaneously on different threads
[Task3]

Async (Single Thread, Switching):
[Task1...] â†’ [Task2...] â†’ [Task3...] â†’ [Task1...] â†’ [Task2...]
 â†‘ Switches between tasks while waiting
```

---

### Misconception 3: "Everything should be async"

**Wrong**: Async everywhere adds complexity.

**Right**: Use async for I/O-bound operations (network, file access). Not for CPU-bound work.

**When sync is fine**:
- Simple single API call
- Sequential workflows
- Quick scripts
- Learning basics

---

## N. Performance Breakdown

### Why Async is Faster for API Tests

**The secret**: Network latency!

**Typical API request timing**:
```
Connection establishment: 100ms
Send request: 10ms
Wait for server: 500ms â† Wasted time!
Receive response: 50ms

Total: 660ms per request
Wasted waiting: 500ms (76% of time!)
```

**With sync**:
- Request 1: Wait 660ms (500ms idle)
- Request 2: Wait 660ms (500ms idle)
- Request 3: Wait 660ms (500ms idle)
- **Total: 1980ms, wasted: 1500ms**

**With async**:
- All 3 requests start together
- While Request 1 waits, start Request 2 and 3
- All finish around same time
- **Total: ~660ms, wasted: minimal**

---

## O. Code Migration Guide

### Converting Sync to Async

**Step 1**: Add `async` to function
```python
# Before
def test_something():

# After
async def test_something():
```

**Step 2**: Use `AsyncClient` instead of `Client`
```python
# Before
with httpx.Client() as client:

# After
async with httpx.AsyncClient() as client:
```

**Step 3**: Add `await` to async operations
```python
# Before
response = client.get(url)

# After
response = await client.get(url)
```

**Step 4**: Add pytest marker
```python
# Before
def test_something():

# After
@pytest.mark.asyncio
async def test_something():
```

**Step 5**: Use `asyncio.gather()` for concurrent operations
```python
# Before (sequential)
r1 = client.get(url1)
r2 = client.get(url2)

# After (concurrent)
r1, r2 = await asyncio.gather(
    client.get(url1),
    client.get(url2)
)
```

---

## P. Common Mistakes

### Mistake 1: Forgetting `await`

```python
# âŒ Wrong
async def test_wrong():
    async with httpx.AsyncClient() as client:
        response = client.get(url)  # Missing await!
        # response is a coroutine, not Response object
```

**Error**:
```
RuntimeWarning: coroutine 'AsyncClient.get' was never awaited
```

**Fix**:
```python
# âœ… Correct
async def test_correct():
    async with httpx.AsyncClient() as client:
        response = await client.get(url)  # Added await
```

---

### Mistake 2: Using `await` in sync function

```python
# âŒ Wrong
def test_wrong():  # Not async!
    async with httpx.AsyncClient() as client:
        response = await client.get(url)  # Can't await in sync function!
```

**Error**:
```
SyntaxError: 'await' outside async function
```

**Fix**:
```python
# âœ… Correct
async def test_correct():  # Made it async
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
```

---

### Mistake 3: Mixing sync and async clients

```python
# âŒ Wrong
async def test_mixed():
    with httpx.Client() as client:  # Sync client in async function!
        response = await client.get(url)  # Can't await sync operation
```

**Fix**:
```python
# âœ… Correct
async def test_async():
    async with httpx.AsyncClient() as client:  # Async client
        response = await client.get(url)  # Await async operation
```

---

### Mistake 4: Forgetting pytest-asyncio marker

```python
# âŒ Wrong - pytest won't run this
async def test_something():
    pass

# âœ… Correct
import pytest

@pytest.mark.asyncio
async def test_something():
    pass
```

---

## Q. Quick Comparison Test

Let's create both versions to see the difference:

File: `tests/test_sync_vs_async_comparison.py`
```python
"""
Direct comparison of sync vs async testing.
"""
import httpx
import asyncio
import time
import pytest


def test_ten_requests_sync():
    """Test 10 requests synchronously."""
    start = time.time()
    
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        for i in range(1, 11):
            response = client.get(f"/users/{i}")
            assert response.status_code == 200
    
    end = time.time()
    sync_time = end - start
    print(f"\nSync time: {sync_time:.2f} seconds")


@pytest.mark.asyncio
async def test_ten_requests_async():
    """Test 10 requests asynchronously."""
    start = time.time()
    
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        tasks = [client.get(f"/users/{i}") for i in range(1, 11)]
        responses = await asyncio.gather(*tasks)
        
        for response in responses:
            assert response.status_code == 200
    
    end = time.time()
    async_time = end - start
    print(f"\nAsync time: {async_time:.2f} seconds")
```

**Run both**:
```bash
pytest tests/test_sync_vs_async_comparison.py -v -s
```

**Expected output**:
```
Sync time: 8.50 seconds
Async time: 1.20 seconds

Speedup: ~7x faster!
```

---

## R. Key Takeaways

ğŸ”‘ **Sync**: One operation at a time (blocking)  
ğŸ”‘ **Async**: Multiple operations concurrently (non-blocking)  
ğŸ”‘ **async def**: Defines async function  
ğŸ”‘ **await**: Waits for async operation  
ğŸ”‘ **AsyncClient**: httpx async HTTP client  
ğŸ”‘ **asyncio.gather()**: Run multiple tasks together  
ğŸ”‘ **Event loop**: Manages async tasks (automatic)  
ğŸ”‘ **Speedup**: 5-50x for independent tests  
ğŸ”‘ **Use cases**: Independent operations, large suites  
ğŸ”‘ **Not magic**: Just better task switching  

---

## S. Quick Check

Before moving on:

1. What's the main difference between sync and async?
2. Does async make a single request faster?
3. What keyword defines an async function?
4. What keyword waits for an async operation?
5. When should you NOT use async?

**Answers**:
1. Sync = sequential, async = concurrent
2. No, but many requests together are faster
3. `async`
4. `await`
5. Sequential workflows, simple single operations

---

## T. What's Next?

In **Lesson 2.3: When to Use Async Tests**, we'll dive deeper into decision-making:
- Detailed decision tree
- Real-world scenarios
- Performance calculations
- Trade-offs to consider
- Migration strategies

You now understand the fundamental difference between sync and async! Let's learn when to use each. ğŸš€

**Ready for lesson 2.3?**
