# Lesson 2.8: Async Fixtures in pytest

## A. Concept Overview

### What & Why
**Async fixtures** are reusable async setup/teardown functions that provide resources for async tests. They're important because they eliminate duplication, ensure consistent test setup, and make async tests cleaner and more maintainable.

### Analogy
Async fixtures are like a pit crew at a race. Instead of each driver setting up their own car before every race (duplicated effort), the pit crew prepares the car once and hands it to each driver. Async fixtures prepare async resources (like AsyncClient) and provide them to each test!

---

## B. Sync vs Async Fixtures

### Sync Fixture (from Project 1)

```python
import pytest
import httpx

@pytest.fixture
def sync_client():
    \"\"\"Sync fixture for regular Client.\"\"\"
    with httpx.Client(base_url="https://jsonplaceholder.typicode.com") as client:
        yield client


def test_with_sync_fixture(sync_client):
    \"\"\"Regular sync test.\"\"\"
    response = sync_client.get("/users/1")
    assert response.status_code == 200
```

---

### Async Fixture

```python
import pytest
import httpx

@pytest.fixture
async def async_client():
    \"\"\"Async fixture for AsyncClient.\"\"\"
    async with httpx.AsyncClient(base_url="https://jsonplaceholder.typicode.com") as client:
        yield client


@pytest.mark.asyncio
async def test_with_async_fixture(async_client):
    \"\"\"Async test using async fixture.\"\"\"
    response = await async_client.get("/users/1")
    assert response.status_code == 200
```

**Key differences**:
- Fixture function is `async def` (not def)
- Uses `async with` (not with)
- Test receives async client

---

## C. Creating Async Fixtures

File: `tests/conftest.py`
```python
\"\"\"
Shared async fixtures for all tests.
\"\"\"
import pytest
import httpx


@pytest.fixture
async def api_client():
    \"\"\"Provide configured async API client.\"\"\"
    async with httpx.AsyncClient(
        base_url="https://jsonplaceholder.typicode.com",
        timeout=10.0,
        headers={"User-Agent": "AsyncTestSuite/1.0"}
    ) as client:
        yield client


@pytest.fixture
async def httpbin_client():
    \"\"\"Provide httpbin async client for testing.\"\"\"
    async with httpx.AsyncClient(base_url="https://httpbin.org") as client:
        yield client


@pytest.fixture
async def api_with_auth():
    \"\"\"Provide authenticated async client.\"\"\"
    async with httpx.AsyncClient(
        base_url="https://api.example.com",
        headers={"Authorization": "Bearer test-token-123"}
    ) as client:
        yield client
```

---

## D. Using Async Fixtures in Tests

File: `tests/test_with_async_fixtures.py`
```python
\"\"\"
Tests using async fixtures.
\"\"\"
import pytest


@pytest.mark.asyncio
async def test_get_user(api_client):
    \"\"\"Test using api_client fixture.\"\"\"
    response = await api_client.get("/users/1")
    
    assert response.status_code == 200
    data = response.json()
    assert data["id"] == 1


@pytest.mark.asyncio
async def test_get_posts(api_client):
    \"\"\"Another test reusing same fixture.\"\"\"
    response = await api_client.get("/posts")
    
    assert response.status_code == 200
    posts = response.json()
    assert len(posts) > 0


@pytest.mark.asyncio
async def test_concurrent_requests(api_client):
    \"\"\"Test concurrent requests with fixture.\"\"\"
    import asyncio
    
    # Use fixture client for concurrent requests
    responses = await asyncio.gather(
        api_client.get("/users/1"),
        api_client.get("/users/2"),
        api_client.get("/users/3")
    )
    
    for response in responses:
        assert response.status_code == 200


@pytest.mark.asyncio
async def test_httpbin_echo(httpbin_client):
    \"\"\"Test using httpbin_client fixture.\"\"\"
    response = await httpbin_client.get("/get")
    
    assert response.status_code == 200
    data = response.json()
    assert "url" in data
```

---

## E. Fixture Scopes for Async

### Function Scope (Default)

```python
@pytest.fixture
async def function_scope_client():
    \"\"\"New client for each test (default).\"\"\"
    async with httpx.AsyncClient() as client:
        yield client
    # Created and destroyed for EACH test
```

**Use when**: Tests might modify state, need isolation

---

### Module Scope

```python
@pytest.fixture(scope="module")
async def module_scope_client():
    \"\"\"One client for entire test module.\"\"\"
    async with httpx.AsyncClient() as client:
        yield client
    # Created once, reused by all tests in module
```

**Use when**: Tests are read-only, faster execution needed

---

### Session Scope

```python
@pytest.fixture(scope="session")
async def session_scope_client():
    \"\"\"One client for entire test session.\"\"\"
    async with httpx.AsyncClient() as client:
        yield client
    # Created once for all tests in all modules
```

**Use when**: Maximum performance, all tests read-only

---

## F. Multiple Async Fixtures

Tests can use multiple async fixtures:

```python
@pytest.fixture
async def users_client():
    \"\"\"Client for users API.\"\"\"
    async with httpx.AsyncClient(base_url="https://api.example.com/users") as client:
        yield client


@pytest.fixture
async def posts_client():
    \"\"\"Client for posts API.\"\"\"
    async with httpx.AsyncClient(base_url="https://api.example.com/posts") as client:
        yield client


@pytest.mark.asyncio
async def test_with_multiple_fixtures(users_client, posts_client):
    \"\"\"Test using multiple async fixtures.\"\"\"
    # Use both clients concurrently
    user_response, posts_response = await asyncio.gather(
        users_client.get("/1"),
        posts_client.get("/?userId=1")
    )
    
    assert user_response.status_code == 200
    assert posts_response.status_code == 200
```

---

## G. Fixture Dependencies

Async fixtures can depend on other fixtures:

```python
@pytest.fixture
async def base_client():
    \"\"\"Base async client.\"\"\"
    async with httpx.AsyncClient() as client:
        yield client


@pytest.fixture
async def authenticated_client(base_client):
    \"\"\"Fixture that depends on base_client.\"\"\"
    # Get auth token
    auth_response = await base_client.post(
        "https://api.example.com/auth/login",
        json={"username": "test", "password": "test123"}
    )
    token = auth_response.json()["token"]
    
    # Create authenticated client
    async with httpx.AsyncClient(
        base_url="https://api.example.com",
        headers={"Authorization": f"Bearer {token}"}
    ) as client:
        yield client


@pytest.mark.asyncio
async def test_with_auth(authenticated_client):
    \"\"\"Test with authenticated client fixture.\"\"\"
    response = await authenticated_client.get("/users/me")
    assert response.status_code == 200
```

---

## H. Async Fixture Patterns

### Pattern 1: Test Data Setup

```python
@pytest.fixture
async def test_user(api_client):
    \"\"\"Create test user before test.\"\"\"
    # Setup: Create user
    create_response = await api_client.post(
        "/users",
        json={"name": "Test User", "email": "test@example.com"}
    )
    user = create_response.json()
    
    yield user  # Provide to test
    
    # Teardown: Delete user
    await api_client.delete(f"/users/{user['id']}")


@pytest.mark.asyncio
async def test_with_test_user(test_user, api_client):
    \"\"\"Test that automatically has a user created.\"\"\"
    # User already exists from fixture
    response = await api_client.get(f"/users/{test_user['id']}")
    assert response.status_code == 200
    # User automatically deleted after test
```

---

### Pattern 2: Configuration Fixture

```python
@pytest.fixture
async def api_config():
    \"\"\"Provide API configuration.\"\"\"
    return {
        "base_url": "https://jsonplaceholder.typicode.com",
        "timeout": 10.0,
        "max_retries": 3
    }


@pytest.fixture
async def configured_client(api_config):
    \"\"\"Client configured from config fixture.\"\"\"
    async with httpx.AsyncClient(
        base_url=api_config["base_url"],
        timeout=api_config["timeout"]
    ) as client:
        yield client


@pytest.mark.asyncio
async def test_with_config(configured_client):
    \"\"\"Test using configured client.\"\"\"
    response = await configured_client.get("/users/1")
    assert response.status_code == 200
```

---

## I. Common Mistakes with Async Fixtures

### Mistake 1: Forgetting async keyword

```python
# ‚ùå Wrong - sync fixture for async resource
@pytest.fixture
def async_client():  # Should be async def!
    async with httpx.AsyncClient() as client:
        yield client

# ‚úÖ Correct
@pytest.fixture
async def async_client():  # async def
    async with httpx.AsyncClient() as client:
        yield client
```

---

### Mistake 2: Not awaiting fixture operations

```python
# ‚ùå Wrong
@pytest.fixture
async def test_data(client):
    response = client.post("/users", json={...})  # Missing await!
    yield response.json()

# ‚úÖ Correct
@pytest.fixture
async def test_data(client):
    response = await client.post("/users", json={...})  # Added await
    yield response.json()
```

---

### Mistake 3: Using sync fixture in async test

```python
# Sync fixture
@pytest.fixture
def sync_client():
    with httpx.Client() as client:
        yield client

# ‚ùå Wrong - using sync client in async test
@pytest.mark.asyncio
async def test_wrong(sync_client):
    response = await sync_client.get(url)  # Can't await sync operation!

# ‚úÖ Correct - use async fixture
@pytest.fixture
async def async_client():
    async with httpx.AsyncClient() as client:
        yield client

@pytest.mark.asyncio
async def test_correct(async_client):
    response = await async_client.get(url)  # Can await async operation
```

---

## J. Complete Fixture Example

File: `tests/conftest.py`
```python
\"\"\"
Complete async fixtures setup.
\"\"\"
import pytest
import httpx
import asyncio


@pytest.fixture(scope="session")
def event_loop():
    \"\"\"Create event loop for session.\"\"\"
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


@pytest.fixture
async def json_placeholder_client():
    \"\"\"JSONPlaceholder async client.\"\"\"
    async with httpx.AsyncClient(
        base_url="https://jsonplaceholder.typicode.com",
        timeout=10.0
    ) as client:
        yield client


@pytest.fixture
async def httpbin_client():
    \"\"\"httpbin async client.\"\"\"
    async with httpx.AsyncClient(
        base_url="https://httpbin.org",
        timeout=5.0
    ) as client:
        yield client


@pytest.fixture
async def test_post(json_placeholder_client):
    \"\"\"Create and cleanup test post.\"\"\"
    # Setup: Create post
    response = await json_placeholder_client.post(
        "/posts",
        json={"title": "Test", "body": "Content", "userId": 1}
    )
    post = response.json()
    
    yield post
    
    # Teardown: Delete post
    await json_placeholder_client.delete(f"/posts/{post['id']}")
```

---

## K. Key Takeaways

üîë **Async fixtures**: Use `async def` for fixture  
üîë **async with**: For async context managers  
üîë **await**: In fixture operations  
üîë **Reusable**: Share async clients across tests  
üîë **Setup/teardown**: yield separates them  
üîë **Scopes**: function, module, session  
üîë **Dependencies**: Fixtures can use other fixtures  
üîë **conftest.py**: Put shared fixtures here  

---

## L. What's Next?

In **Lesson 2.9: Testing Multiple Endpoints Concurrently**, we'll master the core async pattern‚Äîtesting many endpoints simultaneously for maximum performance!

Ready? üöÄ
