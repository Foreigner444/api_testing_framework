# Lesson 1.5: Setting Up pytest for API Testing

## A. Concept Overview

### What & Why
**pytest** is Python's most popular testing framework. It's important because it makes writing and running tests incredibly simple, provides powerful features out of the box, and has excellent support for API testing.

### Analogy
Think of pytest like a quality control system in a factory. Instead of manually checking each product (running tests by hand), you set up automated inspection stations (test functions). pytest is the conveyor belt system that runs all your inspections automatically, reports which ones passed, and shows exactly what failed.

---

## B. Why pytest?

### Advantages Over Other Testing Frameworks

**pytest vs unittest (Python's built-in)**:
- âœ… Simpler syntax - just use `assert`, no `self.assertEqual()`
- âœ… Better error messages
- âœ… Powerful fixtures (shared setup/teardown)
- âœ… Parameterization built-in
- âœ… Huge plugin ecosystem

**pytest vs other tools**:
- More Pythonic and readable
- Auto-discovery of tests
- Rich ecosystem (pytest-asyncio, pytest-cov, pytest-xdist, allure-pytest)
- Industry standard for Python API testing

---

## C. Installing pytest

### Prerequisites
- Python 3.10 or higher installed
- pip (Python package manager)

### Installation Steps

**Step 1: Create a project directory**
```bash
mkdir api_testing_project
cd api_testing_project
```

**Step 2: Create a virtual environment (recommended)**
```bash
# Create virtual environment
python3 -m venv venv

# Activate it
# On Mac/Linux:
source venv/bin/activate

# On Windows:
venv\Scripts\activate
```

**Why virtual environment?**
- Isolates project dependencies
- Prevents version conflicts
- Makes project portable

**Step 3: Install pytest**
```bash
pip install pytest
```

**Step 4: Verify installation**
```bash
pytest --version
```

**Expected output**:
```
pytest 8.0.0
```

---

## D. Project Structure

Let's set up a proper project structure:

```
api_testing_project/
â”œâ”€â”€ venv/                  # Virtual environment (don't commit)
â”œâ”€â”€ tests/                 # All test files go here
â”‚   â”œâ”€â”€ __init__.py       # Makes tests a package
â”‚   â””â”€â”€ test_example.py   # Test files start with "test_"
â”œâ”€â”€ .gitignore            # Ignore venv and cache files
â””â”€â”€ requirements.txt      # Project dependencies
```

### Creating the Structure

**Step 1: Create directories**
```bash
mkdir tests
touch tests/__init__.py
```

**Step 2: Create .gitignore**

File: `.gitignore`
```gitignore
# Virtual environment
venv/
env/

# Python cache
__pycache__/
*.pyc
*.pyo
*.pyd
.Python

# pytest cache
.pytest_cache/
.coverage
htmlcov/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
```

**Step 3: Create requirements.txt**

File: `requirements.txt`
```
pytest==8.0.0
```

**Why requirements.txt?**
- Documents project dependencies
- Makes setup reproducible
- Others can install with: `pip install -r requirements.txt`

---

## E. Your First pytest Test

Let's write a simple test to understand pytest basics.

File: `tests/test_example.py`
```python
"""
Example tests to understand pytest basics.
"""


def test_simple_assertion():
    """Test basic assertion."""
    result = 2 + 2
    assert result == 4


def test_string_operations():
    """Test string methods."""
    text = "hello"
    assert text.upper() == "HELLO"
    assert text.startswith("h")
    assert len(text) == 5


def test_list_operations():
    """Test list operations."""
    numbers = [1, 2, 3, 4, 5]
    assert 3 in numbers
    assert len(numbers) == 5
    assert numbers[0] == 1


def test_dictionary():
    """Test dictionary access."""
    user = {
        "name": "John",
        "age": 30,
        "active": True
    }
    assert user["name"] == "John"
    assert user["age"] == 30
    assert user["active"] is True
```

### Line-by-Line Explanation

**Line 1-3**: Docstring explaining what the file contains (optional but good practice)

**Line 6**: Function name MUST start with `test_`
- pytest auto-discovers functions starting with `test_`

**Line 7**: Docstring explaining what this test does (optional but recommended)

**Line 8-9**: The actual test logic
- Calculate something
- Use `assert` to check if it's correct

**Key Points**:
- âœ… Use plain `assert` statement (not `assertEqual()` like unittest)
- âœ… One assertion or multiple related assertions per test
- âœ… Test functions don't need `self` or class
- âœ… Descriptive function names explain what's being tested

---

## F. Running pytest

### Basic Commands

**Run all tests**:
```bash
pytest
```

**Run with verbose output**:
```bash
pytest -v
```

**Run specific file**:
```bash
pytest tests/test_example.py
```

**Run specific test function**:
```bash
pytest tests/test_example.py::test_simple_assertion
```

**Run tests matching a pattern**:
```bash
pytest -k "string"  # Runs tests with "string" in name
```

---

## G. Understanding pytest Output

Let's run our example tests and understand the output.

**Command**:
```bash
pytest tests/test_example.py -v
```

**Output**:
```
========================= test session starts ==========================
platform darwin -- Python 3.10.0, pytest-8.0.0, pluggy-1.4.0
cachedir: .pytest_cache
rootdir: /path/to/api_testing_project
collected 4 items

tests/test_example.py::test_simple_assertion PASSED            [ 25%]
tests/test_example.py::test_string_operations PASSED           [ 50%]
tests/test_example.py::test_list_operations PASSED             [ 75%]
tests/test_example.py::test_dictionary PASSED                  [100%]

========================== 4 passed in 0.02s ===========================
```

### Understanding Each Part

**Session header**:
```
platform darwin -- Python 3.10.0, pytest-8.0.0, pluggy-1.4.0
```
Shows Python version, pytest version, and platform

**Test collection**:
```
collected 4 items
```
pytest found 4 test functions

**Test results**:
```
tests/test_example.py::test_simple_assertion PASSED [ 25%]
```
- File path and test name
- `PASSED` = test succeeded
- `[ 25%]` = progress percentage

**Summary**:
```
4 passed in 0.02s
```
Total passed tests and execution time

---

## H. What Happens When Tests Fail?

Let's see pytest's excellent error messages.

File: `tests/test_failures.py`
```python
"""
Examples of failing tests to see error messages.
"""


def test_failing_assertion():
    """This test will fail."""
    result = 2 + 2
    assert result == 5  # Wrong!


def test_failing_string():
    """This test will also fail."""
    text = "hello"
    assert text == "HELLO"  # Case mismatch!
```

**Run it**:
```bash
pytest tests/test_failures.py -v
```

**Output**:
```
========================= test session starts ==========================
collected 2 items

tests/test_failures.py::test_failing_assertion FAILED          [ 50%]
tests/test_failures.py::test_failing_string FAILED             [100%]

=============================== FAILURES ===============================
______________________ test_failing_assertion __________________________

    def test_failing_assertion():
        """This test will fail."""
        result = 2 + 2
>       assert result == 5
E       assert 4 == 5

tests/test_failures.py:9: AssertionError
_________________________ test_failing_string __________________________

    def test_failing_string():
        """This test will also fail."""
        text = "hello"
>       assert text == "HELLO"
E       AssertionError: assert 'hello' == 'HELLO'
E         - HELLO
E         + hello

tests/test_failures.py:15: AssertionError
===================== short test summary info ==========================
FAILED tests/test_failures.py::test_failing_assertion - assert 4 == 5
FAILED tests/test_failures.py::test_failing_string - AssertionError...
======================== 2 failed in 0.05s =============================
```

### Reading Failure Messages

**1. Which test failed**:
```
______________________ test_failing_assertion __________________________
```

**2. The failing line** (marked with `>`):
```python
>       assert result == 5
```

**3. What went wrong** (marked with `E`):
```
E       assert 4 == 5
```

**4. File and line number**:
```
tests/test_failures.py:9: AssertionError
```

**Why this is great**:
- Shows exact line that failed
- Shows expected vs actual values
- Shows context (surrounding code)
- For strings, shows diff

---

## I. pytest Test Discovery Rules

pytest automatically finds tests if you follow these rules:

### Rule 1: Test File Names
âœ… **Must start with `test_`** or end with `_test.py`
```
âœ… test_users.py
âœ… test_api.py
âœ… users_test.py
âŒ users.py
âŒ testusers.py
```

### Rule 2: Test Function Names
âœ… **Must start with `test_`**
```python
âœ… def test_create_user():
âœ… def test_login():
âŒ def create_user_test():
âŒ def validate_user():
```

### Rule 3: Test Class Names
âœ… **Must start with `Test`** (capital T, no `__init__` method)
```python
âœ… class TestUsers:
âœ… class TestAuthentication:
âŒ class Users:
âŒ class test_users:
```

### Rule 4: Directory Structure
âœ… Tests in `tests/` or `test/` directory (or any subdirectory)
```
âœ… tests/test_users.py
âœ… tests/api/test_users.py
âœ… test/test_users.py
```

---

## J. pytest Configuration

Create a configuration file for project-wide settings.

File: `pytest.ini`
```ini
[pytest]
# Test discovery patterns
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Output options
addopts = 
    -v                  # Verbose output
    --strict-markers    # Strict marker checking
    --tb=short          # Shorter traceback format
    -ra                 # Show summary of all test outcomes

# Test paths
testpaths = tests

# Ignore patterns
norecursedirs = 
    venv
    env
    .git
    __pycache__

# Markers (we'll use these later)
markers =
    smoke: Quick smoke tests
    integration: Integration tests
    slow: Slow running tests
```

**What each option does**:

- `python_files`: Patterns for test files
- `python_classes`: Patterns for test classes
- `python_functions`: Patterns for test functions
- `addopts`: Default command-line options
- `testpaths`: Where to look for tests
- `norecursedirs`: Directories to ignore
- `markers`: Custom test markers (for categorization)

---

## K. Common pytest Command-Line Options

```bash
# Run all tests
pytest

# Verbose output
pytest -v

# Very verbose (show full diff)
pytest -vv

# Run specific file
pytest tests/test_users.py

# Run specific test
pytest tests/test_users.py::test_create_user

# Run tests matching pattern
pytest -k "create or delete"

# Stop after first failure
pytest -x

# Stop after N failures
pytest --maxfail=3

# Show local variables in tracebacks
pytest -l

# Run last failed tests only
pytest --lf

# Run failed tests first, then others
pytest --ff

# Show print statements
pytest -s

# Quiet output (less verbose)
pytest -q

# Show summary of all test outcomes
pytest -ra

# Run tests in parallel (requires pytest-xdist)
pytest -n auto
```

---

## L. Assert Statement Deep Dive

pytest's `assert` statement is powerful and provides great error messages.

### Basic Assertions
```python
def test_assertions():
    # Equality
    assert 5 == 5
    assert "hello" == "hello"
    
    # Inequality
    assert 5 != 6
    
    # Greater/Less than
    assert 10 > 5
    assert 3 < 7
    assert 5 >= 5
    assert 5 <= 10
    
    # Boolean
    assert True
    assert not False
    
    # Identity
    assert something is not None
    assert something is None
    
    # Membership
    assert "a" in ["a", "b", "c"]
    assert "x" not in ["a", "b", "c"]
```

### String Assertions
```python
def test_string_assertions():
    text = "Hello World"
    
    assert text.startswith("Hello")
    assert text.endswith("World")
    assert "World" in text
    assert text.lower() == "hello world"
    assert len(text) == 11
```

### Collection Assertions
```python
def test_collection_assertions():
    numbers = [1, 2, 3, 4, 5]
    
    assert len(numbers) == 5
    assert numbers[0] == 1
    assert 3 in numbers
    assert numbers == [1, 2, 3, 4, 5]
```

### Dictionary Assertions
```python
def test_dictionary_assertions():
    user = {"name": "John", "age": 30}
    
    assert user["name"] == "John"
    assert "age" in user
    assert user.get("email") is None
    assert len(user) == 2
```

### Asserting Exceptions
```python
import pytest

def test_exception():
    with pytest.raises(ValueError):
        int("not a number")
    
    with pytest.raises(KeyError):
        empty_dict = {}
        value = empty_dict["nonexistent"]
```

---

## M. Best Practices for Test Names

### Good Test Names

```python
âœ… def test_get_user_by_id_returns_user():
    """Clear: tells exactly what's being tested."""
    pass

âœ… def test_create_user_with_duplicate_email_returns_409():
    """Specific: includes expected outcome."""
    pass

âœ… def test_delete_nonexistent_user_returns_404():
    """Descriptive: easy to understand failure."""
    pass
```

### Bad Test Names

```python
âŒ def test_user():
    """Too vague - what about users?"""
    pass

âŒ def test_1():
    """Meaningless - doesn't describe what's tested."""
    pass

âŒ def test():
    """Won't even be discovered by pytest!"""
    pass
```

### Naming Pattern
```
test_<what>_<condition>_<expected_result>

Examples:
test_get_user_with_valid_id_returns_200
test_create_user_without_email_returns_400
test_delete_user_removes_from_database
```

---

## N. Common Stumbling Blocks

### Mistake 1: Forgetting to name tests with `test_` prefix
**The Error**:
```python
def check_user_creation():  # âŒ Won't be discovered!
    assert True
```

**The Fix**:
```python
def test_user_creation():  # âœ… Will be discovered
    assert True
```

### Mistake 2: Not activating virtual environment
**The Error**:
```bash
$ pytest
bash: pytest: command not found
```

**The Fix**:
```bash
# Activate venv first!
source venv/bin/activate  # Mac/Linux
# or
venv\Scripts\activate  # Windows

# Then run pytest
pytest
```

### Mistake 3: Running pytest from wrong directory
**The Error**:
```
ERROR: not found: tests/test_example.py
```

**The Fix**:
- Run pytest from project root directory
- Or use correct relative path

### Mistake 4: Multiple assertions with unclear failure
**Problem**: Test with many assertions - which one failed?

**Better Approach**: Use descriptive assertion messages
```python
# âœ… Good
def test_user_data():
    user = get_user()
    assert user["name"] == "John", f"Expected name 'John', got '{user['name']}'"
    assert user["age"] == 30, f"Expected age 30, got {user['age']}"
```

---

## O. Quick Exercise

Try this yourself!

**Task**: Create a test file that:
1. Creates a test for adding numbers
2. Creates a test for string concatenation
3. Creates a test that checks if a list contains an item
4. Run all tests and verify they pass

**Solution**:

File: `tests/test_exercise.py`
```python
"""Exercise: Basic pytest tests."""


def test_addition():
    """Test that addition works correctly."""
    result = 10 + 5
    assert result == 15


def test_string_concatenation():
    """Test string concatenation."""
    greeting = "Hello" + " " + "World"
    assert greeting == "Hello World"


def test_list_membership():
    """Test that item exists in list."""
    fruits = ["apple", "banana", "orange"]
    assert "banana" in fruits
```

**Run it**:
```bash
pytest tests/test_exercise.py -v
```

**Expected Output**: All 3 tests should pass! âœ…

---

## P. Key Takeaways

ğŸ”‘ **pytest**: Python's best testing framework  
ğŸ”‘ **Installation**: `pip install pytest`  
ğŸ”‘ **Test files**: Must start with `test_` or end with `_test.py`  
ğŸ”‘ **Test functions**: Must start with `test_`  
ğŸ”‘ **Assertions**: Use simple `assert` statement  
ğŸ”‘ **Running**: `pytest` or `pytest -v` for verbose  
ğŸ”‘ **Virtual environment**: Always use one!  
ğŸ”‘ **Structure**: Keep tests in `tests/` directory  

---

## Q. Quick Check

Before moving on:

1. What command installs pytest?
2. What must test function names start with?
3. How do you run pytest in verbose mode?
4. What's the benefit of using a virtual environment?
5. Where should test files be located?

---

## R. What's Next?

In **Lesson 1.6: Why httpx Over requests**, we'll learn about httpxâ€”the modern HTTP client we'll use instead of the older requests library. You'll see why httpx is faster, more powerful, and better for API testing!

You now have pytest set up and understand the basics! Next, we'll add the HTTP client to actually make API calls. ğŸš€

**Ready for lesson 1.6?**
