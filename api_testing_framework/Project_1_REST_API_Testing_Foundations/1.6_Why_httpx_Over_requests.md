# Lesson 1.6: Why httpx Over requests

## A. Concept Overview

### What & Why
**httpx** is a modern, next-generation HTTP client for Python that

 supports both sync and async operations. It's important because it's faster than the older `requests` library, has a nearly identical API (easy transition), and provides advanced features like HTTP/2 support and native async capabilities.

### Analogy
Think of `requests` as a reliable old car that gets you from A to B‚Äîit works great but lacks modern features. **httpx** is like a new electric vehicle: it does everything the old car does, but also has turbo mode (async), better fuel efficiency (connection pooling), and supports the latest highways (HTTP/2). Plus, you already know how to drive it!

---

## B. What is httpx?

**httpx** is a fully-featured HTTP client for Python 3 that provides:
- ‚úÖ Sync and async APIs
- ‚úÖ HTTP/1.1 and HTTP/2 support
- ‚úÖ Connection pooling
- ‚úÖ Request/response streaming
- ‚úÖ Automatic decompression
- ‚úÖ Timeout configuration
- ‚úÖ Type annotations throughout
- ‚úÖ Nearly 100% compatible with requests API

**Created by**: Tom Christie (creator of Starlette and Django REST Framework)  
**First Release**: 2019  
**Status**: Actively maintained, production-ready

---

## C. httpx vs requests: Side-by-Side Comparison

| Feature | requests | httpx |
|---------|----------|-------|
| **Sync Support** | ‚úÖ Yes | ‚úÖ Yes |
| **Async Support** | ‚ùå No | ‚úÖ Yes |
| **HTTP/2** | ‚ùå No | ‚úÖ Yes |
| **Connection Pooling** | ‚úÖ Yes (manual) | ‚úÖ Yes (automatic) |
| **Type Hints** | ‚ùå No | ‚úÖ Yes |
| **Active Development** | ‚ö†Ô∏è Minimal | ‚úÖ Active |
| **Performance** | Good | Better |
| **API Similarity** | N/A | ~95% identical |

---

## D. Why httpx is Better for API Testing

### Reason 1: Async Support = Faster Tests

**Problem with requests**:
```python
import requests

# These run one after another (slow!)
response1 = requests.get("https://api.example.com/users/1")  # Wait 1s
response2 = requests.get("https://api.example.com/users/2")  # Wait 1s
response3 = requests.get("https://api.example.com/users/3")  # Wait 1s
# Total time: ~3 seconds
```

**Solution with httpx**:
```python
import httpx
import asyncio

async def test_multiple_users():
    async with httpx.AsyncClient() as client:
        # These run in parallel (fast!)
        responses = await asyncio.gather(
            client.get("https://api.example.com/users/1"),
            client.get("https://api.example.com/users/2"),
            client.get("https://api.example.com/users/3")
        )
    # Total time: ~1 second (3x faster!)
```

**For API Testing**: When you have 100 tests, async can make them 10-50x faster!

---

### Reason 2: HTTP/2 Support

**What is HTTP/2?**
- Next generation of HTTP protocol
- Multiplexing: multiple requests over single connection
- Header compression
- Server push

**Why it matters for testing**:
- Many modern APIs use HTTP/2
- Better performance
- More realistic testing conditions

**httpx automatically uses HTTP/2 when available**:
```python
import httpx

# Automatically negotiates HTTP/2 if server supports it
client = httpx.Client(http2=True)
response = client.get("https://http2.example.com/api")
print(response.http_version)  # "HTTP/2" if supported
```

---

### Reason 3: Better Connection Management

**requests**: Connection pooling exists but requires manual session management
```python
import requests

# ‚ùå Without session - creates new connection each time
requests.get("https://api.example.com/users/1")
requests.get("https://api.example.com/users/2")

# ‚úÖ With session - reuses connection
session = requests.Session()
session.get("https://api.example.com/users/1")
session.get("https://api.example.com/users/2")
session.close()
```

**httpx**: Connection pooling is automatic and better managed
```python
import httpx

# ‚úÖ Automatic connection pooling with context manager
with httpx.Client() as client:
    client.get("https://api.example.com/users/1")
    client.get("https://api.example.com/users/2")
    # Connections automatically cleaned up
```

---

### Reason 4: Modern Python with Type Hints

**requests**: No type hints (harder for IDEs and type checkers)
```python
import requests

response = requests.get("https://api.example.com/users")
# IDE doesn't know what type 'response' is
# Type checkers can't verify correctness
```

**httpx**: Full type hints throughout
```python
import httpx

response: httpx.Response = httpx.get("https://api.example.com/users")
# IDE knows exact type
# Type checkers can verify your code
# Better autocomplete in your editor
```

---

### Reason 5: Active Maintenance

**requests**:
- ‚ö†Ô∏è Maintenance mode (minimal updates)
- Last major release: 2018
- Creator moved on to other projects

**httpx**:
- ‚úÖ Actively developed
- Regular updates and improvements
- Responsive maintainers
- Growing community

**For API Testing**: Using actively maintained tools means:
- Bug fixes
- Security updates
- New features
- Better documentation

---

## E. Code Comparison: requests vs httpx

### Example 1: Simple GET Request

**requests**:
```python
import requests

response = requests.get("https://api.example.com/users/1")
print(response.status_code)
print(response.json())
```

**httpx** (identical!):
```python
import httpx

response = httpx.get("https://api.example.com/users/1")
print(response.status_code)
print(response.json())
```

---

### Example 2: POST Request with JSON

**requests**:
```python
import requests

data = {"name": "John", "email": "john@example.com"}
response = requests.post(
    "https://api.example.com/users",
    json=data
)
print(response.json())
```

**httpx** (identical!):
```python
import httpx

data = {"name": "John", "email": "john@example.com"}
response = httpx.post(
    "https://api.example.com/users",
    json=data
)
print(response.json())
```

---

### Example 3: Headers and Authentication

**requests**:
```python
import requests

headers = {"Authorization": "Bearer token123"}
response = requests.get(
    "https://api.example.com/users/me",
    headers=headers
)
```

**httpx** (identical!):
```python
import httpx

headers = {"Authorization": "Bearer token123"}
response = httpx.get(
    "https://api.example.com/users/me",
    headers=headers
)
```

---

### Example 4: Using a Client (Session)

**requests**:
```python
import requests

session = requests.Session()
session.headers.update({"Authorization": "Bearer token123"})

response1 = session.get("https://api.example.com/users/1")
response2 = session.get("https://api.example.com/users/2")

session.close()
```

**httpx** (very similar with context manager):
```python
import httpx

with httpx.Client(headers={"Authorization": "Bearer token123"}) as client:
    response1 = client.get("https://api.example.com/users/1")
    response2 = client.get("https://api.example.com/users/2")
    # Automatically closes!
```

---

### Example 5: Async Requests (httpx exclusive!)

**requests**: ‚ùå Not possible without workarounds

**httpx**: ‚úÖ Native async support
```python
import httpx
import asyncio

async def fetch_user(user_id: int):
    async with httpx.AsyncClient() as client:
        response = await client.get(f"https://api.example.com/users/{user_id}")
        return response.json()

async def main():
    # Run 3 requests in parallel
    results = await asyncio.gather(
        fetch_user(1),
        fetch_user(2),
        fetch_user(3)
    )
    print(results)

# Run async function
asyncio.run(main())
```

---

## F. Migration Guide: requests ‚Üí httpx

If you know requests, you already know 95% of httpx!

### What Stays the Same

‚úÖ `httpx.get()`, `httpx.post()`, `httpx.put()`, `httpx.delete()`  
‚úÖ `response.status_code`, `response.headers`, `response.json()`  
‚úÖ `json=` parameter for sending JSON  
‚úÖ `headers=` parameter  
‚úÖ `params=` for query parameters  
‚úÖ `timeout=` for request timeout  

### What Changes

| requests | httpx | Notes |
|----------|-------|-------|
| `requests.Session()` | `httpx.Client()` | Use context manager |
| N/A | `httpx.AsyncClient()` | New async capability |
| Manual session close | Automatic with context manager | Cleaner code |

### Quick Migration

**Before (requests)**:
```python
import requests

session = requests.Session()
response = session.get("https://api.example.com/users")
session.close()
```

**After (httpx)**:
```python
import httpx

with httpx.Client() as client:
    response = client.get("https://api.example.com/users")
```

That's it! Just replace `requests` with `httpx` and add context manager.

---

## G. Real-World Performance Comparison

### Scenario: Testing 50 API endpoints

**With requests (synchronous)**:
```python
import requests
import time

start = time.time()

for i in range(50):
    response = requests.get(f"https://api.example.com/users/{i}")
    assert response.status_code == 200

end = time.time()
print(f"Time: {end - start:.2f} seconds")
# Result: ~50 seconds (1 second per request)
```

**With httpx (synchronous - same speed)**:
```python
import httpx
import time

start = time.time()

with httpx.Client() as client:
    for i in range(50):
        response = client.get(f"https://api.example.com/users/{i}")
        assert response.status_code == 200

end = time.time()
print(f"Time: {end - start:.2f} seconds")
# Result: ~50 seconds (same as requests)
```

**With httpx (asynchronous - MUCH faster!)**:
```python
import httpx
import asyncio
import time

async def test_user(client, user_id):
    response = await client.get(f"https://api.example.com/users/{user_id}")
    assert response.status_code == 200

async def main():
    start = time.time()
    
    async with httpx.AsyncClient() as client:
        tasks = [test_user(client, i) for i in range(50)]
        await asyncio.gather(*tasks)
    
    end = time.time()
    print(f"Time: {end - start:.2f} seconds")

asyncio.run(main())
# Result: ~2-5 seconds (10-25x faster!)
```

**Key Insight**: Async httpx doesn't make individual requests faster, but allows running many requests concurrently!

---

## H. When to Use Sync vs Async httpx

### Use Sync httpx When:
- ‚úÖ Testing one endpoint at a time
- ‚úÖ Learning API testing (simpler)
- ‚úÖ Tests don't need to be super fast
- ‚úÖ Sequential operations required (create ‚Üí read ‚Üí update ‚Üí delete)

### Use Async httpx When:
- ‚úÖ Testing many endpoints in parallel
- ‚úÖ Performance matters (CI/CD with many tests)
- ‚úÖ Independent tests that can run concurrently
- ‚úÖ Smoke tests across multiple services

**Good News**: We'll learn BOTH! Start with sync (Project 1), then async (Project 2).

---

## I. httpx Feature Highlights

### Feature 1: Automatic Decompression
```python
import httpx

# Automatically handles gzip, deflate, brotli
response = httpx.get("https://api.example.com/large-data")
# Response is automatically decompressed
```

### Feature 2: Streaming Responses
```python
import httpx

with httpx.stream("GET", "https://api.example.com/large-file") as response:
    for chunk in response.iter_bytes():
        # Process chunk by chunk (memory efficient)
        process(chunk)
```

### Feature 3: Custom Timeout Configuration
```python
import httpx

# Different timeouts for different phases
timeout = httpx.Timeout(
    connect=5.0,    # 5 seconds to establish connection
    read=10.0,      # 10 seconds to read response
    write=5.0,      # 5 seconds to write request
    pool=10.0       # 10 seconds to acquire connection from pool
)

response = httpx.get("https://api.example.com/users", timeout=timeout)
```

### Feature 4: Following Redirects
```python
import httpx

# Follow redirects automatically (default)
response = httpx.get("https://short.url/abc", follow_redirects=True)

# Or don't follow redirects
response = httpx.get("https://short.url/abc", follow_redirects=False)
print(response.status_code)  # 301, 302, etc.
print(response.headers["Location"])  # Where it redirects to
```

---

## J. Common Questions

### Q: Should I switch from requests to httpx?

**For new projects**: ‚úÖ Yes, definitely use httpx  
**For existing projects**: Depends
- If requests works fine ‚Üí no urgent need
- If you need async ‚Üí yes, switch
- If you want modern features ‚Üí yes, switch

**For learning API testing**: ‚úÖ Absolutely yes (future-proof skills)

---

### Q: Is httpx stable for production?

‚úÖ **Yes!** httpx is:
- Battle-tested in production
- Used by major companies
- Thoroughly tested (99%+ code coverage)
- Version 1.0 released (stable API)

---

### Q: Will requests be deprecated?

‚ö†Ô∏è Not officially deprecated, but:
- In maintenance mode (minimal updates)
- Creator recommends httpx for new projects
- Community moving toward httpx

**Bottom line**: requests still works, but httpx is the future.

---

### Q: Do I need to learn async Python first?

‚ùå **No!** You can:
1. Start with sync httpx (identical to requests)
2. Learn async later (Project 2)
3. Use both as needed

Sync httpx alone is already great for API testing!

---

## K. Common Stumbling Blocks

### Mistake 1: Forgetting context manager
**Wrong**:
```python
import httpx

client = httpx.Client()
response = client.get("https://api.example.com/users")
# ‚ö†Ô∏è Forgot to close!
```

**Right**:
```python
import httpx

with httpx.Client() as client:
    response = client.get("https://api.example.com/users")
    # ‚úÖ Automatically closed
```

---

### Mistake 2: Mixing sync and async
**Wrong**:
```python
import httpx

# ‚ùå Can't await sync function!
async def test():
    client = httpx.Client()  # Sync client
    response = await client.get("...")  # ‚ùå Error!
```

**Right**:
```python
import httpx

# ‚úÖ Use AsyncClient for async
async def test():
    async with httpx.AsyncClient() as client:
        response = await client.get("...")  # ‚úÖ Works!
```

---

### Mistake 3: Installing wrong package
**Wrong**:
```bash
pip install http-x  # ‚ùå Wrong package!
```

**Right**:
```bash
pip install httpx  # ‚úÖ Correct
```

---

## L. Installation and Verification

### Install httpx

```bash
pip install httpx
```

### Verify Installation

```python
import httpx

print(httpx.__version__)  # Should print version like "0.27.0"
```

### Install httpx with HTTP/2 support (optional)

```bash
pip install httpx[http2]
```

---

## M. Key Takeaways

üîë **httpx**: Modern HTTP client for Python  
üîë **95% compatible with requests**: Easy to learn if you know requests  
üîë **Async support**: Run tests in parallel (much faster)  
üîë **HTTP/2**: Support for modern protocol  
üîë **Type hints**: Better IDE support and type checking  
üîë **Active development**: Regular updates and improvements  
üîë **Use sync first**: Learn basics, then add async later  
üîë **Context manager**: Always use `with` statement for clients  

---

## N. Quick Comparison Summary

**Use httpx if you want**:
- ‚úÖ Async/parallel testing
- ‚úÖ HTTP/2 support
- ‚úÖ Modern Python with type hints
- ‚úÖ Active maintenance
- ‚úÖ Future-proof skills

**Stick with requests if**:
- ‚ö†Ô∏è Legacy codebase you can't change
- ‚ö†Ô∏è Team isn't ready for new library

**For this course**: We're using httpx! üöÄ

---

## O. What's Next?

In **Lesson 1.7: Installing httpx and Dependencies**, we'll:
- Install httpx properly
- Set up our project dependencies
- Update requirements.txt
- Verify everything works
- Write our first httpx test!

You now understand WHY httpx is the right choice. Let's install it! üéâ

**Ready for lesson 1.7?**
