# Lesson 1.15: JSON Response Parsing

## A. Concept Overview

### What & Why
**JSON parsing** is extracting and navigating data from JSON responses. It's crucial because APIs primarily communicate using JSON, and you need to access nested data, arrays, and objects to validate responses properly.

### Analogy
Think of JSON like a filing cabinet with folders inside folders. Parsing is knowing how to navigate: open the right drawer (top-level key), find the right folder (nested object), and pull out the document you need (specific value).

---

## B. Basic JSON Parsing with httpx

```python
import httpx

response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
data = response.json()  # Parse JSON string to Python dict
```

**What happens**:
- `response.json()` parses JSON string
- Returns Python dict/list
- Raises exception if not valid JSON

---

## C. Accessing Simple Fields

```python
import httpx

response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
data = response.json()

# Direct access
user_id = data["id"]           # 1
name = data["name"]             # "Leanne Graham"
email = data["email"]           # "Sincere@april.biz"

# Safe access (returns None if missing)
middle_name = data.get("middleName")  # None
age = data.get("age", 25)             # 25 (default value)
```

---

## D. Navigating Nested Objects

```python
response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
data = response.json()

# Nested address object
address = data["address"]
street = address["street"]
city = address["city"]
zipcode = address["zipcode"]

# Deep nesting
geo = address["geo"]
lat = geo["lat"]
lng = geo["lng"]

# All in one line (unsafe if keys missing)
lat = data["address"]["geo"]["lat"]

# Safe nested access
lat = data.get("address", {}).get("geo", {}).get("lat")
```

---

## E. Working with Arrays

```python
# Get list of users
response = httpx.get("https://jsonplaceholder.typicode.com/users")
users = response.json()

# Access by index
first_user = users[0]
second_user = users[1]

# Iterate
for user in users:
    print(user["name"])

# List comprehension
names = [user["name"] for user in users]
emails = [user["email"] for user in users]

# Filter
admins = [u for u in users if u.get("role") == "admin"]

# Find specific user
user_5 = next((u for u in users if u["id"] == 5), None)
```

---

## F. Complex Parsing Examples

```python
import httpx

def test_parse_nested_arrays():
    """Parse posts with comments."""
    # Get post
    post_response = httpx.get("https://jsonplaceholder.typicode.com/posts/1")
    post = post_response.json()
    
    # Get comments for post
    comments_response = httpx.get(
        f"https://jsonplaceholder.typicode.com/posts/{post['id']}/comments"
    )
    comments = comments_response.json()
    
    # Parse each comment
    for comment in comments:
        comment_id = comment["id"]
        name = comment["name"]
        email = comment["email"]
        body = comment["body"]
        
        print(f"Comment {comment_id} by {email}: {name}")


def test_parse_mixed_data_types():
    """Parse response with mixed types."""
    data = {
        "id": 1,                    # int
        "name": "John",             # str
        "active": True,             # bool
        "score": 95.5,              # float
        "tags": ["python", "api"],  # list
        "metadata": {"key": "val"}, # dict
        "nullable": None            # None
    }
    
    # Type checking while parsing
    assert isinstance(data["id"], int)
    assert isinstance(data["name"], str)
    assert isinstance(data["active"], bool)
    assert isinstance(data["score"], float)
    assert isinstance(data["tags"], list)
    assert isinstance(data["metadata"], dict)
    assert data["nullable"] is None
```

---

## G. Safe Parsing Patterns

```python
def safe_get_nested(data, *keys, default=None):
    """Safely get nested value."""
    for key in keys:
        if isinstance(data, dict):
            data = data.get(key, {})
        else:
            return default
    return data if data != {} else default


# Usage
data = {"user": {"profile": {"name": "John"}}}

# Safe access
name = safe_get_nested(data, "user", "profile", "name")  # "John"
age = safe_get_nested(data, "user", "profile", "age", default=0)  # 0


def parse_with_validation(response):
    """Parse with validation."""
    # Check status first
    assert response.status_code == 200
    
    # Parse
    try:
        data = response.json()
    except ValueError as e:
        assert False, f"Invalid JSON: {e}"
    
    # Validate structure
    assert isinstance(data, dict), "Expected JSON object"
    
    return data
```

---

## H. Error Handling in Parsing

```python
import httpx
import pytest

def test_parse_invalid_json():
    """Test handling of invalid JSON."""
    # Can't easily test with real API, demonstration:
    # If response.text is "not json":
    # response.json() raises ValueError or JSONDecodeError
    pass


def test_parse_empty_response():
    """Test parsing empty response."""
    response = httpx.get("https://httpbin.org/status/204")
    
    # 204 No Content has empty body
    assert response.status_code == 204
    assert response.text == ""
    
    # Don't try to parse empty response
    if response.text:
        data = response.json()


def test_safe_array_access():
    """Test safe array access."""
    users = []  # Empty array
    
    # Unsafe - raises IndexError
    # first = users[0]
    
    # Safe
    first = users[0] if users else None
    assert first is None
    
    # Or use try/except
    try:
        first = users[0]
    except IndexError:
        first = None
```

---

## I. Key Takeaways

ðŸ”‘ **response.json()**: Parses JSON to Python dict/list  
ðŸ”‘ **dict["key"]**: Direct access (raises KeyError if missing)  
ðŸ”‘ **dict.get("key")**: Safe access (returns None)  
ðŸ”‘ **Nested**: Chain keys or use get() with defaults  
ðŸ”‘ **Arrays**: Access by index, iterate, comprehensions  
ðŸ”‘ **Type check**: Use isinstance() for safety  
ðŸ”‘ **Error handle**: Try/except for invalid JSON  

---

## J. What's Next?

In **Lesson 1.16: Headers and Content Types**, we'll master HTTP headers.

Ready for lesson 1.16? ðŸš€
