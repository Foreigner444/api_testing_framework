# Lesson 1.9: httpx Client Basics

## A. Concept Overview

### What & Why
**httpx.Client** is a reusable HTTP client that manages connections, headers, and configuration across multiple requests. It's important because it provides better performance through connection pooling and makes your code cleaner with shared configuration.

### Analogy
Think of the difference between calling an Uber for every errand (httpx.get()) vs owning a car (httpx.Client()). The car is always ready, knows your preferences, and is more efficient for multiple trips. Similarly, Client maintains connections and settings across requests.

---

## B. Client vs Simple Methods

### Simple Methods (One-off Requests)
```python
import httpx

# Each request creates new connection
response1 = httpx.get("https://api.example.com/users/1")
response2 = httpx.get("https://api.example.com/users/2")
response3 = httpx.get("https://api.example.com/users/3")
# 3 separate connections created and closed
```

**Use when**: Single request, quick test, script

---

### Client (Reusable Session)
```python
import httpx

# One connection pool, reused across requests
with httpx.Client() as client:
    response1 = client.get("https://api.example.com/users/1")
    response2 = client.get("https://api.example.com/users/2")
    response3 = client.get("https://api.example.com/users/3")
# Connection pool automatically cleaned up
```

**Use when**: Multiple requests, production code, test suite

---

## C. Creating and Using a Client

### Basic Client Usage

File: `tests/test_client_basics.py`
```python
"""
Basic httpx.Client usage examples.
"""
import httpx


def test_client_with_context_manager():
    """Test using Client with context manager (recommended)."""
    with httpx.Client() as client:
        response = client.get("https://httpbin.org/get")
        assert response.status_code == 200


def test_client_multiple_requests():
    """Test making multiple requests with same client."""
    with httpx.Client() as client:
        # All requests reuse same connection pool
        response1 = client.get("https://httpbin.org/get")
        response2 = client.post("https://httpbin.org/post", json={"test": "data"})
        response3 = client.get("https://httpbin.org/headers")
        
        assert response1.status_code == 200
        assert response2.status_code == 200
        assert response3.status_code == 200


def test_client_manual_lifecycle():
    """Test manual client lifecycle (not recommended)."""
    # Create client
    client = httpx.Client()
    
    try:
        response = client.get("https://httpbin.org/get")
        assert response.status_code == 200
    finally:
        # Must manually close!
        client.close()
```

**Best Practice**: Always use context manager (`with` statement)

---

## D. Client Configuration

### Base URL

Set base URL once, use relative paths everywhere:

```python
import httpx


def test_client_with_base_url():
    """Test client with base URL."""
    with httpx.Client(base_url="https://httpbin.org") as client:
        # Use relative URLs
        response1 = client.get("/get")
        response2 = client.get("/status/200")
        response3 = client.post("/post", json={"test": "data"})
        
        assert response1.status_code == 200
        assert response2.status_code == 200
        assert response3.status_code == 200
        
        # Verify actual URLs
        assert str(response1.url) == "https://httpbin.org/get"
        assert str(response2.url) == "https://httpbin.org/status/200"
```

**Benefits**:
- âœ… DRY - don't repeat URL
- âœ… Easy to change environments (dev/staging/prod)
- âœ… Cleaner test code

---

### Default Headers

Set headers once for all requests:

```python
import httpx


def test_client_with_default_headers():
    """Test client with default headers."""
    default_headers = {
        "User-Agent": "MyTestSuite/1.0",
        "Accept": "application/json",
        "X-API-Key": "test-key-123"
    }
    
    with httpx.Client(headers=default_headers) as client:
        response = client.get("https://httpbin.org/headers")
        
        assert response.status_code == 200
        data = response.json()
        
        # Verify headers were sent
        assert "MyTestSuite" in data["headers"]["User-Agent"]
        assert "application/json" in data["headers"]["Accept"]
        assert data["headers"]["X-Api-Key"] == "test-key-123"


def test_client_override_headers():
    """Test that per-request headers override defaults."""
    default_headers = {"X-Default": "default-value"}
    
    with httpx.Client(headers=default_headers) as client:
        # Override for this request
        response = client.get(
            "https://httpbin.org/headers",
            headers={"X-Default": "overridden"}
        )
        
        data = response.json()
        assert data["headers"]["X-Default"] == "overridden"
```

---

### Timeouts

Configure timeout behavior:

```python
import httpx


def test_client_with_timeout():
    """Test client with custom timeout."""
    # Set 5 second timeout for all requests
    with httpx.Client(timeout=5.0) as client:
        response = client.get("https://httpbin.org/delay/2")
        assert response.status_code == 200


def test_client_with_detailed_timeout():
    """Test client with granular timeout configuration."""
    timeout = httpx.Timeout(
        connect=5.0,  # Time to establish connection
        read=10.0,    # Time to read response
        write=5.0,    # Time to write request
        pool=5.0      # Time to get connection from pool
    )
    
    with httpx.Client(timeout=timeout) as client:
        response = client.get("https://httpbin.org/get")
        assert response.status_code == 200


def test_client_disable_timeout():
    """Test client with no timeout (wait forever)."""
    with httpx.Client(timeout=None) as client:
        response = client.get("https://httpbin.org/delay/3")
        assert response.status_code == 200
```

**Default timeout**: 5 seconds for all operations

---

## E. Advanced Client Configuration

### Follow Redirects

```python
import httpx


def test_client_follow_redirects():
    """Test that client follows redirects by default."""
    with httpx.Client(follow_redirects=True) as client:
        # httpbin redirects /redirect/1 -> /get
        response = client.get("https://httpbin.org/redirect/1")
        
        assert response.status_code == 200
        # Final URL after redirect
        assert "get" in str(response.url)


def test_client_dont_follow_redirects():
    """Test client with redirects disabled."""
    with httpx.Client(follow_redirects=False) as client:
        response = client.get("https://httpbin.org/redirect/1")
        
        # Gets redirect response, doesn't follow
        assert response.status_code == 302
        assert "Location" in response.headers
```

---

### HTTP/2 Support

```python
import httpx


def test_client_with_http2():
    """Test client with HTTP/2 enabled."""
    with httpx.Client(http2=True) as client:
        response = client.get("https://httpbin.org/get")
        assert response.status_code == 200
        # Server may or may not support HTTP/2
        print(f"HTTP version: {response.http_version}")
```

---

### Max Redirects

```python
import httpx
import pytest


def test_client_max_redirects():
    """Test client respects max redirects limit."""
    # Limit to 2 redirects
    with httpx.Client(follow_redirects=True, max_redirects=2) as client:
        # Try to follow 5 redirects (will fail)
        with pytest.raises(httpx.TooManyRedirects):
            client.get("https://httpbin.org/redirect/5")
```

---

## F. Connection Pooling

Client automatically manages connection pool:

```python
import httpx


def test_connection_pooling():
    """Test that client reuses connections."""
    with httpx.Client() as client:
        # First request - creates connection
        response1 = client.get("https://httpbin.org/get")
        
        # Second request - reuses connection (faster!)
        response2 = client.get("https://httpbin.org/get")
        
        # Third request - still reuses connection
        response3 = client.get("https://httpbin.org/get")
        
        assert response1.status_code == 200
        assert response2.status_code == 200
        assert response3.status_code == 200


def test_pool_limits():
    """Test configuring connection pool limits."""
    limits = httpx.Limits(
        max_keepalive_connections=5,  # Keep 5 connections alive
        max_connections=10,            # Max 10 total connections
        keepalive_expiry=30.0          # Keep connections for 30s
    )
    
    with httpx.Client(limits=limits) as client:
        response = client.get("https://httpbin.org/get")
        assert response.status_code == 200
```

---

## G. Complete Client Example

Here's a production-ready client configuration:

File: `tests/test_production_client.py`
```python
"""
Production-ready httpx.Client configuration.
"""
import httpx


def get_configured_client() -> httpx.Client:
    """Create fully configured client for testing."""
    return httpx.Client(
        base_url="https://httpbin.org",
        headers={
            "User-Agent": "MyAPITests/1.0",
            "Accept": "application/json"
        },
        timeout=httpx.Timeout(
            connect=5.0,
            read=10.0,
            write=5.0,
            pool=5.0
        ),
        follow_redirects=True,
        max_redirects=5,
        http2=True,
        limits=httpx.Limits(
            max_keepalive_connections=10,
            max_connections=20
        )
    )


def test_with_configured_client():
    """Test using fully configured client."""
    with get_configured_client() as client:
        # Test GET
        response = client.get("/get")
        assert response.status_code == 200
        
        # Test POST
        response = client.post("/post", json={"test": "data"})
        assert response.status_code == 200
        
        # Test headers were sent
        response = client.get("/headers")
        data = response.json()
        assert "MyAPITests" in data["headers"]["User-Agent"]
```

---

## H. Client in pytest Fixtures

Best practice: Create client as pytest fixture for reuse:

File: `tests/conftest.py`
```python
"""
Shared pytest fixtures.
"""
import pytest
import httpx


@pytest.fixture
def http_client():
    """Fixture providing configured httpx client."""
    with httpx.Client(
        base_url="https://httpbin.org",
        timeout=10.0
    ) as client:
        yield client


@pytest.fixture
def api_client():
    """Fixture for production API client."""
    with httpx.Client(
        base_url="https://api.example.com",
        headers={"Authorization": "Bearer test-token"},
        timeout=5.0
    ) as client:
        yield client
```

File: `tests/test_with_fixtures.py`
```python
"""
Tests using client fixtures.
"""


def test_with_http_client_fixture(http_client):
    """Test using http_client fixture."""
    response = http_client.get("/get")
    assert response.status_code == 200


def test_multiple_requests_with_fixture(http_client):
    """Test making multiple requests with fixture."""
    response1 = http_client.get("/get")
    response2 = http_client.post("/post", json={"test": "data"})
    
    assert response1.status_code == 200
    assert response2.status_code == 200
```

**Benefits**:
- âœ… Single configuration point
- âœ… Reused across all tests
- âœ… Easy to modify
- âœ… Automatic setup/teardown

---

## I. When to Use Client vs Simple Methods

### Use Simple Methods (`httpx.get()`, etc.) When:
- âœ… Single request in a script
- âœ… Quick one-off test
- âœ… Simple example/demo
- âœ… No need for configuration

```python
# Quick and simple
response = httpx.get("https://api.example.com/health")
assert response.status_code == 200
```

---

### Use Client When:
- âœ… Multiple requests
- âœ… Shared configuration needed
- âœ… Connection pooling beneficial
- âœ… Production code
- âœ… Test suite

```python
# Better for test suites
with httpx.Client(base_url="https://api.example.com") as client:
    client.get("/users/1")
    client.get("/users/2")
    client.post("/users", json={...})
```

---

## J. Common Patterns

### Pattern 1: Client per test
```python
def test_example():
    with httpx.Client() as client:
        response = client.get("...")
        assert response.status_code == 200
```

### Pattern 2: Client as fixture (shared across tests)
```python
@pytest.fixture
def client():
    with httpx.Client() as c:
        yield c

def test_1(client):
    response = client.get("...")

def test_2(client):
    response = client.get("...")
```

### Pattern 3: Client factory function
```python
def create_client(base_url: str) -> httpx.Client:
    return httpx.Client(
        base_url=base_url,
        timeout=5.0
    )

def test_example():
    with create_client("https://api.example.com") as client:
        response = client.get("/endpoint")
```

---

## K. Key Takeaways

ğŸ”‘ **httpx.Client()**: Reusable HTTP client with connection pooling  
ğŸ”‘ **Context manager**: Always use `with` statement  
ğŸ”‘ **base_url**: Set once, use relative URLs  
ğŸ”‘ **headers**: Configure default headers for all requests  
ğŸ”‘ **timeout**: Control request timeout behavior  
ğŸ”‘ **Connection pooling**: Automatic, improves performance  
ğŸ”‘ **pytest fixtures**: Best way to share clients across tests  
ğŸ”‘ **Configuration**: Set once, applies to all requests  

---

## L. What's Next?

In **Lesson 1.10: Testing GET Endpoints**, we'll focus specifically on GET requests:
- Query parameters
- Path parameters
- Response validation
- Testing different scenarios
- Real-world examples

You now understand httpx.Client! Time to master GET testing. ğŸš€

**Ready for lesson 1.10?**
