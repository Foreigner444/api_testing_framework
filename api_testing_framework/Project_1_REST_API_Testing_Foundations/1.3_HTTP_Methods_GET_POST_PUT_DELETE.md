# Lesson 1.3: HTTP Methods (GET, POST, PUT, DELETE)

## A. Concept Overview

### What & Why
**HTTP Methods** (also called HTTP Verbs) define the type of action you want to perform on a resource. They're important because they tell the API what you want to do‚Äîread data, create something new, update existing data, or delete it.

### Analogy
Think of HTTP methods like actions you perform in a file manager:
- **GET** = Opening a file to read it (doesn't change anything)
- **POST** = Creating a new file in a folder
- **PUT** = Replacing an entire file with a new version
- **PATCH** = Editing part of a file (fixing a typo)
- **DELETE** = Moving a file to trash

Just like you wouldn't use "create new file" to read a file, you shouldn't use POST when you mean GET!

---

## B. The Five Main HTTP Methods

| Method | Purpose | Has Body? | Safe? | Idempotent? |
|--------|---------|-----------|-------|-------------|
| GET | Retrieve data | No | ‚úÖ Yes | ‚úÖ Yes |
| POST | Create new resource | Yes | ‚ùå No | ‚ùå No |
| PUT | Replace entire resource | Yes | ‚ùå No | ‚úÖ Yes |
| PATCH | Partially update resource | Yes | ‚ùå No | ‚úÖ Yes |
| DELETE | Remove resource | No | ‚ùå No | ‚úÖ Yes |

**Key Terms**:
- **Safe**: Operation doesn't modify data on the server
- **Idempotent**: Making the same request multiple times produces the same result
- **Has Body**: Can send data in the request

---

## C. GET - Retrieve Data

### What It Does
GET retrieves information from the server without modifying anything.

### Characteristics
- ‚úÖ **Safe**: Doesn't change server state
- ‚úÖ **Idempotent**: Same result every time
- ‚ùå **No request body**: Data passed via URL parameters
- ‚úÖ **Cacheable**: Responses can be cached

### Use Cases
1. Get a list of resources
2. Get a specific resource by ID
3. Search or filter resources
4. Get related resources

### Examples

**Example 1: Get all users**
```http
GET /api/users HTTP/1.1
Host: example.com
```

**Response** (200 OK):
```json
{
  "data": [
    {"id": 1, "name": "John", "email": "john@example.com"},
    {"id": 2, "name": "Jane", "email": "jane@example.com"}
  ],
  "total": 2
}
```

**Example 2: Get specific user**
```http
GET /api/users/1 HTTP/1.1
Host: example.com
```

**Response** (200 OK):
```json
{
  "id": 1,
  "name": "John",
  "email": "john@example.com",
  "created_at": "2024-01-15T10:30:00Z"
}
```

**Example 3: Get with query parameters (filtering)**
```http
GET /api/users?status=active&role=admin HTTP/1.1
Host: example.com
```

**Response** (200 OK):
```json
{
  "data": [
    {"id": 5, "name": "Admin User", "status": "active", "role": "admin"}
  ],
  "total": 1
}
```

**Example 4: Resource not found**
```http
GET /api/users/9999 HTTP/1.1
Host: example.com
```

**Response** (404 Not Found):
```json
{
  "error": "User not found",
  "code": "USER_NOT_FOUND"
}
```

### What to Test for GET

‚úÖ **Status code 200** for successful requests  
‚úÖ **Status code 404** when resource doesn't exist  
‚úÖ **Response contains expected fields**  
‚úÖ **Data types are correct** (strings, numbers, booleans)  
‚úÖ **Arrays contain expected number of items**  
‚úÖ **Query parameters filter correctly**  
‚úÖ **Pagination works** (if applicable)  
‚úÖ **Response time is acceptable**  

---

## D. POST - Create New Resource

### What It Does
POST creates a new resource on the server.

### Characteristics
- ‚ùå **Not safe**: Modifies server state (creates data)
- ‚ùå **Not idempotent**: Each call creates a new resource
- ‚úÖ **Has request body**: Sends data to create resource
- ‚ùå **Not cacheable**: Each request is unique

### Use Cases
1. Create a new user
2. Submit a form
3. Upload a file
4. Place an order
5. Register/login

### Examples

**Example 1: Create new user**
```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Alice Smith",
  "email": "alice@example.com",
  "password": "securepass123"
}
```

**Response** (201 Created):
```json
{
  "id": 3,
  "name": "Alice Smith",
  "email": "alice@example.com",
  "created_at": "2024-01-15T11:00:00Z"
}
```

**Example 2: Create with validation error**
```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Bob",
  "email": "invalid-email"
}
```

**Response** (400 Bad Request):
```json
{
  "error": "Validation failed",
  "details": {
    "email": "Must be a valid email address",
    "password": "Password is required"
  }
}
```

**Example 3: Create duplicate resource**
```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John",
  "email": "john@example.com"  // Email already exists
}
```

**Response** (409 Conflict):
```json
{
  "error": "User with this email already exists",
  "code": "DUPLICATE_EMAIL"
}
```

### What to Test for POST

‚úÖ **Status code 201** when resource created successfully  
‚úÖ **Status code 400** for validation errors  
‚úÖ **Status code 409** for duplicates  
‚úÖ **Response includes new resource with ID**  
‚úÖ **Required fields are validated**  
‚úÖ **Optional fields work correctly**  
‚úÖ **Data is actually created** (verify with GET)  
‚úÖ **Response contains `Location` header** (optional but best practice)  

---

## E. PUT - Replace Entire Resource

### What It Does
PUT completely replaces an existing resource with new data.

### Characteristics
- ‚ùå **Not safe**: Modifies server state
- ‚úÖ **Idempotent**: Same request = same result
- ‚úÖ **Has request body**: Complete resource data
- ‚ùå **Not cacheable**

### Use Cases
1. Replace entire user profile
2. Update complete configuration
3. Replace document contents

### Important Note
PUT replaces the **entire** resource. Any fields not included will be removed or set to default values.

### Examples

**Example 1: Update user (replace all fields)**
```http
PUT /api/users/1 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "id": 1,
  "name": "John Updated",
  "email": "john.new@example.com",
  "phone": "+1234567890",
  "status": "active"
}
```

**Response** (200 OK):
```json
{
  "id": 1,
  "name": "John Updated",
  "email": "john.new@example.com",
  "phone": "+1234567890",
  "status": "active",
  "updated_at": "2024-01-15T12:00:00Z"
}
```

**Example 2: PUT with missing fields (they get removed!)**
```http
PUT /api/users/1 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "id": 1,
  "name": "John"
  // Notice: email, phone, status are missing!
}
```

**Response** (200 OK):
```json
{
  "id": 1,
  "name": "John",
  "email": null,        // ‚ö†Ô∏è Got removed!
  "phone": null,        // ‚ö†Ô∏è Got removed!
  "status": "inactive", // ‚ö†Ô∏è Set to default!
  "updated_at": "2024-01-15T12:05:00Z"
}
```

**Example 3: PUT to non-existent resource**
```http
PUT /api/users/9999 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "id": 9999,
  "name": "New User"
}
```

**Response** (404 Not Found):
```json
{
  "error": "User not found",
  "code": "USER_NOT_FOUND"
}
```

### What to Test for PUT

‚úÖ **Status code 200** for successful update  
‚úÖ **Status code 404** if resource doesn't exist  
‚úÖ **Status code 400** for validation errors  
‚úÖ **All fields are replaced**  
‚úÖ **Missing fields are removed/defaulted**  
‚úÖ **Idempotency**: Multiple identical requests = same result  
‚úÖ **Updated data persists** (verify with GET)  

---

## F. PATCH - Partially Update Resource

### What It Does
PATCH updates only specific fields of a resource, leaving others unchanged.

### Characteristics
- ‚ùå **Not safe**: Modifies server state
- ‚úÖ **Idempotent**: Same request = same result
- ‚úÖ **Has request body**: Only fields to update
- ‚ùå **Not cacheable**

### Use Cases
1. Update user email only
2. Change product price
3. Update status field
4. Modify single attribute

### PUT vs PATCH

**PUT** = Replace the entire thing  
**PATCH** = Change just what you specify  

### Examples

**Example 1: Update only email**
```http
PATCH /api/users/1 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "email": "newemail@example.com"
}
```

**Response** (200 OK):
```json
{
  "id": 1,
  "name": "John",              // ‚úÖ Unchanged
  "email": "newemail@example.com",  // ‚úÖ Updated
  "phone": "+1234567890",      // ‚úÖ Unchanged
  "status": "active",          // ‚úÖ Unchanged
  "updated_at": "2024-01-15T13:00:00Z"
}
```

**Example 2: Update multiple fields**
```http
PATCH /api/users/1 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "John Smith",
  "status": "inactive"
}
```

**Response** (200 OK):
```json
{
  "id": 1,
  "name": "John Smith",        // ‚úÖ Updated
  "email": "newemail@example.com",  // ‚úÖ Unchanged
  "phone": "+1234567890",      // ‚úÖ Unchanged
  "status": "inactive",        // ‚úÖ Updated
  "updated_at": "2024-01-15T13:05:00Z"
}
```

**Example 3: PATCH with validation error**
```http
PATCH /api/users/1 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "email": "invalid-email-format"
}
```

**Response** (400 Bad Request):
```json
{
  "error": "Validation failed",
  "details": {
    "email": "Must be a valid email address"
  }
}
```

### What to Test for PATCH

‚úÖ **Status code 200** for successful update  
‚úÖ **Status code 404** if resource doesn't exist  
‚úÖ **Status code 400** for validation errors  
‚úÖ **Only specified fields are updated**  
‚úÖ **Other fields remain unchanged**  
‚úÖ **Multiple fields can be updated together**  
‚úÖ **Idempotency**: Same request = same result  
‚úÖ **Updated data persists** (verify with GET)  

---

## G. DELETE - Remove Resource

### What It Does
DELETE removes a resource from the server.

### Characteristics
- ‚ùå **Not safe**: Modifies server state (removes data)
- ‚úÖ **Idempotent**: Deleting twice = same result (it's gone)
- ‚ùå **No request body**: Resource ID in URL
- ‚ùå **Not cacheable**

### Use Cases
1. Delete user account
2. Remove product from catalog
3. Cancel order
4. Remove comment

### Examples

**Example 1: Successful deletion**
```http
DELETE /api/users/1 HTTP/1.1
Host: example.com
```

**Response** (204 No Content):
```
(No body - successful deletion)
```

**Alternative Response** (200 OK with confirmation):
```json
{
  "message": "User deleted successfully",
  "deleted_id": 1
}
```

**Example 2: Delete non-existent resource**
```http
DELETE /api/users/9999 HTTP/1.1
Host: example.com
```

**Response** (404 Not Found):
```json
{
  "error": "User not found",
  "code": "USER_NOT_FOUND"
}
```

**Example 3: Idempotent behavior (delete twice)**
```http
// First request
DELETE /api/users/1 HTTP/1.1
‚Üí 204 No Content (deleted)

// Second request (same resource)
DELETE /api/users/1 HTTP/1.1
‚Üí 404 Not Found (already gone) OR 204 No Content (idempotent design)
```

**Example 4: Delete with dependencies**
```http
DELETE /api/users/1 HTTP/1.1
Host: example.com
```

**Response** (409 Conflict):
```json
{
  "error": "Cannot delete user with active orders",
  "code": "USER_HAS_DEPENDENCIES",
  "details": {
    "active_orders": 3
  }
}
```

### What to Test for DELETE

‚úÖ **Status code 204** (No Content) or **200** (with body)  
‚úÖ **Status code 404** if resource doesn't exist  
‚úÖ **Status code 409** if deletion blocked (dependencies)  
‚úÖ **Resource is actually deleted** (GET returns 404)  
‚úÖ **Idempotency**: Deleting twice doesn't cause errors  
‚úÖ **Related data handled correctly** (cascade or prevent)  
‚úÖ **Soft delete vs hard delete** (if applicable)  

---

## H. Comparison Table

| Aspect | GET | POST | PUT | PATCH | DELETE |
|--------|-----|------|-----|-------|--------|
| **Purpose** | Read | Create | Replace | Update | Remove |
| **Request Body** | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No |
| **Safe** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No |
| **Idempotent** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| **Success Code** | 200 | 201 | 200 | 200 | 204/200 |
| **Cacheable** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No |

---

## I. Real-World Workflow Example

Let's follow a complete user management workflow:

### 1. Create User (POST)
```http
POST /api/users
Body: {"name": "Alice", "email": "alice@example.com"}
‚Üí 201 Created: {"id": 5, "name": "Alice", "email": "alice@example.com"}
```

### 2. Get User (GET)
```http
GET /api/users/5
‚Üí 200 OK: {"id": 5, "name": "Alice", "email": "alice@example.com"}
```

### 3. Update Email (PATCH)
```http
PATCH /api/users/5
Body: {"email": "alice.new@example.com"}
‚Üí 200 OK: {"id": 5, "name": "Alice", "email": "alice.new@example.com"}
```

### 4. Replace User (PUT)
```http
PUT /api/users/5
Body: {"id": 5, "name": "Alice Smith", "email": "alice.smith@example.com", "phone": "123"}
‚Üí 200 OK: {"id": 5, "name": "Alice Smith", "email": "alice.smith@example.com", "phone": "123"}
```

### 5. Delete User (DELETE)
```http
DELETE /api/users/5
‚Üí 204 No Content
```

### 6. Verify Deletion (GET)
```http
GET /api/users/5
‚Üí 404 Not Found
```

---

## J. Common Stumbling Blocks

### Mistake 1: Confusing PUT and PATCH
**Wrong Thinking**: "They both update, so they're the same"  
**Reality**: 
- PUT = Replace everything (missing fields get removed)
- PATCH = Update only what you send (other fields stay)

**Example**:
```json
Current user: {"id": 1, "name": "John", "email": "john@example.com"}

PUT with {"name": "Jane"}
‚Üí Result: {"id": 1, "name": "Jane", "email": null}  // ‚ö†Ô∏è Email lost!

PATCH with {"name": "Jane"}
‚Üí Result: {"id": 1, "name": "Jane", "email": "john@example.com"}  // ‚úÖ Email kept!
```

### Mistake 2: Using GET with Request Body
**Wrong**:
```http
GET /api/users HTTP/1.1
Body: {"filter": "active"}  // ‚ùå GET shouldn't have body
```

**Right**:
```http
GET /api/users?filter=active HTTP/1.1  // ‚úÖ Use query parameters
```

### Mistake 3: Expecting Same Status Codes for All Methods
**Reality**: Different methods have different success codes:
- GET ‚Üí 200 OK
- POST ‚Üí 201 Created
- PUT/PATCH ‚Üí 200 OK
- DELETE ‚Üí 204 No Content (or 200 OK)

### Mistake 4: Not Understanding Idempotency
**POST is NOT idempotent**:
```http
POST /api/users (Body: {"name": "John"})  ‚Üí Creates user ID 1
POST /api/users (Body: {"name": "John"})  ‚Üí Creates user ID 2 ‚ö†Ô∏è
POST /api/users (Body: {"name": "John"})  ‚Üí Creates user ID 3 ‚ö†Ô∏è
```

**PUT IS idempotent**:
```http
PUT /api/users/1 (Body: {"name": "John"})  ‚Üí Updates user 1
PUT /api/users/1 (Body: {"name": "John"})  ‚Üí Updates user 1 (same result) ‚úÖ
PUT /api/users/1 (Body: {"name": "John"})  ‚Üí Updates user 1 (same result) ‚úÖ
```

---

## K. Key Takeaways

üîë **GET**: Read data (safe, idempotent, no body)  
üîë **POST**: Create new (not safe, not idempotent, has body)  
üîë **PUT**: Replace all (not safe, idempotent, has body)  
üîë **PATCH**: Update partial (not safe, idempotent, has body)  
üîë **DELETE**: Remove (not safe, idempotent, no body)  
üîë **Idempotent**: Multiple identical requests = same result  
üîë **Safe**: Doesn't modify server data  

---

## L. Quick Check

Can you answer these?

1. Which method would you use to get a list of products?
2. Which method creates a new order?
3. What's the difference between PUT and PATCH?
4. Is DELETE idempotent? Why?
5. Which method should never have a request body?

---

## M. What's Next?

In **Lesson 1.4: Status Codes and Responses**, we'll learn what those numbers (200, 404, 500) mean, why they matter, and what status code to expect for each scenario.

You're making great progress! üéâ

**Ready for lesson 1.4?**
