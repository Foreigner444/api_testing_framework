# Lesson 1.19: Best Practices for REST API Tests

## ðŸŽ‰ Final Lesson - Project 1 Complete!

Congratulations! You've made it to the final lesson of Project 1. Let's consolidate everything you've learned with industry best practices.

---

## A. Test Organization

### File Structure
```
tests/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py              # Shared fixtures
â”œâ”€â”€ test_users.py            # User endpoint tests
â”œâ”€â”€ test_posts.py            # Post endpoint tests
â”œâ”€â”€ test_authentication.py   # Auth tests
â””â”€â”€ helpers/
    â”œâ”€â”€ __init__.py
    â””â”€â”€ validators.py        # Validation helpers
```

### Naming Conventions
```python
# âœ… Good test names
def test_get_user_by_id_returns_200()
def test_create_user_with_valid_data_returns_201()
def test_delete_nonexistent_user_returns_404()

# âŒ Bad test names
def test_user()
def test_1()
def test()
```

---

## B. Fixture Usage

```python
# conftest.py
import pytest
import httpx

@pytest.fixture
def api_client():
    """Reusable API client fixture."""
    with httpx.Client(
        base_url="https://jsonplaceholder.typicode.com",
        timeout=10.0
    ) as client:
        yield client


# test_users.py
def test_get_user(api_client):
    """Test using fixture."""
    response = api_client.get("/users/1")
    assert response.status_code == 200
```

---

## C. Test Independence

```python
# âœ… Good - each test is independent
def test_create_user():
    # Create user
    # Verify
    # Clean up
    pass

def test_get_user():
    # Create test data
    # Get user
    # Verify
    # Clean up
    pass

# âŒ Bad - tests depend on each other
def test_1_create_user():
    # Creates user ID 123
    pass

def test_2_get_user():
    # Assumes user 123 exists from test_1
    pass
```

---

## D. Clear Assertions

```python
# âœ… Good - clear assertions with messages
def test_user_email():
    response = httpx.get("https://api.example.com/users/1")
    data = response.json()
    
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"
    assert "email" in data, "Email field missing from response"
    assert "@" in data["email"], f"Invalid email format: {data['email']}"

# âŒ Bad - unclear failures
def test_user_email():
    response = httpx.get("https://api.example.com/users/1")
    data = response.json()
    assert "@" in data["email"]  # Which test failed? Why?
```

---

## E. DRY Principle

```python
# âœ… Good - reusable validation
def validate_user_response(data):
    """Reusable user validation."""
    assert "id" in data
    assert "name" in data
    assert "email" in data
    assert isinstance(data["id"], int)
    assert "@" in data["email"]

def test_get_user():
    response = httpx.get("https://api.example.com/users/1")
    data = response.json()
    validate_user_response(data)

def test_create_user():
    response = httpx.post("https://api.example.com/users", json={...})
    data = response.json()
    validate_user_response(data)
```

---

## F. Error Handling

```python
# âœ… Good - explicit error testing
import pytest
import httpx

def test_timeout_handling():
    """Test timeout is handled properly."""
    with pytest.raises(httpx.TimeoutException):
        httpx.get("https://httpbin.org/delay/10", timeout=1.0)

def test_invalid_json_handling():
    """Test invalid JSON handling."""
    # Would need mock or special endpoint
    pass
```

---

## G. Test Data Management

```python
# âœ… Good - test data as constants or fixtures
TEST_USER = {
    "name": "Test User",
    "email": "test@example.com",
    "username": "testuser"
}

def test_create_user():
    response = httpx.post(
        "https://api.example.com/users",
        json=TEST_USER
    )
    assert response.status_code == 201
```

---

## H. Documentation

```python
def test_get_user_by_id():
    """
    Test GET /users/{id} endpoint.
    
    Verifies:
    - Returns 200 OK for valid user ID
    - Response contains all required fields
    - Data types are correct
    - Email format is valid
    """
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
    # ... rest of test
```

---

## I. Complete Example

```python
"""
Complete example following all best practices.
"""
import pytest
import httpx

# Constants
BASE_URL = "https://jsonplaceholder.typicode.com"

# Fixtures
@pytest.fixture
def api_client():
    """Configured API client."""
    with httpx.Client(
        base_url=BASE_URL,
        timeout=10.0,
        headers={"Accept": "application/json"}
    ) as client:
        yield client

# Helper functions
def validate_user(data):
    """Validate user response structure."""
    required_fields = ["id", "name", "username", "email"]
    for field in required_fields:
        assert field in data, f"Missing field: {field}"
    
    assert isinstance(data["id"], int)
    assert len(data["name"]) > 0
    assert "@" in data["email"]

# Tests
def test_get_user_returns_valid_structure(api_client):
    """
    Test GET /users/{id} returns valid user structure.
    
    Verifies all required fields are present with correct types.
    """
    response = api_client.get("/users/1")
    
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"
    
    data = response.json()
    validate_user(data)
    assert data["id"] == 1, "User ID should match requested ID"


def test_get_nonexistent_user_returns_404(api_client):
    """
    Test GET /users/{id} returns 404 for non-existent user.
    """
    response = api_client.get("/users/99999")
    
    assert response.status_code == 404, "Non-existent user should return 404"
```

---

## J. CI/CD Readiness

```python
# pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_functions = test_*
addopts = 
    -v
    --tb=short
    -ra
```

```yaml
# .github/workflows/tests.yml
name: API Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: '3.10'
      - run: pip install -r requirements.txt
      - run: pytest tests/ -v
```

---

## K. Key Takeaways - Project 1 Complete! ðŸŽ‰

ðŸ”‘ **Organization**: Clear structure, good naming  
ðŸ”‘ **Fixtures**: Reuse setup code  
ðŸ”‘ **Independence**: Tests don't depend on each other  
ðŸ”‘ **Assertions**: Clear, with helpful messages  
ðŸ”‘ **DRY**: Don't repeat yourself  
ðŸ”‘ **Documentation**: Docstrings for complex tests  
ðŸ”‘ **Error handling**: Test both success and failure  
ðŸ”‘ **CI/CD ready**: Works in automation pipelines  

---

## L. Project 1 Skills Checklist

You now master:

âœ… REST API fundamentals  
âœ… HTTP methods (GET, POST, PUT, PATCH, DELETE)  
âœ… Status codes (2xx, 3xx, 4xx, 5xx)  
âœ… pytest testing framework  
âœ… httpx modern HTTP client  
âœ… httpx.Client with connection pooling  
âœ… Response validation techniques  
âœ… JSON parsing and navigation  
âœ… Headers and Content-Types  
âœ… Query and path parameters  
âœ… Timeout configuration  
âœ… Industry best practices  

---

## M. What's Next? ðŸš€

### Project 2: Async API Testing with httpx
- AsyncClient for parallel execution
- pytest-asyncio integration
- Performance optimization
- 10-50x faster test suites!

### Project 3: Pydantic Models & Schema Validation
- Type-safe testing
- Automatic validation
- Schema generation

### Projects 4-9: Advanced Topics
- Test data with Faker
- Multi-environment configuration
- Authentication testing
- Production frameworks
- Allure reporting
- CI/CD deployment

---

## N. Congratulations! ðŸŽŠ

**You've completed Project 1: REST API Testing Foundations!**

You started knowing nothing about API testing. Now you can:
- Write comprehensive API tests
- Validate responses properly
- Follow industry best practices
- Build maintainable test suites

This is a HUGE accomplishment! You're now ready for advanced topics in Projects 2-9.

**Take a moment to celebrate your achievement!** ðŸŽ‰

---

## O. Final Challenge

Before moving to Project 2, try this:

**Build a complete test suite for a public API:**
1. Choose an API (JSONPlaceholder, httpbin, or any public API)
2. Write tests for all endpoints
3. Use all techniques from Project 1
4. Follow best practices
5. Run tests and get 100% pass rate!

You've got the skills. Now apply them!

---

## P. Keep Learning!

Ready for **Project 2: Async API Testing**?

Let's make your tests 10x faster! ðŸš€
