# Lesson 1.14: Response Validation Basics

## A. Concept Overview

### What & Why
**Response validation** is the process of verifying that API responses meet expected criteriaâ€”correct status codes, proper headers, valid data structure, and accurate content. It's important because validation ensures the API behaves correctly and catches bugs early before they reach production.

### Analogy
Think of response validation like quality control at a factory. You don't just check if the product existsâ€”you verify: it's the right size (status code), properly packaged (headers), has all required parts (required fields), everything is the correct type (data types), and values are within acceptable ranges (business rules). One missing check could mean defective products reach customers!

---

## B. Why Validation Matters

### The Problem Without Validation

```python
# âŒ Bad - Only checking status code
def test_get_user():
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
    # What if response is empty?
    # What if fields are missing?
    # What if data types are wrong?
```

### The Solution With Comprehensive Validation

```python
# âœ… Good - Comprehensive validation
def test_get_user():
    response = httpx.get("https://api.example.com/users/1")
    
    # Status code
    assert response.status_code == 200
    
    # Headers
    assert "application/json" in response.headers["content-type"]
    
    # Response structure
    data = response.json()
    assert isinstance(data, dict)
    
    # Required fields
    assert "id" in data
    assert "name" in data
    assert "email" in data
    
    # Data types
    assert isinstance(data["id"], int)
    assert isinstance(data["name"], str)
    
    # Value validation
    assert data["id"] > 0
    assert "@" in data["email"]
    assert len(data["name"]) > 0
```

---

## C. Status Code Validation

### Basic Status Code Checks

File: `tests/test_status_validation.py`
```python
"""
Test status code validation patterns.
"""
import httpx


def test_success_status_codes():
    """Test various success status codes."""
    with httpx.Client(base_url="https://httpbin.org") as client:
        # 200 OK
        response = client.get("/get")
        assert response.status_code == 200
        
        # 201 Created (simulated)
        response = client.get("/status/201")
        assert response.status_code == 201
        
        # 204 No Content
        response = client.get("/status/204")
        assert response.status_code == 204


def test_client_error_status_codes():
    """Test client error status codes."""
    with httpx.Client(base_url="https://httpbin.org") as client:
        # 400 Bad Request
        response = client.get("/status/400")
        assert response.status_code == 400
        
        # 401 Unauthorized
        response = client.get("/status/401")
        assert response.status_code == 401
        
        # 403 Forbidden
        response = client.get("/status/403")
        assert response.status_code == 403
        
        # 404 Not Found
        response = client.get("/status/404")
        assert response.status_code == 404


def test_server_error_status_codes():
    """Test server error status codes."""
    with httpx.Client(base_url="https://httpbin.org") as client:
        # 500 Internal Server Error
        response = client.get("/status/500")
        assert response.status_code == 500
        
        # 503 Service Unavailable
        response = client.get("/status/503")
        assert response.status_code == 503


def test_status_code_helpers():
    """Test httpx status code helper properties."""
    response = httpx.get("https://httpbin.org/get")
    
    # Helper properties
    assert response.is_success  # 2xx status codes
    assert not response.is_error  # Not 4xx or 5xx
    assert not response.is_redirect  # Not 3xx
    assert not response.is_client_error  # Not 4xx
    assert not response.is_server_error  # Not 5xx


def test_status_code_ranges():
    """Test validating status code ranges."""
    response = httpx.get("https://httpbin.org/get")
    
    # Check if in success range
    assert 200 <= response.status_code < 300
    
    # Alternative: use helpers
    assert response.is_success
```

---

## D. Header Validation

### Required Headers

File: `tests/test_header_validation.py`
```python
"""
Test response header validation.
"""
import httpx


def test_content_type_header():
    """Test Content-Type header validation."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users")
    
    # Check header exists
    assert "content-type" in response.headers
    
    # Check value (case-insensitive)
    content_type = response.headers["content-type"]
    assert "application/json" in content_type


def test_common_headers_present():
    """Test that common headers are present."""
    response = httpx.get("https://httpbin.org/get")
    
    # Standard headers
    assert "content-type" in response.headers
    assert "content-length" in response.headers
    assert "date" in response.headers
    assert "server" in response.headers


def test_header_values():
    """Test specific header values."""
    response = httpx.get("https://httpbin.org/response-headers", params={
        "X-Custom-Header": "test-value"
    })
    
    data = response.json()
    # httpbin echoes back custom headers
    assert "X-Custom-Header" in data


def test_cache_headers():
    """Test cache-related headers."""
    response = httpx.get("https://httpbin.org/cache")
    
    # Check cache headers
    if "cache-control" in response.headers:
        assert response.headers["cache-control"]
    
    # Check ETag if present
    if "etag" in response.headers:
        assert len(response.headers["etag"]) > 0


def test_security_headers():
    """Test security headers."""
    response = httpx.get("https://httpbin.org/get")
    
    # These headers might be present (depends on server config)
    # Just demonstrating how to check them
    security_headers = [
        "strict-transport-security",
        "x-content-type-options",
        "x-frame-options",
        "x-xss-protection"
    ]
    
    for header in security_headers:
        if header in response.headers:
            print(f"{header}: {response.headers[header]}")
```

---

## E. Response Body Structure Validation

### Validating Data Types

File: `tests/test_structure_validation.py`
```python
"""
Test response body structure validation.
"""
import httpx


def test_response_is_json_object():
    """Test that response is a JSON object (dict)."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    
    data = response.json()
    assert isinstance(data, dict)


def test_response_is_json_array():
    """Test that response is a JSON array (list)."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users")
    
    data = response.json()
    assert isinstance(data, list)
    assert len(data) > 0


def test_field_data_types():
    """Test that fields have correct data types."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    # Integer fields
    assert isinstance(data["id"], int)
    
    # String fields
    assert isinstance(data["name"], str)
    assert isinstance(data["username"], str)
    assert isinstance(data["email"], str)
    assert isinstance(data["phone"], str)
    assert isinstance(data["website"], str)
    
    # Nested object
    assert isinstance(data["address"], dict)
    assert isinstance(data["company"], dict)


def test_nested_structure():
    """Test nested object structure."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    # Address structure
    address = data["address"]
    assert isinstance(address["street"], str)
    assert isinstance(address["suite"], str)
    assert isinstance(address["city"], str)
    assert isinstance(address["zipcode"], str)
    
    # Nested geo object
    assert isinstance(address["geo"], dict)
    assert isinstance(address["geo"]["lat"], str)
    assert isinstance(address["geo"]["lng"], str)


def test_array_elements_structure():
    """Test that array elements have consistent structure."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users")
    data = response.json()
    
    # All users should have same structure
    required_fields = ["id", "name", "username", "email"]
    
    for user in data:
        assert isinstance(user, dict)
        for field in required_fields:
            assert field in user
```

---

## F. Required Fields Validation

File: `tests/test_required_fields.py`
```python
"""
Test required fields validation.
"""
import httpx


def test_all_required_fields_present():
    """Test that all required fields are present."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    required_fields = [
        "id",
        "name",
        "username",
        "email",
        "address",
        "phone",
        "website",
        "company"
    ]
    
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"


def test_nested_required_fields():
    """Test required fields in nested objects."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    # Address required fields
    address_fields = ["street", "suite", "city", "zipcode", "geo"]
    for field in address_fields:
        assert field in data["address"], f"Missing address field: {field}"
    
    # Company required fields
    company_fields = ["name", "catchPhrase", "bs"]
    for field in company_fields:
        assert field in data["company"], f"Missing company field: {field}"


def test_optional_fields():
    """Test handling of optional fields."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    # Optional fields - check if present, validate if they exist
    optional_fields = {
        "middleName": str,
        "age": int,
        "avatar": str
    }
    
    for field, expected_type in optional_fields.items():
        if field in data:
            # If present, should be correct type
            assert isinstance(data[field], expected_type)


def test_required_field_not_null():
    """Test that required fields are not null."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    # These fields should never be null
    critical_fields = ["id", "name", "email"]
    
    for field in critical_fields:
        assert data[field] is not None, f"Field {field} should not be null"
        
        # String fields should not be empty
        if isinstance(data[field], str):
            assert len(data[field]) > 0, f"Field {field} should not be empty"
```

---

## G. Value Validation

File: `tests/test_value_validation.py`
```python
"""
Test field value validation.
"""
import httpx
import re


def test_id_is_positive():
    """Test that ID fields are positive integers."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    assert data["id"] > 0


def test_email_format():
    """Test that email has valid format."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    email = data["email"]
    
    # Simple validation
    assert "@" in email
    assert "." in email
    
    # Regex validation
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    assert re.match(email_pattern, email), f"Invalid email format: {email}"


def test_string_length_constraints():
    """Test string length constraints."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    # Name should not be empty
    assert len(data["name"]) > 0
    
    # Name should not be too long
    assert len(data["name"]) <= 100
    
    # Username constraints
    assert 3 <= len(data["username"]) <= 50


def test_numeric_ranges():
    """Test numeric value ranges."""
    response = httpx.get("https://jsonplaceholder.typicode.com/posts/1")
    data = response.json()
    
    # User ID should be reasonable
    assert 1 <= data["userId"] <= 10000
    
    # Post ID should be positive
    assert data["id"] > 0


def test_boolean_values():
    """Test boolean field validation."""
    response = httpx.get("https://jsonplaceholder.typicode.com/todos/1")
    data = response.json()
    
    # completed should be boolean
    assert isinstance(data["completed"], bool)
    
    # Should be explicitly True or False
    assert data["completed"] in [True, False]


def test_enum_values():
    """Test that fields have expected enum values."""
    # Example: status should be one of specific values
    # Using httpbin for demonstration
    response = httpx.get("https://httpbin.org/get")
    data = response.json()
    
    # URL should start with http:// or https://
    url = data["url"]
    assert url.startswith("http://") or url.startswith("https://")


def test_date_format():
    """Test date format validation."""
    # Demonstration with ISO 8601 format
    import datetime
    
    # Mock date string
    date_string = "2024-01-15T10:30:00Z"
    
    # Validate ISO 8601 format
    try:
        datetime.datetime.fromisoformat(date_string.replace('Z', '+00:00'))
        assert True
    except ValueError:
        assert False, f"Invalid date format: {date_string}"


def test_url_format():
    """Test URL format validation."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    data = response.json()
    
    website = data["website"]
    
    # Should look like a domain
    assert "." in website
    
    # Could validate as full URL if protocol included
    # if website.startswith("http"):
    #     parsed = httpx.URL(website)
    #     assert parsed.scheme in ["http", "https"]
```

---

## H. Null and Empty Value Handling

File: `tests/test_null_handling.py`
```python
"""
Test null and empty value handling.
"""
import httpx


def test_null_vs_missing_field():
    """Test difference between null and missing field."""
    response = httpx.get("https://httpbin.org/get")
    data = response.json()
    
    # Field exists with null value
    # vs field doesn't exist at all
    
    # Safe way to check
    middle_name = data.get("middleName")  # Returns None if missing
    assert middle_name is None  # Could be null or missing


def test_empty_string_validation():
    """Test handling of empty strings."""
    # In real API testing
    empty_data = {
        "name": "",  # Empty string
        "description": None  # Null
    }
    
    # Empty string is different from null
    assert empty_data["name"] == ""
    assert empty_data["name"] is not None
    assert empty_data["description"] is None


def test_empty_array():
    """Test handling of empty arrays."""
    # Some endpoints might return empty array
    # Demonstration
    empty_list = []
    
    assert isinstance(empty_list, list)
    assert len(empty_list) == 0
    
    # Checking if not empty before accessing
    if empty_list:
        first_item = empty_list[0]
    else:
        # Handle empty case
        first_item = None


def test_null_in_nested_object():
    """Test null values in nested structures."""
    data = {
        "user": {
            "name": "John",
            "middleName": None,  # Explicitly null
            "address": {
                "street": "123 Main St",
                "apartment": None  # Null apartment
            }
        }
    }
    
    # Safe access
    middle_name = data["user"].get("middleName")
    assert middle_name is None
    
    apartment = data["user"]["address"].get("apartment")
    assert apartment is None
```

---

## I. Complete Validation Pattern

File: `tests/test_complete_validation.py`
```python
"""
Complete validation pattern example.
"""
import httpx


def test_complete_user_validation():
    """Example of complete response validation."""
    response = httpx.get("https://jsonplaceholder.typicode.com/users/1")
    
    # 1. Status Code
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"
    
    # 2. Headers
    assert "application/json" in response.headers["content-type"]
    assert int(response.headers["content-length"]) > 0
    
    # 3. Response can be parsed
    data = response.json()
    
    # 4. Response structure
    assert isinstance(data, dict), "Response should be JSON object"
    
    # 5. Required fields present
    required_fields = ["id", "name", "username", "email", "address", "phone", "website", "company"]
    for field in required_fields:
        assert field in data, f"Missing required field: {field}"
    
    # 6. Data types correct
    assert isinstance(data["id"], int)
    assert isinstance(data["name"], str)
    assert isinstance(data["email"], str)
    assert isinstance(data["address"], dict)
    assert isinstance(data["company"], dict)
    
    # 7. Value validation
    assert data["id"] > 0
    assert len(data["name"]) > 0
    assert "@" in data["email"]
    
    # 8. Nested structure validation
    assert "street" in data["address"]
    assert "city" in data["address"]
    assert isinstance(data["address"]["geo"], dict)
    assert "lat" in data["address"]["geo"]
    assert "lng" in data["address"]["geo"]
    
    # 9. Company structure
    assert "name" in data["company"]
    assert len(data["company"]["name"]) > 0


def validate_post_response(response, expected_user_id=None):
    """Reusable validation function for post responses."""
    # Status
    assert response.status_code == 200
    
    # Parse
    data = response.json()
    
    # Structure
    assert isinstance(data, dict)
    
    # Required fields
    required = ["userId", "id", "title", "body"]
    for field in required:
        assert field in data
    
    # Types
    assert isinstance(data["userId"], int)
    assert isinstance(data["id"], int)
    assert isinstance(data["title"], str)
    assert isinstance(data["body"], str)
    
    # Values
    assert data["userId"] > 0
    assert data["id"] > 0
    assert len(data["title"]) > 0
    
    # Optional: check specific user ID
    if expected_user_id:
        assert data["userId"] == expected_user_id
    
    return data


def test_using_validation_helper():
    """Test using validation helper function."""
    response = httpx.get("https://jsonplaceholder.typicode.com/posts/1")
    validated_data = validate_post_response(response, expected_user_id=1)
    
    # Can do additional checks on validated data
    assert validated_data["id"] == 1
```

---

## J. Common Validation Mistakes

### Mistake 1: Only Checking Status Code
```python
# âŒ Bad
def test_incomplete():
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
    # What if response body is wrong?

# âœ… Good
def test_complete():
    response = httpx.get("https://api.example.com/users/1")
    assert response.status_code == 200
    data = response.json()
    assert "id" in data
    assert isinstance(data["id"], int)
```

### Mistake 2: Not Checking Data Types
```python
# âŒ Bad
assert data["id"] == "1"  # Might be string or int!

# âœ… Good
assert isinstance(data["id"], int)
assert data["id"] == 1
```

### Mistake 3: Unsafe Dictionary Access
```python
# âŒ Bad - will crash if key missing
email = data["email"]

# âœ… Good - safe access
email = data.get("email")
if email:
    assert "@" in email
```

---

## K. Validation Checklist

For every API response, validate:

**1. Status Code**
- âœ… Correct status (200, 201, 404, etc.)
- âœ… Use helper properties (is_success, is_error)

**2. Headers**
- âœ… Content-Type is correct
- âœ… Required headers present
- âœ… Security headers (if applicable)

**3. Response Structure**
- âœ… Can be parsed (valid JSON/XML)
- âœ… Correct type (object vs array)
- âœ… Not empty (unless expected)

**4. Required Fields**
- âœ… All required fields present
- âœ… No extra unexpected fields (optional)

**5. Data Types**
- âœ… All fields have correct types
- âœ… Nested objects validated

**6. Value Validation**
- âœ… IDs are positive
- âœ… Strings not empty (if required)
- âœ… Email format valid
- âœ… URLs well-formed
- âœ… Dates in correct format
- âœ… Enums have valid values
- âœ… Numbers in valid ranges

**7. Null Handling**
- âœ… Required fields not null
- âœ… Optional fields handled safely

---

## L. Key Takeaways

ğŸ”‘ **Validate status codes**: First line of defense  
ğŸ”‘ **Check headers**: Content-Type especially important  
ğŸ”‘ **Verify structure**: Object vs array, nested data  
ğŸ”‘ **Required fields**: Must all be present  
ğŸ”‘ **Data types**: Use isinstance() to check  
ğŸ”‘ **Value ranges**: Positive IDs, valid emails, etc.  
ğŸ”‘ **Null safety**: Use .get() for optional fields  
ğŸ”‘ **Be comprehensive**: Multiple validation layers  

---

## M. Quick Exercise

**Challenge**: Write a validation function that checks:
1. Status is 200
2. Response is JSON
3. Has "data" array field
4. Array is not empty
5. First item has "id" and "name"

**Solution**:
```python
def validate_list_response(response):
    assert response.status_code == 200
    assert "application/json" in response.headers["content-type"]
    
    data = response.json()
    assert "data" in data
    assert isinstance(data["data"], list)
    assert len(data["data"]) > 0
    
    first_item = data["data"][0]
    assert "id" in first_item
    assert "name" in first_item
    
    return data
```

---

## N. What's Next?

In **Lesson 1.15: JSON Response Parsing**, we'll dive deep into:
- Navigating nested JSON structures
- Accessing array elements safely
- Handling complex nested objects
- JSONPath expressions
- Error handling in parsing

You now know how to validate responses! Let's master JSON parsing. ğŸš€

**Ready for lesson 1.15?**
