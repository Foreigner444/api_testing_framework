# Lesson 5.21: Environment Variable Precedence

## A. Concept Overview

### What & Why
**Environment variable precedence** defines the order in which configuration sources are evaluated when the same setting exists in multiple places. Understanding precedence is critical because it determines which value your application actually uses when conflicts occur.

### Analogy
Think of precedence like a chain of command in an organization. The CEO's decision (system env vars) overrides the VP's recommendation (.env file), which overrides the manager's suggestion (config file), which overrides the employee handbook (code defaults). Clear hierarchy prevents confusion.

---

## B. Code Implementation

### Standard Precedence Order (Highest to Lowest)

```python
"""
Configuration Source Precedence:

1. System Environment Variables (HIGHEST)
   - Set with: export VAR=value
   - Persists for session/system
   
2. .env.{ENVIRONMENT}.local
   - Personal local overrides
   - Never committed to git
   
3. .env.{ENVIRONMENT}
   - Environment-specific config
   - e.g., .env.development, .env.staging
   
4. .env.local
   - General local overrides
   - Never committed to git
   
5. .env
   - Base configuration
   - Can be committed (with dummy values)
   
6. Config files (YAML/JSON/TOML)
   - Structured configuration
   - Version controlled
   
7. Code defaults (LOWEST)
   - Hardcoded in Settings class
   - Last resort fallback
"""

from pydantic_settings import BaseSettings, SettingsConfigDict
import os


class Settings(BaseSettings):
    api_key: str = "default_from_code"
    timeout: int = 30
    
    model_config = SettingsConfigDict(
        env_file=(".env", ".env.local"),
        case_sensitive=False
    )


# Demonstrate precedence
def show_precedence():
    """Show which source provides each value."""
    
    # Set system env var (highest precedence)
    os.environ["API_KEY"] = "from_system_env"
    
    # .env file has:
    # TIMEOUT=60
    
    # Code has default:
    # timeout: int = 30
    
    settings = Settings()
    
    print("Configuration Sources:")
    print(f"  API_KEY: {settings.api_key}")
    print(f"    â†’ From: System environment variable")
    print(f"  TIMEOUT: {settings.timeout}")
    print(f"    â†’ From: .env file (no system override)")
    
    # Unset system var to see next level
    del os.environ["API_KEY"]
    settings2 = Settings()
    print(f"\nAfter removing system env var:")
    print(f"  API_KEY: {settings2.api_key}")
    print(f"    â†’ From: .env file (next in precedence)")
```

---

### Precedence Testing Tool

```python
from pathlib import Path
from typing import Dict, List
import os


class PrecedenceTester:
    """Test which configuration source provides each value."""
    
    def __init__(self, settings):
        self.settings = settings
    
    def check_source(self, field_name: str) -> str:
        """Determine which source provided a field's value."""
        value = getattr(self.settings, field_name)
        
        # Check system environment
        if field_name.upper() in os.environ:
            return f"System Environment ({os.environ[field_name.upper()]})"
        
        # Check .env files
        env_files = [".env.local", ".env"]
        for env_file in env_files:
            if Path(env_file).exists():
                with open(env_file) as f:
                    for line in f:
                        if line.strip().startswith(field_name.upper()):
                            return f"{env_file} file"
        
        # Must be from code default
        return "Code default"
    
    def show_all_sources(self) -> None:
        """Display source for all settings fields."""
        print("\n" + "=" * 60)
        print("Configuration Source Report")
        print("=" * 60)
        
        for field_name in self.settings.model_fields:
            value = getattr(self.settings, field_name)
            source = self.check_source(field_name)
            
            # Mask sensitive values
            if any(x in field_name.lower() for x in ["key", "secret", "password"]):
                display_value = "***"
            else:
                display_value = value
            
            print(f"\n{field_name}:")
            print(f"  Value: {display_value}")
            print(f"  Source: {source}")
        
        print("\n" + "=" * 60)


# Usage
settings = Settings()
tester = PrecedenceTester(settings)
tester.show_all_sources()
```

---

## C. Connect & Apply

### How to Test It

```bash
# 1. Create .env with base config
cat > .env << 'EOF'
API_KEY=from_env_file
TIMEOUT=60
EOF

# 2. Test with just .env
python -c "
from config.settings import Settings
s = Settings()
print(f'API_KEY: {s.api_key}')  # from_env_file
print(f'TIMEOUT: {s.timeout}')  # 60
"

# 3. Add system environment variable (higher precedence)
export API_KEY=from_system

python -c "
from config.settings import Settings
s = Settings()
print(f'API_KEY: {s.api_key}')  # from_system (overrides .env)
print(f'TIMEOUT: {s.timeout}')  # 60 (still from .env)
"

# 4. Unset to see precedence drop back
unset API_KEY

python -c "
from config.settings import Settings
s = Settings()
print(f'API_KEY: {s.api_key}')  # from_env_file (back to .env)
"
```

### Expected Result

```
# With system env var:
API_KEY: from_system        # System env (highest)
TIMEOUT: 60                 # .env file

# Without system env var:
API_KEY: from_env_file      # .env file
TIMEOUT: 60                 # .env file
```

---

## D. Common Stumbling Blocks

### Mistake #1: Expecting .env to override system env vars

**The Problem:**

```bash
export API_KEY=production_key

# .env has: API_KEY=dev_key

python app.py
# Uses production_key, not dev_key!
```

**Why:** System environment variables always have highest precedence (security feature).

**The Fix:** Understand this is intentional. To use .env value, unset system var:

```bash
unset API_KEY
python app.py  # Now uses dev_key from .env
```

---

### Mistake #2: Not knowing what's set in system environment

**The Problem:**

```bash
# Something set API_KEY days ago
# You forgot about it
# Now your .env changes don't seem to work
```

**The Fix:**

```bash
# Check what's currently set
env | grep API

# Or in Python:
python -c "import os; print(os.getenv('API_KEY', 'NOT SET'))"

# Unset if needed:
unset API_KEY
```

---

### Mistake #3: Precedence confusion with multiple .env files

**The Problem:**

```python
# Which wins?
model_config = SettingsConfigDict(
    env_file=(".env", ".env.local", ".env.development")
)
```

**Answer:** Later files in the tuple have higher precedence:
- `.env.development` > `.env.local` > `.env`

But system env vars still beat all of them!

---

## ðŸŽ¯ Key Takeaways

âœ… **System environment variables** always win (highest precedence)  
âœ… **Precedence order:** System env > .env.local > .env > config files > code defaults  
âœ… **Security feature:** System env can't be overridden by files  
âœ… **Check system env** when config changes don't seem to work  
âœ… **Use precedence intentionally** for flexible configuration  
âœ… **Document precedence** in your project README  

---

## What's Next?

Next: **Dynamic Configuration Loading** - loading configuration at runtime!

**Ready to continue?** ðŸš€
