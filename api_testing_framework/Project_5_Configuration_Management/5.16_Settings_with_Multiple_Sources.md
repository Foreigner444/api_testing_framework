# Lesson 5.16: Settings with Multiple Sources

## A. Concept Overview

### What & Why
**Loading configuration from multiple sources** (environment variables, .env files, YAML, JSON) with defined precedence ensures flexibility across different deployment scenarios. Essential for frameworks that need to support various configuration methods while maintaining predictable behavior.

### Analogy
Multiple configuration sources are like restaurant orders: online orders (env vars - highest priority), phone orders (.env files), and walk-ins (YAML/JSON defaults). All are valid ways to order, but there's a clear priority when conflicts occur.

---

## B. Code Implementation

```python
from typing import Any, Dict
from pathlib import Path
from pydantic_settings import BaseSettings, SettingsConfigDict
import yaml
import json


class MultiSourceSettings(BaseSettings):
    """Settings loading from multiple sources with precedence."""
    
    api_key: str
    database_url: str
    timeout: int = 30
    
    model_config = SettingsConfigDict(
        # Source precedence (highest to lowest):
        # 1. System environment variables
        # 2. .env file
        # 3. Programmatically set values
        env_file=".env",
        case_sensitive=False
    )
    
    @classmethod
    def from_yaml(cls, yaml_path: Path) -> "MultiSourceSettings":
        """Load settings from YAML file as base."""
        with open(yaml_path) as f:
            yaml_data = yaml.safe_load(f)
        return cls(**yaml_data)
    
    @classmethod
    def from_multiple_sources(cls) -> "MultiSourceSettings":
        """
        Load from multiple sources with precedence:
        1. System env vars (highest)
        2. .env file
        3. config.yaml (lowest)
        """
        # Load YAML as base
        config_file = Path("config.yaml")
        if config_file.exists():
            with open(config_file) as f:
                base_config = yaml.safe_load(f)
        else:
            base_config = {}
        
        # Pydantic will layer env vars and .env on top
        return cls(**base_config)


# Example usage:
# config.yaml has defaults
# .env overrides some values
# System env vars override everything
settings = MultiSourceSettings.from_multiple_sources()
```

---

## C. Connect & Apply

### How to Test It

```bash
# Create config.yaml
cat > config.yaml << 'EOF'
api_key: default_key_from_yaml
database_url: postgresql://localhost/default_db
timeout: 30
EOF

# Create .env (overrides YAML)
cat > .env << 'EOF'
DATABASE_URL=postgresql://localhost/env_db
EOF

# System env var (overrides everything)
export API_KEY=system_env_key

python -c "
from config.settings import MultiSourceSettings
s = MultiSourceSettings.from_multiple_sources()
print(f'API Key: {s.api_key}')  # From system env
print(f'Database: {s.database_url}')  # From .env
print(f'Timeout: {s.timeout}')  # From YAML (nothing overrode it)
"
```

### Expected Result

```
API Key: system_env_key        # System env (highest priority)
Database: postgresql://localhost/env_db   # .env file
Timeout: 30                     # config.yaml (lowest priority)
```

---

## D. Common Stumbling Blocks

### Mistake #1: Confusion about precedence

**Problem:** Not understanding which source wins when values conflict.

**Fix:** Always remember: System env > .env > config files > defaults

---

## ðŸŽ¯ Key Takeaways

âœ… **System environment variables** have highest priority  
âœ… **.env files** override config file defaults  
âœ… **Config files (YAML/JSON)** provide base configuration  
âœ… **Class methods** allow loading from different sources  
âœ… **Precedence is predictable** and follows industry standards  

---

## What's Next?

Next: **YAML Configuration Files** - using YAML for structured configuration!

**Ready to continue?** ðŸš€
