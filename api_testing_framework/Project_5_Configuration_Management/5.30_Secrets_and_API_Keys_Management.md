# Lesson 5.30: Secrets and API Keys Management

## A. Concept Overview

### What & Why
**Secrets management** ensures API keys, passwords, and tokens are stored securely, never committed to version control, and accessed safely in code. Essential for securityâ€”leaked secrets can lead to data breaches, unauthorized access, and financial damage.

### Analogy
Secrets management is like a bank vault systemâ€”safe deposit boxes (secret managers) for valuable items (credentials), access logs (audit trails), and multiple keys required (multi-factor auth). You don't store cash under your mattress (in code) or write your PIN on your debit card (.env in git).

---

## B. Code Implementation

```python
from pydantic import Field, SecretStr, field_validator
from pydantic_settings import BaseSettings
import os
from typing import Optional


class SecretsSettings(BaseSettings):
    """Secure secrets management."""
    
    # API Keys
    api_key: SecretStr = Field(..., description="API key - never logged")
    api_secret: SecretStr = Field(..., description="API secret")
    
    # Database credentials
    database_password: SecretStr
    
    # JWT secrets
    jwt_secret_key: SecretStr
    
    # Encryption keys
    encryption_key: Optional[SecretStr] = None
    
    @field_validator("api_key", "api_secret")
    @classmethod
    def validate_key_length(cls, v: SecretStr) -> SecretStr:
        """Ensure keys meet minimum length."""
        if len(v.get_secret_value()) < 32:
            raise ValueError("Secrets must be at least 32 characters")
        return v
    
    def get_database_url(self, host: str, database: str) -> str:
        """Build database URL with secret password."""
        password = self.database_password.get_secret_value()
        return f"postgresql://user:{password}@{host}/{database}"


# .env.example (safe template)
# API_KEY=generate_with_openssl_rand_hex_32
# API_SECRET=generate_with_openssl_rand_hex_32
# DATABASE_PASSWORD=your_secure_password_here
# JWT_SECRET_KEY=generate_with_openssl_rand_hex_32

# .env (never commit!)
# API_KEY=real_32_char_key_here_abcd1234
# API_SECRET=real_32_char_secret_xyz9876  
# DATABASE_PASSWORD=real_db_password
# JWT_SECRET_KEY=real_jwt_secret_key


# Secret rotation helper
def rotate_secret(old_secret: str, new_secret: str) -> None:
    """Helper for secret rotation."""
    print("Rotating secret...")
    # Update in environment/secret manager
    os.environ["API_KEY"] = new_secret
    print("âœ“ Secret rotated")


# Audit logging
import logging

def log_secret_access(secret_name: str) -> None:
    """Log secret access for auditing."""
    logging.info(f"Secret accessed: {secret_name}")
```

---

## C. Connect & Apply

```bash
# Generate secure secrets
openssl rand -hex 32

# Never do this:
# git add .env
# API_KEY="secret123"  # In code

# Always do this:
# .env in .gitignore
# Use SecretStr in Pydantic
```

---

## D. Common Stumbling Blocks

**Mistake:** Logging secrets
```python
print(f"API Key: {settings.api_key}")  # Logs secret!
```

**Fix:**
```python
print(f"API Key: ***")  # SecretStr prevents leakage
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Use SecretStr** to prevent accidental logging  
âœ… **Never commit** secrets to version control  
âœ… **Rotate secrets** regularly  
âœ… **Audit access** to secrets  
âœ… **Minimum 32 characters** for cryptographic keys  

---

## What's Next?

Next: **Database Connection Strings**!

**Ready to continue?** ðŸš€
