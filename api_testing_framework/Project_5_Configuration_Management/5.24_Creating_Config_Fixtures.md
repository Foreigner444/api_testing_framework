# Lesson 5.24: Creating Config Fixtures

## A. Concept Overview

### What & Why
**Configuration fixtures** in pytest provide clean, reusable access to settings throughout your test suite. Essential for dependency injection, test isolation, and enabling different configurations per test when needed.

### Analogy
Config fixtures are like a hotel concierge service. Instead of each guest (test) figuring out where things are, the concierge (fixture) provides everything you needâ€”room key (API credentials), Wi-Fi password (database URL), restaurant recommendations (configured clients). Centralized, consistent service.

---

## B. Code Implementation

### Basic Config Fixtures

**File Path:** `conftest.py`

```python
import pytest
from config.settings import Settings


@pytest.fixture(scope="session")
def settings():
    """
    Provide settings for entire test session.
    
    Scope='session' means settings loaded once and reused
    across all tests (efficient).
    """
    return Settings()


@pytest.fixture(scope="session")
def api_config(settings):
    """Provide API-specific configuration."""
    return {
        "base_url": settings.api_base_url,
        "api_key": settings.api_key,
        "timeout": settings.api_timeout,
    }


@pytest.fixture(scope="session")
def database_config(settings):
    """Provide database configuration."""
    return {
        "url": settings.database_url,
        "pool_size": settings.database_pool_size,
    }
```

---

### httpx Client Fixtures

**File Path:** `conftest.py` (continued)

```python
import httpx


@pytest.fixture(scope="session")
def api_client(settings):
    """
    Provide configured httpx client for entire session.
    
    Client is created once and reused across all tests.
    """
    client = httpx.Client(
        base_url=settings.api_base_url,
        headers={"Authorization": f"Bearer {settings.api_key}"},
        timeout=settings.api_timeout
    )
    
    yield client
    
    # Cleanup after all tests
    client.close()


@pytest.fixture
def fresh_api_client(settings):
    """
    Provide fresh httpx client for each test.
    
    Scope='function' (default) means new client per test.
    Use when tests modify client state.
    """
    client = httpx.Client(
        base_url=settings.api_base_url,
        headers={"Authorization": f"Bearer {settings.api_key}"},
        timeout=settings.api_timeout
    )
    
    yield client
    
    client.close()
```

---

### Environment-Specific Fixtures

```python
@pytest.fixture(scope="session")
def is_production(settings):
    """Check if running in production environment."""
    return settings.environment == "production"


@pytest.fixture(scope="session")
def is_development(settings):
    """Check if running in development environment."""
    return settings.environment == "development"


def test_destructive_operation(is_production):
    """Skip destructive tests in production."""
    if is_production:
        pytest.skip("Skipping destructive test in production")
    
    # Safe to run destructive operations in dev/staging
    pass


@pytest.fixture
def test_data_config(settings):
    """Provide test data based on environment."""
    if settings.environment == "production":
        return {
            "max_records": 10,  # Limited in production
            "use_real_data": True
        }
    else:
        return {
            "max_records": 1000,  # More in dev/staging
            "use_real_data": False
        }
```

---

### Parametrized Config Fixtures

```python
@pytest.fixture(params=["development", "staging"])
def multi_env_settings(request):
    """
    Test against multiple environments.
    
    This fixture will cause each test using it to run twice:
    once with development config, once with staging config.
    """
    env = request.param
    return Settings(_env_file=f".env.{env}")


def test_api_health(multi_env_settings):
    """This test runs twice: dev and staging."""
    client = httpx.Client(base_url=multi_env_settings.api_base_url)
    response = client.get("/health")
    assert response.status_code == 200
```

---

### Using Fixtures in Tests

**File Path:** `tests/test_with_fixtures.py`

```python
def test_with_settings_fixture(settings):
    """Test using settings fixture."""
    assert settings.api_base_url is not None
    assert len(settings.api_key) > 0
    print(f"Testing against: {settings.api_base_url}")


def test_with_api_client(api_client):
    """Test using pre-configured API client."""
    response = api_client.get("/health")
    assert response.status_code == 200


def test_with_database_config(database_config):
    """Test using database configuration."""
    assert "postgresql://" in database_config["url"]
    assert database_config["pool_size"] > 0


def test_environment_specific(is_development, test_data_config):
    """Test that behaves differently per environment."""
    if is_development:
        # More extensive testing in development
        assert test_data_config["max_records"] == 1000
    
    print(f"Max records for this env: {test_data_config['max_records']}")
```

---

## C. Connect & Apply

### How to Test It

```bash
# Create conftest.py with fixtures (code above)

# Create test file
cat > tests/test_fixtures.py << 'EOF'
def test_settings(settings):
    print(f"API URL: {settings.api_base_url}")
    print(f"Environment: {settings.environment}")
    assert settings is not None

def test_api_client(api_client):
    print(f"Client base URL: {api_client.base_url}")
    assert api_client is not None
EOF

# Run tests
pytest tests/test_fixtures.py -v -s
```

### Expected Result

```
tests/test_fixtures.py::test_settings PASSED
API URL: http://localhost:8000
Environment: development

tests/test_fixtures.py::test_api_client PASSED
Client base URL: http://localhost:8000
```

---

## D. Common Stumbling Blocks

### Mistake #1: Wrong fixture scope

**The Problem:**

```python
@pytest.fixture(scope="session")
def api_client(settings):
    return httpx.Client(...)

def test_modifies_client(api_client):
    api_client.headers["X-Custom"] = "value"  # Affects other tests!
```

**The Fix:**

```python
# Use function scope for fixtures that get modified
@pytest.fixture  # scope="function" is default
def api_client(settings):
    return httpx.Client(...)
```

---

### Mistake #2: Forgetting cleanup

**The Problem:**

```python
@pytest.fixture
def api_client(settings):
    return httpx.Client(...)  # Never closed!
```

**The Fix:**

```python
@pytest.fixture
def api_client(settings):
    client = httpx.Client(...)
    yield client
    client.close()  # Cleanup
```

---

### Mistake #3: Circular fixture dependencies

**The Problem:**

```python
@pytest.fixture
def fixture_a(fixture_b):
    pass

@pytest.fixture
def fixture_b(fixture_a):  # Circular!
    pass
```

**Error:** `fixture 'fixture_a' not found`

**The Fix:** Redesign to avoid circular dependencies

---

## ğŸ¯ Key Takeaways

âœ… **Use fixtures** for configuration dependency injection  
âœ… **scope="session"** for expensive, reusable fixtures  
âœ… **scope="function"** for fixtures that tests modify  
âœ… **yield** for fixtures needing cleanup  
âœ… **Parametrize** fixtures to test multiple configurations  
âœ… **Organize** fixtures in conftest.py for reusability  

---

## What's Next?

Next: **Environment Switching in Tests** - testing against multiple environments!

**Ready to continue?** ğŸš€
