# Lesson 5.5: Installing python-dotenv

## A. Concept Overview

### What & Why
**python-dotenv** is a Python library that automatically loads environment variables from `.env` files into your environment. It's important because it eliminates the tedium of manually exporting dozens of environment variables before running tests, making local development effortless while maintaining 12-Factor compliance.

### Analogy
Think of python-dotenv like a valet service for your configuration. Instead of carrying around all your keys (environment variables) and fumbling to unlock each door manually (`export VAR1=... export VAR2=...`), you hand a file to the valet (`python-dotenv` loads your `.env` file) and they unlock everything for you automatically. Same keys, just way more convenient.

---

## B. Code Implementation

### Installing python-dotenv

**File Path:** `requirements.txt`

```txt
# Core Testing Dependencies
pytest>=7.4.0
pytest-asyncio>=0.21.0
httpx>=0.24.0

# Configuration Management
python-dotenv>=1.0.0
pydantic>=2.0.0
pydantic-settings>=2.0.0

# Testing Utilities
faker>=18.0.0

# Reporting
allure-pytest>=2.13.0
```

---

### Installation Commands

```bash
# Install python-dotenv only
pip install python-dotenv

# Or install all dependencies for your framework
pip install -r requirements.txt

# With specific version
pip install python-dotenv==1.0.0

# Check installation
pip show python-dotenv
```

**Expected output:**
```
Name: python-dotenv
Version: 1.0.0
Summary: Read key-value pairs from a .env file and set them as environment variables
Home-page: https://github.com/theskumar/python-dotenv
```

---

### Basic Usage of python-dotenv

**File Path:** `.env`

```bash
# Development environment configuration
API_BASE_URL=http://localhost:8000
API_KEY=dev_key_12345
DATABASE_URL=postgresql://user:password@localhost:5432/testdb
TIMEOUT=30
DEBUG=True
LOG_LEVEL=DEBUG
```

**File Path:** `examples/load_dotenv_basic.py`

```python
import os
from dotenv import load_dotenv

# Method 1: Load .env from current directory
load_dotenv()

# Now environment variables are available
api_key = os.getenv("API_KEY")
base_url = os.getenv("API_BASE_URL")
debug = os.getenv("DEBUG")

print(f"API Key: {api_key}")
print(f"Base URL: {base_url}")
print(f"Debug: {debug}")

# Method 2: Load from specific file path
load_dotenv(dotenv_path=".env.development")

# Method 3: Load and override existing env vars
load_dotenv(override=True)

# Method 4: Find .env automatically in parent directories
from dotenv import find_dotenv
load_dotenv(find_dotenv())
```

---

### Advanced python-dotenv Usage

**File Path:** `examples/load_dotenv_advanced.py`

```python
import os
from dotenv import load_dotenv, dotenv_values, find_dotenv
from pathlib import Path


def load_from_specific_file():
    """
    Load environment variables from a specific .env file.
    Useful when you have multiple environment files.
    """
    # Load development environment
    env_path = Path('.env.development')
    load_dotenv(dotenv_path=env_path)
    
    print(f"Loaded from: {env_path}")
    print(f"Environment: {os.getenv('ENVIRONMENT')}")


def load_without_setting_env():
    """
    Read .env file without modifying os.environ.
    Useful for inspecting config without side effects.
    """
    # Returns dict without modifying environment
    config = dotenv_values(".env")
    
    print("Configuration from .env:")
    for key, value in config.items():
        print(f"  {key} = {value}")
    
    # os.environ is unchanged
    print(f"\nAPI_KEY in os.environ: {'API_KEY' in os.environ}")


def load_with_override():
    """
    Override existing environment variables.
    By default, load_dotenv() doesn't override existing vars.
    """
    # Set an environment variable first
    os.environ["API_KEY"] = "existing_key"
    print(f"Before load_dotenv: API_KEY = {os.getenv('API_KEY')}")
    
    # Load without override (default behavior)
    load_dotenv()
    print(f"After load_dotenv (no override): API_KEY = {os.getenv('API_KEY')}")
    
    # Load with override
    load_dotenv(override=True)
    print(f"After load_dotenv (with override): API_KEY = {os.getenv('API_KEY')}")


def find_env_file_automatically():
    """
    Search for .env file in current and parent directories.
    Useful in complex project structures.
    """
    # find_dotenv() searches current dir and all parent dirs
    env_file = find_dotenv()
    
    if env_file:
        print(f"Found .env file at: {env_file}")
        load_dotenv(env_file)
    else:
        print("No .env file found")
        print("Searched directories:")
        print(f"  - Current: {Path.cwd()}")
        print(f"  - Parents: {list(Path.cwd().parents)}")


def load_with_encoding():
    """
    Load .env files with specific encoding.
    Useful for international characters.
    """
    load_dotenv(encoding='utf-8')
    
    # Now you can have non-ASCII characters in your .env
    # MESSAGE=Hello ä¸–ç•Œ ðŸŒ


def interpolate_variables():
    """
    python-dotenv supports variable interpolation.
    """
    # In .env file:
    # BASE_DIR=/home/user/project
    # DATA_DIR=${BASE_DIR}/data
    # LOG_FILE=${DATA_DIR}/app.log
    
    load_dotenv()
    
    print(f"BASE_DIR: {os.getenv('BASE_DIR')}")
    print(f"DATA_DIR: {os.getenv('DATA_DIR')}")
    print(f"LOG_FILE: {os.getenv('LOG_FILE')}")


if __name__ == "__main__":
    print("=== Load from Specific File ===")
    load_from_specific_file()
    
    print("\n=== Load Without Setting Environment ===")
    load_without_setting_env()
    
    print("\n=== Load With Override ===")
    load_with_override()
    
    print("\n=== Find .env Automatically ===")
    find_env_file_automatically()
```

---

### Using python-dotenv in Tests

**File Path:** `conftest.py`

```python
"""
pytest configuration file.

This file is automatically loaded by pytest before running tests.
Perfect place to load environment variables.
"""

import os
from pathlib import Path
from dotenv import load_dotenv, find_dotenv


def load_environment():
    """
    Load environment variables from .env file.
    
    This runs once when pytest starts, before any tests.
    """
    # Determine which .env file to load
    # Priority: .env.{ENVIRONMENT} > .env
    environment = os.getenv("ENVIRONMENT", "development")
    
    # Try environment-specific file first
    env_file = Path(f".env.{environment}")
    if env_file.exists():
        print(f"Loading configuration from: {env_file}")
        load_dotenv(dotenv_path=env_file)
    else:
        # Fall back to .env
        env_file = find_dotenv()
        if env_file:
            print(f"Loading configuration from: {env_file}")
            load_dotenv(dotenv_path=env_file)
        else:
            print("No .env file found, using system environment variables only")
    
    # Validate required variables
    required_vars = ["API_BASE_URL", "API_KEY"]
    missing = [var for var in required_vars if var not in os.environ]
    
    if missing:
        raise ValueError(
            f"Missing required environment variables: {', '.join(missing)}\n"
            f"Create a .env file with these variables."
        )


# Load environment variables when pytest starts
load_environment()


# Print configuration summary (optional, helpful for debugging)
def pytest_configure(config):
    """Hook called after conftest is loaded."""
    print("\n" + "=" * 50)
    print("Test Configuration Loaded")
    print("=" * 50)
    print(f"Environment: {os.getenv('ENVIRONMENT', 'development')}")
    print(f"API Base URL: {os.getenv('API_BASE_URL')}")
    print(f"Debug Mode: {os.getenv('DEBUG', 'False')}")
    print("=" * 50 + "\n")
```

**File Path:** `tests/test_with_dotenv.py`

```python
import os
import httpx
import pytest


def test_env_vars_loaded():
    """
    Verify that environment variables were loaded from .env file.
    """
    # These should be loaded by conftest.py
    assert "API_BASE_URL" in os.environ
    assert "API_KEY" in os.environ
    
    api_url = os.getenv("API_BASE_URL")
    assert api_url is not None
    assert len(api_url) > 0
    
    print(f"Testing against: {api_url}")


@pytest.fixture
def api_client():
    """
    Create httpx client using env vars loaded from .env file.
    """
    # No need to load_dotenv() here - conftest.py already did it
    base_url = os.getenv("API_BASE_URL")
    api_key = os.getenv("API_KEY")
    timeout = float(os.getenv("TIMEOUT", "30"))
    
    client = httpx.Client(
        base_url=base_url,
        headers={"Authorization": f"Bearer {api_key}"},
        timeout=timeout
    )
    
    yield client
    client.close()


def test_api_with_dotenv_config(api_client):
    """
    Test API using configuration from .env file.
    """
    response = api_client.get("/health")
    assert response.status_code == 200
```

---

### Line-by-Line Explanation

**In `load_dotenv_basic.py`:**

- `load_dotenv()`: Searches for `.env` in current directory and loads it
- `load_dotenv(dotenv_path="...")`: Load from specific file path
- `load_dotenv(override=True)`: Override existing environment variables
- `find_dotenv()`: Search current and parent directories for `.env`
- After `load_dotenv()`, all variables are in `os.environ`

**In `load_dotenv_advanced.py`:**

- `dotenv_values(".env")`: Returns dict without modifying `os.environ` - useful for inspecting config
- `load_dotenv(encoding='utf-8')`: Handle international characters
- Variable interpolation: `${VAR_NAME}` in `.env` file expands to value

**In `conftest.py`:**

- Runs automatically before any test
- Loads environment variables once for entire test session
- Environment-specific file takes precedence (`.env.development` over `.env`)
- Validates required variables are present
- `pytest_configure` hook prints config summary

---

### The "Why" Behind the Code

**Why python-dotenv?**

1. **Developer Experience**: No tedious `export` commands before running tests
2. **Onboarding**: New developers just create `.env` and start testing
3. **Consistency**: Everyone uses the same variable names
4. **Documentation**: `.env.example` shows what variables are needed
5. **12-Factor Compliant**: Uses environment variables, just loads them from file
6. **Doesn't Replace Env Vars**: Existing environment variables take precedence (secure)
7. **CI/CD Friendly**: In CI, set real env vars; dotenv gracefully does nothing

**Why load in conftest.py?**

- Runs once before all tests (efficient)
- Centralized configuration loading
- Validates config before any test runs
- Can customize environment file per test run
- Follows pytest best practices

**Why .env is gitignored:**

Your `.env` file contains your personal/local configuration. It might have:
- API keys you generated
- Local database credentials
- Paths specific to your machine
- Debug settings you prefer

Everyone on the team has different values, so `.env` stays local. Instead, commit `.env.example` with dummy values.

---

## C. Connect & Apply

### How to Test It

1. **Install python-dotenv:**

```bash
pip install python-dotenv
```

2. **Create .env file:**

```bash
cat > .env << 'EOF'
API_BASE_URL=http://localhost:8000
API_KEY=dev_key_12345
DATABASE_URL=postgresql://localhost:5432/testdb
TIMEOUT=30
DEBUG=True
LOG_LEVEL=DEBUG
ENVIRONMENT=development
EOF
```

3. **Create test script:**

```bash
mkdir -p examples

cat > examples/test_dotenv.py << 'EOF'
import os
from dotenv import load_dotenv

print("Before load_dotenv:")
print(f"  API_KEY: {os.getenv('API_KEY')}")

load_dotenv()

print("\nAfter load_dotenv:")
print(f"  API_KEY: {os.getenv('API_KEY')}")
print(f"  API_BASE_URL: {os.getenv('API_BASE_URL')}")
print(f"  DEBUG: {os.getenv('DEBUG')}")
EOF

python examples/test_dotenv.py
```

4. **Test with pytest:**

Create the conftest.py from above, then:

```bash
pytest tests/ -v -s
```

### Expected Result

**From `test_dotenv.py`:**
```
Before load_dotenv:
  API_KEY: None

After load_dotenv:
  API_KEY: dev_key_12345
  API_BASE_URL: http://localhost:8000
  DEBUG: True
```

**From pytest with conftest.py:**
```
Loading configuration from: .env
==================================================
Test Configuration Loaded
==================================================
Environment: development
API Base URL: http://localhost:8000
Debug Mode: True
==================================================

tests/test_with_dotenv.py::test_env_vars_loaded PASSED
tests/test_with_dotenv.py::test_api_with_dotenv_config PASSED
```

---

## D. Common Stumbling Blocks

### Mistake #1: .env file not in the right location

**The Problem:**

```
$ python tests/test_api.py
KeyError: 'API_KEY'
# But the .env file exists!
```

**Root Cause:**

`load_dotenv()` looks for `.env` in the current working directory. If you run scripts from a subdirectory, it won't find the .env file in the project root.

**The Fix:**

```python
# âŒ FRAGILE: Only works if run from project root
load_dotenv()

# âœ… ROBUST: Find .env in current or parent directories
from dotenv import find_dotenv
load_dotenv(find_dotenv())

# âœ… EXPLICIT: Specify path relative to this file
from pathlib import Path
env_path = Path(__file__).parent.parent / ".env"
load_dotenv(dotenv_path=env_path)
```

---

### Mistake #2: load_dotenv() doesn't override existing env vars

**The Problem:**

```bash
export API_KEY="from_shell"

# In Python:
load_dotenv()  # .env has API_KEY="from_file"
print(os.getenv("API_KEY"))
# Output: "from_shell" (not "from_file")
```

**Why It Happens:**

By default, `load_dotenv()` respects existing environment variables. This is a security feature - it prevents .env files from overriding system/CI configuration.

**The Fix:**

```python
# If you really want .env to override (rare):
load_dotenv(override=True)

# But usually, the default behavior is what you want:
# - CI sets env vars (takes precedence)
# - .env fills in missing vars (convenience)
```

---

### Mistake #3: Forgetting to .gitignore the .env file

**The Problem:**

```bash
$ git add .
$ git commit -m "Add configuration"
$ git push

# GitHub Security Alert: Secrets detected in repository!
```

**The Fix:**

Create `.gitignore` immediately:

```bash
cat > .gitignore << 'EOF'
# Environment files with secrets
.env
.env.local
.env.*.local
.env.development
.env.staging
.env.production

# Only .env.example should be committed
!.env.example

# Python
__pycache__/
*.pyc
.pytest_cache/

# IDE
.vscode/
.idea/
*.swp
EOF

git add .gitignore
git commit -m "Add .gitignore for secrets"
```

---

### Mistake #4: Calling load_dotenv() multiple times

**The Problem:**

```python
# module_a.py
load_dotenv()

# module_b.py  
load_dotenv()

# test_file.py
load_dotenv()

# Inefficient: Loading .env file multiple times
```

**Why It Matters:**

Each `load_dotenv()` call reads and parses the .env file. In a test suite with hundreds of tests, this adds unnecessary overhead.

**The Fix:**

```python
# conftest.py (runs once for all tests)
load_dotenv()

# Now all test files have env vars, no need to load again

# Or use a module-level singleton:
_env_loaded = False

def load_env_once():
    global _env_loaded
    if not _env_loaded:
        load_dotenv()
        _env_loaded = True
```

---

## ðŸŽ¯ Key Takeaways

âœ… **python-dotenv** loads `.env` files into environment variables automatically  
âœ… **Install with** `pip install python-dotenv`  
âœ… **Use** `load_dotenv()` at application startup (conftest.py for pytest)  
âœ… **Existing env vars** take precedence over .env (security feature)  
âœ… **Use** `find_dotenv()` to search parent directories automatically  
âœ… **Always .gitignore** `.env` files (commit `.env.example` instead)  
âœ… **Load once** in conftest.py for all tests (efficient)  

---

## What's Next?

Now that you can load environment variables effortlessly, the next lesson will show you how to **create `.env` files** with proper structure, naming conventions, and best practices!

**Ready to continue?** ðŸš€
