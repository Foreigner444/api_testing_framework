# Lesson 5.8: Environment Specific .env Files

## A. Concept Overview

### What & Why
**Environment-specific .env files** are separate configuration files for each deployment environment (development, staging, production). They're essential because each environment requires different settingsâ€”local development uses localhost, staging uses test servers, and production uses live infrastructure with real credentials.

### Analogy
Think of environment-specific .env files like having different outfits for different occasions. You have casual clothes for home (.env.development), business attire for work (.env.staging), and formal wear for special events (.env.production). Same person (same codebase), but dressed appropriately for each context (configured for each environment).

---

## B. Code Implementation

### Creating Environment-Specific Files

**File Path:** `.env.development`

```bash
# Development Environment - Local Testing
API_BASE_URL=http://localhost:8000
API_KEY=dev_key_safe_for_local
API_TIMEOUT=10
DATABASE_URL=postgresql://localhost:5432/test_db
REDIS_URL=redis://localhost:6379/0
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG
```

**File Path:** `.env.staging`

```bash
# Staging Environment - Pre-Production Testing
API_BASE_URL=https://api.staging.example.com
API_KEY=staging_key_abc123
API_TIMEOUT=20
DATABASE_URL=postgresql://staging-db.example.com:5432/staging_db
REDIS_URL=redis://staging-redis.example.com:6379/0
ENVIRONMENT=staging
DEBUG=false
LOG_LEVEL=INFO
```

**File Path:** `.env.production`

```bash
# Production Environment - Live System
# NEVER commit this file to git
API_BASE_URL=https://api.example.com
API_KEY=prod_key_secret_real_credentials
API_TIMEOUT=30
DATABASE_URL=postgresql://prod-db.example.com:5432/prod_db
REDIS_URL=redis://prod-redis.example.com:6379/0
ENVIRONMENT=production
DEBUG=false
LOG_LEVEL=WARNING
```

---

### Loading Environment-Specific Files

**File Path:** `config/env_loader.py`

```python
import os
from pathlib import Path
from dotenv import load_dotenv


def load_environment_config():
    """
    Load the appropriate .env file based on ENVIRONMENT variable.
    """
    # Get environment name (default to development)
    environment = os.getenv("ENVIRONMENT", "development")
    
    # Determine which .env file to load
    env_file = Path(f".env.{environment}")
    
    if env_file.exists():
        print(f"Loading configuration for: {environment}")
        print(f"From file: {env_file}")
        load_dotenv(dotenv_path=env_file)
    else:
        print(f"Warning: {env_file} not found")
        print("Falling back to .env")
        load_dotenv()
    
    return environment


# Load at import time
current_env = load_environment_config()
```

**File Path:** `conftest.py`

```python
from config.env_loader import load_environment_config

# Load environment-specific configuration
load_environment_config()
```

---

### Switching Between Environments

**File Path:** `scripts/run_tests.sh`

```bash
#!/bin/bash

# Run tests against different environments

echo "Select environment:"
echo "1) Development (local)"
echo "2) Staging"
echo "3) Production (read-only tests only!)"
read -p "Choice: " choice

case $choice in
    1)
        export ENVIRONMENT=development
        echo "Running tests against DEVELOPMENT"
        ;;
    2)
        export ENVIRONMENT=staging
        echo "Running tests against STAGING"
        ;;
    3)
        export ENVIRONMENT=production
        echo "Running READ-ONLY tests against PRODUCTION"
        pytest tests/ -m "readonly"
        exit 0
        ;;
    *)
        echo "Invalid choice"
        exit 1
        ;;
esac

pytest tests/ -v
```

---

## C. Connect & Apply

### How to Test It

1. **Create all environment files:**

```bash
# Development
cat > .env.development << 'EOF'
API_BASE_URL=http://localhost:8000
API_KEY=dev_key
ENVIRONMENT=development
DEBUG=true
EOF

# Staging  
cat > .env.staging << 'EOF'
API_BASE_URL=https://api.staging.example.com
API_KEY=staging_key
ENVIRONMENT=staging
DEBUG=false
EOF
```

2. **Test with development:**

```bash
export ENVIRONMENT=development
pytest tests/ -v
```

3. **Test with staging:**

```bash
export ENVIRONMENT=staging
pytest tests/ -v
```

### Expected Result

```
# With ENVIRONMENT=development
Loading configuration for: development
From file: .env.development
API_BASE_URL: http://localhost:8000

# With ENVIRONMENT=staging
Loading configuration for: staging
From file: .env.staging
API_BASE_URL: https://api.staging.example.com
```

---

## D. Common Stumbling Blocks

### Mistake #1: Committing production .env files

**The Problem:**
```bash
git add .
# Accidentally commits .env.production with real credentials
```

**The Fix:**

```bash
# .gitignore
.env.*
!.env.*.example
```

---

### Mistake #2: Wrong environment selected

**The Problem:**
Running tests against production when you meant development.

**The Fix:**

```bash
# Always verify before running
echo "Current environment: $ENVIRONMENT"
echo "API URL: $(grep API_BASE_URL .env.$ENVIRONMENT)"
read -p "Proceed? (y/N): " confirm
```

---

## ðŸŽ¯ Key Takeaways

âœ… **One .env file per environment** - .env.development, .env.staging, .env.production  
âœ… **Never commit production files** - add to .gitignore  
âœ… **Use ENVIRONMENT variable** to select which file to load  
âœ… **Validate before running** - confirm you're targeting the right environment  
âœ… **Document differences** - comment why each environment differs  

---

## What's Next?

Next lesson covers **.env file naming conventions and precedence** - the complete rules for which files load in which order!

**Ready to continue?** ðŸš€
