# Lesson 5.3: The 12-Factor App Configuration

## A. Concept Overview

### What & Why
**The 12-Factor App** is a methodology for building modern, cloud-native applications developed by Heroku in 2011. Factor III specifically addresses configuration: "Store config in the environment." This principle states that configuration should be stored in environment variables, not in code, making your application portable across environments without code changes.

### Analogy
Think of your test framework like a smartphone app. The app (code) is the same whether you download it in the US, UK, or Japan. But it automatically adapts to your location, language, and settings (environment). You don't need different versions of Instagram for different countries - one app, configured differently based on environment. That's 12-Factor configuration: one codebase, many deployments.

---

## B. Code Implementation

### The 12-Factor Approach to Configuration

**What Belongs in Configuration (Environment Variables):**

âœ… **Resource handles to backing services:**
- Database URLs and credentials
- API endpoints and base URLs
- Cache servers (Redis, Memcached)
- Message queues
- External service URLs

âœ… **Credentials and secrets:**
- API keys and tokens
- OAuth client IDs and secrets
- Database passwords
- Encryption keys

âœ… **Per-environment values:**
- Hostnames and ports
- Feature flags
- Timeout values
- Retry counts
- Log levels

âŒ **What Does NOT Belong in Configuration:**
- Business logic
- Code behavior
- Algorithms
- Internal constants that never change

---

### Example: 12-Factor Compliant Configuration

**File Path:** `config/settings.py`

```python
from pydantic_settings import BaseSettings
from typing import Optional


class Settings(BaseSettings):
    """
    12-Factor App compliant configuration.
    
    All values are loaded from environment variables.
    This class can be instantiated in any environment
    (dev, staging, production, CI/CD) without code changes.
    """
    
    # API Configuration (Factor III: Config in environment)
    api_base_url: str  # Required: Must be provided via env var
    api_key: str       # Required: Must be provided via env var
    api_timeout: int = 30  # Optional: Has sensible default
    
    # Database Configuration (Factor IV: Backing services)
    database_url: str
    database_pool_size: int = 10
    
    # Redis Configuration (Factor IV: Backing services)
    redis_url: Optional[str] = None  # Optional backing service
    
    # Application Settings
    environment: str = "development"  # dev, staging, production
    debug: bool = False
    log_level: str = "INFO"
    
    # Feature Flags (Factor X: Dev/prod parity)
    feature_async_tests: bool = True
    feature_retry_logic: bool = False
    
    # External Services
    slack_webhook_url: Optional[str] = None
    
    class Config:
        # Load from .env file if present (local development)
        env_file = ".env"
        env_file_encoding = "utf-8"
        # Environment variables take precedence over .env file
        case_sensitive = False


# Singleton pattern - load once
_settings: Optional[Settings] = None


def get_settings() -> Settings:
    """
    Get cached settings instance.
    
    Settings are loaded once and reused throughout the application.
    This is efficient and ensures consistency.
    """
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings
```

---

### 12-Factor in Practice: Different Environments, Same Code

**File Path:** `.env.development` (Local development)

```bash
# Development Environment
# Use local services, safe test credentials, verbose logging

API_BASE_URL=http://localhost:8000
API_KEY=dev_key_12345_safe_to_commit_in_example
API_TIMEOUT=10

DATABASE_URL=postgresql://dev_user:dev_pass@localhost:5432/test_db
DATABASE_POOL_SIZE=5

REDIS_URL=redis://localhost:6379/0

ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG

FEATURE_ASYNC_TESTS=true
FEATURE_RETRY_LOGIC=false

# No Slack notifications in dev
SLACK_WEBHOOK_URL=
```

**File Path:** `.env.staging` (Staging environment)

```bash
# Staging Environment
# Production-like setup with staging credentials

API_BASE_URL=https://api.staging.example.com
API_KEY=staging_key_abc123
API_TIMEOUT=20

DATABASE_URL=postgresql://staging_user:staging_pass@staging-db.example.com:5432/staging_db
DATABASE_POOL_SIZE=20

REDIS_URL=redis://staging-redis.example.com:6379/0

ENVIRONMENT=staging
DEBUG=false
LOG_LEVEL=INFO

FEATURE_ASYNC_TESTS=true
FEATURE_RETRY_LOGIC=true

SLACK_WEBHOOK_URL=https://hooks.slack.com/services/STAGING/CHANNEL
```

**File Path:** CI/CD (GitHub Actions) - Set as encrypted secrets

```yaml
# .github/workflows/test.yml
name: Run Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    env:
      # 12-Factor: Config comes from environment
      API_BASE_URL: https://api.test.example.com
      API_KEY: ${{ secrets.TEST_API_KEY }}  # Encrypted secret
      API_TIMEOUT: 15
      
      DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
      DATABASE_POOL_SIZE: 10
      
      ENVIRONMENT: ci
      DEBUG: false
      LOG_LEVEL: INFO
      
      FEATURE_ASYNC_TESTS: true
      FEATURE_RETRY_LOGIC: true
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      
      - name: Run tests
        run: |
          pytest tests/ -v
          # Same code, different config via env vars!
```

---

### Using 12-Factor Config in Tests

**File Path:** `tests/test_api_12factor.py`

```python
import httpx
import pytest
from config.settings import get_settings


@pytest.fixture(scope="session")
def settings():
    """
    Load settings once per test session.
    
    The same fixture works in all environments because
    settings come from environment variables.
    """
    return get_settings()


@pytest.fixture(scope="session")
def api_client(settings):
    """
    Create httpx client configured from settings.
    
    This client automatically adapts to any environment
    without code changes.
    """
    client = httpx.Client(
        base_url=settings.api_base_url,
        headers={"Authorization": f"Bearer {settings.api_key}"},
        timeout=settings.api_timeout
    )
    yield client
    client.close()


def test_api_connection(api_client, settings):
    """
    Test API connectivity.
    
    This test works in dev (localhost), staging, production, and CI
    because all config comes from the environment.
    """
    response = api_client.get("/health")
    assert response.status_code == 200
    
    # Verify we're testing the right environment
    print(f"Testing against: {settings.api_base_url}")
    print(f"Environment: {settings.environment}")


def test_with_feature_flag(settings):
    """
    Feature flags allow different behavior per environment.
    """
    if settings.feature_retry_logic:
        # Staging/production behavior
        max_retries = 3
    else:
        # Development behavior - fail fast
        max_retries = 0
    
    assert max_retries >= 0


def test_debug_mode_off_in_production(settings):
    """
    Safety check: Debug mode must be off in production.
    """
    if settings.environment == "production":
        assert settings.debug is False, "Debug mode must be disabled in production!"
```

---

### Line-by-Line Explanation

**In `settings.py`:**

- `class Settings(BaseSettings)`: Inherits from pydantic-settings, which auto-loads from environment variables
- `api_base_url: str`: Required field (no default) - will fail if not provided
- `api_timeout: int = 30`: Optional field with default - environment var overrides if provided
- `Optional[str] = None`: Truly optional services (like Redis) that may not exist in all environments
- `env_file = ".env"`: Load from .env file if present (local dev convenience)
- `case_sensitive = False`: API_KEY, api_key, Api_Key all work (forgiving)
- `get_settings()`: Singleton pattern - load once, reuse everywhere for efficiency

**In environment files:**

- No Python code, just key=value pairs
- Different files for different environments
- Only .env.example committed to git
- Actual .env files are in .gitignore

**In tests:**

- Tests never import configuration values directly
- Everything goes through `settings` fixture
- Same test code runs in all environments
- Feature flags enable/disable behavior per environment

---

### The "Why" Behind the Code

**Why 12-Factor Configuration Matters:**

1. **Portability**: Deploy the same code to laptop, staging, production without changes
2. **Security**: Secrets never in code, only in environment/secret managers
3. **Scalability**: Easy to add new environments (QA, UAT, etc.)
4. **Team Collaboration**: Each developer has their own .env.development
5. **CI/CD Friendly**: GitHub Actions, Jenkins, etc. just set environment variables
6. **Cloud Native**: Works seamlessly with Docker, Kubernetes, AWS, Azure
7. **No Accidents**: Can't accidentally run tests against production (different env vars)

**Industry Adoption:**

- Used by Heroku, AWS, Azure, Google Cloud
- Standard for containerized applications (Docker)
- Required for Kubernetes deployments
- Expected in all modern frameworks (Django, Flask, FastAPI)
- Best practice in test automation frameworks

---

## C. Connect & Apply

### How to Test It

1. **Create the configuration structure:**

```bash
mkdir -p config
touch config/__init__.py
# Create the settings.py from above
```

2. **Create a development environment file:**

```bash
# .env.development
cat > .env.development << 'EOF'
API_BASE_URL=http://localhost:8000
API_KEY=dev_key_safe
API_TIMEOUT=10
DATABASE_URL=postgresql://localhost/test_db
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG
FEATURE_ASYNC_TESTS=true
FEATURE_RETRY_LOGIC=false
EOF
```

3. **Test loading configuration:**

```bash
# Install dependencies first
pip install pydantic-settings python-dotenv

# Copy .env.development to .env for local testing
cp .env.development .env

# Test loading settings
python -c "
from config.settings import get_settings
s = get_settings()
print(f'Environment: {s.environment}')
print(f'API URL: {s.api_base_url}')
print(f'Debug: {s.debug}')
"
```

4. **Test environment switching:**

```bash
# Use staging config
cp .env.staging .env
pytest tests/ -v

# Use dev config
cp .env.development .env
pytest tests/ -v

# Same code, different behavior!
```

### Expected Result

```
$ python -c "from config.settings import get_settings; s = get_settings(); print(f'{s.environment}: {s.api_base_url}')"
development: http://localhost:8000

$ API_BASE_URL=https://production.example.com ENVIRONMENT=production python -c "from config.settings import get_settings; s = get_settings(); print(f'{s.environment}: {s.api_base_url}')"
production: https://production.example.com

# Notice: Environment variable overrides .env file!
```

---

## D. Common Stumbling Blocks

### Mistake #1: "I need different code for different environments"

**The Problem:**
Beginners create separate test files or use if/else for environment-specific logic:

```python
# âŒ WRONG: Environment-specific code
if os.getenv("ENV") == "production":
    from config.prod_settings import settings
elif os.getenv("ENV") == "staging":
    from config.staging_settings import settings
else:
    from config.dev_settings import settings
```

**The Fix:**
You need different **configuration**, not different code. One Settings class, different environment variables:

```python
# âœ… RIGHT: One class, environment provides values
from config.settings import get_settings
settings = get_settings()  # Works everywhere
```

---

### Mistake #2: "Environment variables are hard to manage locally"

**The Problem:**
Developers avoid environment variables because typing `export API_KEY=...` before every test session is annoying.

**Error You'll See:**
```bash
$ pytest tests/
ValidationError: 1 validation error for Settings
api_key
  field required (type=value_error.missing)
```

**The Fix:**
Use `.env` files for local development convenience:

```bash
# .env (local development only, gitignored)
API_KEY=dev_key
DATABASE_URL=postgresql://localhost/test_db

# Now just run tests:
pytest tests/  # Settings auto-load from .env
```

The 12-Factor methodology allows .env files for dev convenience while requiring true environment variables in production. Best of both worlds!

---

### Mistake #3: "My tests pass locally but fail in CI"

**The Problem:**
Tests work on your laptop but fail in GitHub Actions or Jenkins.

**Error in CI:**
```
FAILED tests/test_api.py::test_connection - ValidationError: field required: api_key
```

**Root Cause:**
Your .env file is gitignored (correct!), so CI doesn't have it. CI needs environment variables set in the pipeline.

**The Fix:**

```yaml
# .github/workflows/test.yml
env:
  API_KEY: ${{ secrets.API_KEY }}
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  # All required config as environment variables
```

This is actually a feature, not a bug! It forces you to explicitly configure CI, which is more secure than committing a .env file.

---

### Mistake #4: "I set environment variables but pydantic isn't loading them"

**The Problem:**
```bash
export API_BASE_URL=http://localhost:8000
pytest tests/
# Still getting: field required: api_base_url
```

**Root Cause:**
Field name mismatch. Pydantic looks for exact or uppercase matches by default.

**The Fix:**

```python
# In Settings class:
class Config:
    case_sensitive = False  # api_base_url matches API_BASE_URL
    
    # Or use explicit environment variable names:
    env_prefix = "APP_"  # Now looks for APP_API_BASE_URL
```

Or set the exact name:
```bash
export API_BASE_URL=http://localhost:8000  # Uppercase
# or
export api_base_url=http://localhost:8000  # Lowercase (if case_sensitive=False)
```

---

## ðŸŽ¯ Key Takeaways

âœ… **12-Factor App** is the industry standard for configuration management  
âœ… **Store config in environment variables**, not in code  
âœ… **One codebase, many deploys** - same code works everywhere  
âœ… **Use .env files** for local dev convenience, true env vars in production/CI  
âœ… **pydantic-settings** makes 12-Factor effortless with Python  
âœ… **Configuration is external** to code - change config without changing code  

---

## What's Next?

Now that you understand the principles, we'll dive deep into **Environment Variables** in the next lesson - how they work, how to set them, and how to use them effectively.

**Ready to continue?** ðŸš€
