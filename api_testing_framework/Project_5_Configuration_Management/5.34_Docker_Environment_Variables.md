# Lesson 5.34: Docker Environment Variables

## A. Concept Overview

### What & Why
**Docker environment variable configuration** manages settings in containerized applications, ensuring tests in Docker containers receive proper configuration. Essential for consistent environmentsâ€”containers provide isolation, env vars provide configuration.

### Analogy
Docker containers with env vars are like shipping containers with labels. The container (Docker) is standardized and portable, while labels (env vars) tell handlers what's inside and how to handle it. Same container works everywhere, different labels for different contents.

---

## B. Code Implementation

### Dockerfile with Configuration

**File Path:** `Dockerfile`

```dockerfile
FROM python:3.10-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Environment variables with defaults
ENV PYTHONUNBUFFERED=1
ENV ENVIRONMENT=development
ENV LOG_LEVEL=INFO

# Run tests
CMD ["pytest", "tests/", "-v"]
```

---

### Docker Compose with Environment Files

**File Path:** `docker-compose.yml`

```yaml
version: '3.8'

services:
  test-runner:
    build: .
    environment:
      # Inline environment variables
      ENVIRONMENT: ${ENVIRONMENT:-development}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    
    env_file:
      # Load from .env file
      - .env.development
    
    volumes:
      - ./tests:/app/tests
      - ./config:/app/config
    
    command: pytest tests/ -v

  test-runner-staging:
    build: .
    env_file:
      - .env.staging
    command: pytest tests/ -v --env=staging

  database:
    image: postgres:15
    environment:
      POSTGRES_DB: ${DB_NAME:-testdb}
      POSTGRES_USER: ${DB_USER:-testuser}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-testpass}
    ports:
      - "5432:5432"
```

---

### Passing Environment Variables to Docker

```bash
# Method 1: Command line
docker run -e API_KEY=test123 -e ENVIRONMENT=dev my-test-image

# Method 2: Environment file
docker run --env-file .env.development my-test-image

# Method 3: Docker Compose
docker-compose --env-file .env.staging up

# Method 4: Inline with docker-compose
API_KEY=test123 ENVIRONMENT=dev docker-compose up
```

---

### Reading Env Vars in Containerized Tests

**File Path:** `config/docker_settings.py`

```python
from pydantic_settings import BaseSettings


class DockerSettings(BaseSettings):
    """Settings for Dockerized application."""
    
    # Application settings
    api_base_url: str
    api_key: str
    
    # Docker-specific
    container_name: str = "test-container"
    host_port: int = 8000
    
    # Database (from linked container)
    database_host: str = "database"  # Service name in docker-compose
    database_port: int = 5432


# Environment variables automatically loaded
settings = DockerSettings()
```

---

## C. Connect & Apply

### Running Tests in Docker

```bash
# Build image
docker build -t api-tests .

# Run with environment variables
docker run \
  -e API_BASE_URL=http://api:8000 \
  -e API_KEY=test_key \
  -e DATABASE_URL=postgresql://db:5432/testdb \
  api-tests

# Or with docker-compose
docker-compose up test-runner
```

### Expected Output

```
test-runner_1  | Testing against: http://api:8000
test-runner_1  | Environment: development
test-runner_1  | tests/test_api.py::test_health PASSED
```

---

## D. Common Stumbling Blocks

**Mistake:** .env file not copied to Docker image
**Fix:** Use `--env-file` or mount volume

---

## ðŸŽ¯ Key Takeaways

âœ… **ENV in Dockerfile** for defaults  
âœ… **-e flag** for runtime overrides  
âœ… **--env-file** for bulk loading  
âœ… **docker-compose.yml** for multi-container setup  
âœ… **Service names** as hostnames in Docker networks  

---

## What's Next?

Next: **Configuration Testing Strategies**!

**Ready to continue?** ðŸš€
