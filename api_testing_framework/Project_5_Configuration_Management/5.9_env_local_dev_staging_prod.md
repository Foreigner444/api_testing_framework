# Lesson 5.9: .env File Naming Conventions and Precedence

## A. Concept Overview

### What & Why
**Environment file naming conventions and precedence rules** define which .env files are loaded and in what order, ensuring consistent and predictable configuration behavior. Understanding precedence is critical because multiple .env files can exist, and knowing which values "win" prevents configuration bugs.

### Analogy
Think of .env file precedence like CSS specificity. Just as inline styles override class styles, which override element styles, environment-specific files override general files. The most specific configuration (system env vars) always wins, followed by local overrides (.local files), then environment files, then general defaults.

---

## B. Code Implementation

### Standard .env File Naming Convention

```
Project Root/
â”œâ”€â”€ .env                      # Base configuration (committed as .env.example)
â”œâ”€â”€ .env.local                # Local overrides (never commit)
â”œâ”€â”€ .env.development          # Development environment
â”œâ”€â”€ .env.development.local    # Personal dev overrides (never commit)
â”œâ”€â”€ .env.staging              # Staging environment
â”œâ”€â”€ .env.staging.local        # Personal staging overrides (never commit)
â”œâ”€â”€ .env.production           # Production environment (never commit)
â”œâ”€â”€ .env.production.local     # Production overrides (never commit)
â”œâ”€â”€ .env.test                 # Test/CI environment
â””â”€â”€ .env.example              # Template (safe to commit)
```

---

### Loading Precedence (Highest to Lowest)

**Priority Order:**

1. **System Environment Variables** (highest priority)
2. **`.env.{ENVIRONMENT}.local`** (e.g., .env.development.local)
3. **`.env.{ENVIRONMENT}`** (e.g., .env.development)
4. **`.env.local`**
5. **`.env`** (lowest priority)

---

### Implementation with Precedence

**File Path:** `config/env_loader.py`

```python
import os
from pathlib import Path
from dotenv import load_dotenv
from typing import List


class EnvironmentLoader:
    """
    Loads .env files following precedence rules.
    
    Precedence (highest to lowest):
    1. System environment variables
    2. .env.{ENVIRONMENT}.local
    3. .env.{ENVIRONMENT}
    4. .env.local
    5. .env
    """
    
    def __init__(self, base_dir: Path = None):
        self.base_dir = base_dir or Path.cwd()
        self.environment = os.getenv("ENVIRONMENT", "development")
        self.loaded_files: List[Path] = []
    
    def get_env_files(self) -> List[Path]:
        """
        Get list of .env files in loading order (lowest to highest precedence).
        Files are loaded in this order, with later files potentially overriding earlier ones.
        """
        return [
            self.base_dir / ".env",                                    # Lowest priority
            self.base_dir / ".env.local",
            self.base_dir / f".env.{self.environment}",
            self.base_dir / f".env.{self.environment}.local",          # Highest priority (file)
            # System env vars have highest priority (not a file)
        ]
    
    def load(self, override: bool = False) -> None:
        """
        Load environment files in order.
        
        Args:
            override: If False (default), only sets vars not already set.
                     If True, override existing values.
        """
        env_files = self.get_env_files()
        
        print(f"Loading configuration for environment: {self.environment}")
        print("Checking files in order (lowest to highest precedence):")
        
        for env_file in env_files:
            if env_file.exists():
                print(f"  âœ“ Loading: {env_file.name}")
                load_dotenv(dotenv_path=env_file, override=override)
                self.loaded_files.append(env_file)
            else:
                print(f"  âœ— Skipping: {env_file.name} (not found)")
        
        print(f"\nLoaded {len(self.loaded_files)} file(s)")
        print(f"System environment variables take precedence over all files\n")
    
    def show_precedence_example(self, var_name: str) -> None:
        """
        Demonstrate which file provides a variable's value.
        """
        print(f"\nPrecedence check for: {var_name}")
        print(f"Final value: {os.getenv(var_name, '<not set>')}\n")
        
        # Check each file in reverse order (highest precedence first)
        for env_file in reversed(self.loaded_files):
            # Read file and check if var is defined
            if env_file.exists():
                with open(env_file) as f:
                    for line in f:
                        if line.strip().startswith(f"{var_name}="):
                            value = line.strip().split('=', 1)[1]
                            print(f"  {env_file.name}: {var_name}={value}")


def load_with_precedence() -> EnvironmentLoader:
    """Convenience function to load environment with precedence."""
    loader = EnvironmentLoader()
    loader.load()
    return loader
```

---

### Example: Precedence in Action

**File Path:** `.env`

```bash
# Base configuration - shared defaults
API_BASE_URL=http://localhost:3000
API_TIMEOUT=30
LOG_LEVEL=INFO
```

**File Path:** `.env.development`

```bash
# Development-specific
API_BASE_URL=http://localhost:8000
LOG_LEVEL=DEBUG
```

**File Path:** `.env.development.local`

```bash
# Your personal overrides
API_BASE_URL=http://localhost:9000
```

**Result when loaded:**

```python
import os
from config.env_loader import load_with_precedence

load_with_precedence()

print(f"API_BASE_URL: {os.getenv('API_BASE_URL')}")     # http://localhost:9000 (from .local)
print(f"LOG_LEVEL: {os.getenv('LOG_LEVEL')}")           # DEBUG (from .development)
print(f"API_TIMEOUT: {os.getenv('API_TIMEOUT')}")       # 30 (from .env)
```

---

### .gitignore Configuration

**File Path:** `.gitignore`

```bash
# Environment files with secrets
.env.local
.env.*.local
.env.development
.env.staging
.env.production

# These should be committed (examples/templates)
!.env.example
!.env.development.example
!.env.staging.example
!.env.production.example

# Generic .env protection
.env

# BUT allow .env if it's just examples
# (Some teams commit .env with dummy values)
```

---

## C. Connect & Apply

### How to Test It

1. **Create multiple .env files:**

```bash
# Base
echo "API_TIMEOUT=30" > .env
echo "LOG_LEVEL=INFO" >> .env

# Development
echo "API_BASE_URL=http://localhost:8000" > .env.development
echo "LOG_LEVEL=DEBUG" >> .env.development

# Development local (your personal override)
echo "API_BASE_URL=http://localhost:9000" > .env.development.local
```

2. **Test precedence:**

```bash
python -c "
from config.env_loader import load_with_precedence
import os

loader = load_with_precedence()
print(f'\\nFinal values:')
print(f'  API_BASE_URL: {os.getenv(\"API_BASE_URL\")}')
print(f'  LOG_LEVEL: {os.getenv(\"LOG_LEVEL\")}')
print(f'  API_TIMEOUT: {os.getenv(\"API_TIMEOUT\")}')

loader.show_precedence_example('API_BASE_URL')
"
```

### Expected Result

```
Loading configuration for environment: development
Checking files in order (lowest to highest precedence):
  âœ“ Loading: .env
  âœ— Skipping: .env.local (not found)
  âœ“ Loading: .env.development
  âœ“ Loading: .env.development.local

Loaded 3 file(s)
System environment variables take precedence over all files

Final values:
  API_BASE_URL: http://localhost:9000     # From .local (highest precedence)
  LOG_LEVEL: DEBUG                         # From .development
  API_TIMEOUT: 30                          # From .env (only place it's defined)

Precedence check for: API_BASE_URL
Final value: http://localhost:9000

  .env.development.local: API_BASE_URL=http://localhost:9000
  .env.development: API_BASE_URL=http://localhost:8000
  .env: API_BASE_URL=http://localhost:3000
```

---

## D. Common Stumbling Blocks

### Mistake #1: Not understanding .local files

**The Problem:**
Team members overwrite shared .env.development with personal values, causing conflicts.

**The Fix:**
Use `.env.development.local` for personal overrides:

```bash
# Shared (committed)
.env.development

# Personal (gitignored, each developer has their own)
.env.development.local
```

---

### Mistake #2: Loading files in wrong order

**The Problem:**

```python
# âŒ WRONG: Loading high precedence first means low precedence overrides it
load_dotenv(".env.development.local")
load_dotenv(".env.development")  # This overwrites .local values!
```

**The Fix:**

```python
# âœ… RIGHT: Load low to high precedence
# Later loads don't override by default (override=False)
load_dotenv(".env")
load_dotenv(".env.local")
load_dotenv(".env.development")
load_dotenv(".env.development.local")
```

---

### Mistake #3: Forgetting system env vars have highest precedence

**The Problem:**

```bash
export API_BASE_URL=http://production.example.com

# Python loads .env.development
load_dotenv(".env.development")  # Has API_BASE_URL=http://localhost

# But you're still using production URL!
print(os.getenv("API_BASE_URL"))  # http://production.example.com
```

**Why:** System environment variables are never overridden by .env files (by design, for security).

**The Fix:**
Be aware of system env vars:

```python
# Check what's set before loading
if "API_BASE_URL" in os.environ:
    print(f"Warning: API_BASE_URL already set to {os.getenv('API_BASE_URL')}")
    print("This will not be overridden by .env files")
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Precedence order:** System env > .{ENV}.local > .{ENV} > .local > .env  
âœ… **.local files** are for personal overrides (never commit)  
âœ… **Load files** from lowest to highest precedence  
âœ… **System environment variables** always win  
âœ… **Document your conventions** in README and .env.example  
âœ… **Use specific over general** - more specific files override general ones  

---

## What's Next?

Next lesson: **gitignore for Secret Management** - protecting sensitive configuration from version control!

**Ready to continue?** ðŸš€
