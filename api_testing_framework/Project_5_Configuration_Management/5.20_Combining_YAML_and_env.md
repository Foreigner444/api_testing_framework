# Lesson 5.20: Combining YAML and .env

## A. Concept Overview

### What & Why
**Hybrid YAML + environment variable approach** provides readable defaults in YAML files with secure overrides via environment variables. Essential pattern for production deployments where defaults are version-controlled but secrets come from environment.

### Analogy
Like a car with factory settings (YAML) that you personalize (env vars). Everyone gets same car model, but you adjust seat position, mirrors, radio presets to your preference.

---

## B. Code Implementation

```python
from pathlib import Path
from pydantic_settings import BaseSettings, SettingsConfigDict
import yaml


class Settings(BaseSettings):
    api_key: str
    database_url: str
    timeout: int = 30
    debug: bool = False
    
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False
    )
    
    @classmethod
    def from_yaml_with_env(cls, yaml_path: Path):
        # Load YAML as base
        with open(yaml_path) as f:
            yaml_data = yaml.safe_load(f)
        
        # Pydantic overlays env vars on top
        return cls(**yaml_data)


# config.yaml (version-controlled defaults):
# api_key: default_key
# database_url: postgresql://localhost/db
# timeout: 30

# .env (gitignored secrets):
# API_KEY=production_secret
# DEBUG=false

settings = Settings.from_yaml_with_env(Path("config.yaml"))
```

---

## C. Connect & Apply

Create both `config.yaml` and `.env`, test precedence.

### Expected Result

```
API Key: production_secret  # From .env
Timeout: 30  # From YAML
```

---

## D. Common Stumbling Blocks

### Mistake: Expecting YAML to override env vars

**Fix:** Environment variables ALWAYS have highest priority

---

## ðŸŽ¯ Key Takeaways

âœ… **YAML** for version-controlled defaults  
âœ… **.env** for secret overrides  
âœ… **Env vars always win**  
âœ… **Production best practice**  

---

## What's Next?

Next: **Environment Variable Precedence**!

**Ready to continue?** ðŸš€
