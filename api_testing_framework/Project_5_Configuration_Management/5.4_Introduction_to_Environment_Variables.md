# Lesson 5.4: Introduction to Environment Variables

## A. Concept Overview

### What & Why
**Environment variables** are dynamic key-value pairs that exist in your operating system's environment and can be accessed by any running process. They're important for test frameworks because they allow you to configure behavior without changing code, making your tests portable across different machines, environments, and CI/CD systems.

### Analogy
Think of environment variables like the weather outside. Your house (your code) is the same, but you dress differently (configure differently) based on the weather (environment). On a sunny day (development), you wear a t-shirt (minimal security, fast timeouts). On a rainy day (production), you wear a raincoat (proper credentials, longer timeouts). The house doesn't change, but your behavior adapts to the environment.

---

## B. Code Implementation

### Understanding Environment Variables

**How Environment Variables Work:**

```
Your Shell (bash/zsh/cmd)
    ‚Üì Sets environment variables
Your Terminal Session
    ‚Üì Inherits environment
Python Process
    ‚Üì Accesses via os.environ
Your Test Framework
```

---

### Accessing Environment Variables in Python

**File Path:** `examples/env_basics.py`

```python
import os
from typing import Optional


def basic_env_access():
    """
    Basic ways to access environment variables in Python.
    """
    
    # Method 1: os.environ dictionary (raises KeyError if not found)
    try:
        api_key = os.environ["API_KEY"]
        print(f"API Key found: {api_key}")
    except KeyError:
        print("API_KEY environment variable not set!")
    
    # Method 2: os.environ.get() with default (safe, never raises)
    api_key = os.environ.get("API_KEY", "default_key")
    print(f"API Key: {api_key}")
    
    # Method 3: os.getenv() - same as os.environ.get()
    api_key = os.getenv("API_KEY", "default_key")
    print(f"API Key: {api_key}")
    
    # Checking if variable exists
    if "API_KEY" in os.environ:
        print("API_KEY is set")
    else:
        print("API_KEY is not set")


def working_with_env_types():
    """
    Environment variables are always strings.
    You must convert them to other types.
    """
    
    # ‚ùå WRONG: This is a string "True", not boolean True
    debug = os.getenv("DEBUG", "False")
    if debug:  # This is always True because non-empty strings are truthy!
        print("Debug mode")
    
    # ‚úÖ RIGHT: Convert string to boolean
    debug_str = os.getenv("DEBUG", "False")
    debug = debug_str.lower() in ("true", "1", "yes", "on")
    if debug:
        print("Debug mode ON")
    
    # ‚úÖ RIGHT: Convert string to integer
    timeout_str = os.getenv("TIMEOUT", "30")
    timeout = int(timeout_str)
    print(f"Timeout: {timeout} seconds")
    
    # ‚úÖ RIGHT: Convert string to float
    retry_delay_str = os.getenv("RETRY_DELAY", "1.5")
    retry_delay = float(retry_delay_str)
    print(f"Retry delay: {retry_delay} seconds")
    
    # ‚úÖ RIGHT: Convert string to list
    allowed_envs_str = os.getenv("ALLOWED_ENVS", "dev,staging,prod")
    allowed_envs = [env.strip() for env in allowed_envs_str.split(",")]
    print(f"Allowed environments: {allowed_envs}")


def env_variable_validation():
    """
    Always validate environment variables!
    """
    
    # Check required variables
    required_vars = ["API_BASE_URL", "API_KEY", "DATABASE_URL"]
    missing_vars = [var for var in required_vars if var not in os.environ]
    
    if missing_vars:
        raise ValueError(
            f"Missing required environment variables: {', '.join(missing_vars)}\n"
            f"Please set them before running tests."
        )
    
    # Validate environment name
    environment = os.getenv("ENVIRONMENT", "development")
    valid_environments = ["development", "staging", "production"]
    
    if environment not in valid_environments:
        raise ValueError(
            f"Invalid ENVIRONMENT: {environment}. "
            f"Must be one of: {', '.join(valid_environments)}"
        )
    
    print(f"‚úÖ All required environment variables present")
    print(f"‚úÖ Running in {environment} environment")


if __name__ == "__main__":
    print("=== Basic Environment Variable Access ===")
    basic_env_access()
    
    print("\n=== Working with Types ===")
    working_with_env_types()
    
    print("\n=== Environment Variable Validation ===")
    try:
        env_variable_validation()
    except ValueError as e:
        print(f"‚ùå Validation failed: {e}")
```

---

### Using Environment Variables in Tests

**File Path:** `tests/test_with_env_vars.py`

```python
import os
import httpx
import pytest


def test_environment_based_behavior():
    """
    Test behavior changes based on ENVIRONMENT variable.
    """
    environment = os.getenv("ENVIRONMENT", "development")
    
    if environment == "development":
        # Development: use fast timeouts, expect local services
        base_url = "http://localhost:8000"
        timeout = 5
    elif environment == "staging":
        # Staging: use moderate timeouts, expect staging services
        base_url = "https://api.staging.example.com"
        timeout = 15
    elif environment == "production":
        # Production: use longer timeouts, expect production services
        base_url = "https://api.production.example.com"
        timeout = 30
    else:
        pytest.fail(f"Unknown environment: {environment}")
    
    client = httpx.Client(base_url=base_url, timeout=timeout)
    
    # Run test with environment-appropriate configuration
    response = client.get("/health")
    assert response.status_code == 200
    
    print(f"Tested against {environment} environment: {base_url}")


def test_feature_flag_from_env():
    """
    Enable/disable test features via environment variables.
    """
    # Feature flag: Skip slow tests in development
    skip_slow_tests = os.getenv("SKIP_SLOW_TESTS", "False").lower() == "true"
    
    if skip_slow_tests:
        pytest.skip("Slow tests disabled via SKIP_SLOW_TESTS=True")
    
    # Run potentially slow test
    import time
    time.sleep(2)  # Simulate slow operation
    assert True


def test_required_env_var():
    """
    Fail gracefully if required environment variable is missing.
    """
    if "API_KEY" not in os.environ:
        pytest.fail(
            "API_KEY environment variable is required. "
            "Set it with: export API_KEY=your_key"
        )
    
    api_key = os.environ["API_KEY"]
    assert len(api_key) > 0, "API_KEY cannot be empty"


@pytest.fixture(scope="session")
def api_client_from_env():
    """
    Create httpx client configured entirely from environment variables.
    """
    # Get configuration from environment
    base_url = os.environ.get("API_BASE_URL", "http://localhost:8000")
    api_key = os.environ.get("API_KEY", "dev_key")
    timeout = int(os.environ.get("API_TIMEOUT", "30"))
    
    # Create client
    client = httpx.Client(
        base_url=base_url,
        headers={"Authorization": f"Bearer {api_key}"},
        timeout=timeout
    )
    
    yield client
    
    # Cleanup
    client.close()


def test_with_env_configured_client(api_client_from_env):
    """
    Use the environment-configured client.
    """
    response = api_client_from_env.get("/health")
    assert response.status_code == 200
```

---

### Setting Environment Variables

**File Path:** `scripts/set_env_examples.sh`

```bash
#!/bin/bash

# Script showing different ways to set environment variables

echo "=== Method 1: Export for current session ==="
export API_KEY="dev_key_12345"
export API_BASE_URL="http://localhost:8000"
export TIMEOUT="30"

echo "API_KEY is now: $API_KEY"

echo ""
echo "=== Method 2: Inline for single command ==="
ENVIRONMENT=production pytest tests/test_api.py

echo ""
echo "=== Method 3: Set multiple at once ==="
export API_KEY="dev_key" \
       API_BASE_URL="http://localhost:8000" \
       DATABASE_URL="postgresql://localhost/test_db" \
       ENVIRONMENT="development"

echo ""
echo "=== Method 4: Load from file (we'll use .env files for this) ==="
# We'll learn this in the next lesson with python-dotenv

echo ""
echo "=== Viewing all environment variables ==="
# List all environment variables
env | grep -E "^(API_|DATABASE_|ENVIRONMENT)" | sort

echo ""
echo "=== Unsetting variables ==="
unset API_KEY
echo "API_KEY after unset: ${API_KEY:-<not set>}"
```

---

### Line-by-Line Explanation

**In `env_basics.py`:**

- `os.environ["API_KEY"]`: Direct access - raises KeyError if not found (use for required vars)
- `os.environ.get("API_KEY", "default")`: Safe access with fallback (use for optional vars)
- `os.getenv("API_KEY")`: Alias for os.environ.get() - more concise
- `"API_KEY" in os.environ`: Check existence before accessing
- **Type conversion is critical**: Environment variables are always strings!
- `debug_str.lower() in ("true", "1", "yes")`: Robust boolean conversion
- `int(timeout_str)`: Convert string to integer - will raise ValueError if invalid
- List validation ensures environment names are valid before proceeding

**In `test_with_env_vars.py`:**

- Tests adapt behavior based on ENVIRONMENT variable
- Feature flags (SKIP_SLOW_TESTS) control test execution
- Graceful failures with helpful error messages when vars are missing
- Fixture creates client from environment variables for DRY tests

**In `set_env_examples.sh`:**

- `export VAR=value`: Sets variable for current shell and child processes
- `VAR=value command`: Sets variable for single command only
- `unset VAR`: Removes variable from environment
- Backslash `\` allows multi-line export statements

---

### The "Why" Behind the Code

**Why Environment Variables?**

1. **Portability**: Same code runs on any machine with different values
2. **Security**: Secrets don't go in code or version control
3. **Flexibility**: Change behavior without code changes
4. **12-Factor Compliant**: Industry standard for cloud-native apps
5. **CI/CD Friendly**: Every CI system supports environment variables
6. **Docker/Kubernetes Native**: Containers use env vars for configuration
7. **Operating System Agnostic**: Works on Linux, macOS, Windows

**Why Type Conversion Matters:**

Environment variables are always strings in the OS. Python doesn't magically know that "30" should be an integer or "True" should be a boolean. This is a common source of bugs:

```python
# ‚ùå BUG: Treats string "False" as truthy!
if os.getenv("DEBUG"):  # "False" is truthy!
    
# ‚úÖ CORRECT: Convert to actual boolean
if os.getenv("DEBUG", "").lower() == "true":
```

Pydantic-settings (which we'll use later) handles all this type conversion automatically, which is why it's the industry standard.

---

## C. Connect & Apply

### How to Test It

1. **Create the examples file:**

```bash
mkdir -p examples
# Copy the env_basics.py code above
```

2. **Test without environment variables (see errors):**

```bash
python examples/env_basics.py
```

**Expected output:**
```
=== Basic Environment Variable Access ===
API_KEY environment variable not set!
API Key: default_key
API Key: default_key
API_KEY is not set

=== Environment Variable Validation ===
‚ùå Validation failed: Missing required environment variables: API_BASE_URL, API_KEY, DATABASE_URL
```

3. **Set environment variables and test again:**

```bash
export API_KEY="dev_key_12345"
export API_BASE_URL="http://localhost:8000"
export DATABASE_URL="postgresql://localhost/test_db"
export ENVIRONMENT="development"
export DEBUG="True"
export TIMEOUT="10"

python examples/env_basics.py
```

**Expected output:**
```
=== Basic Environment Variable Access ===
API Key found: dev_key_12345
API Key: dev_key_12345
API Key: dev_key_12345
API_KEY is set

=== Working with Types ===
Debug mode ON
Timeout: 10 seconds

=== Environment Variable Validation ===
‚úÖ All required environment variables present
‚úÖ Running in development environment
```

4. **Test environment-based test behavior:**

```bash
# Development environment
export ENVIRONMENT="development"
pytest tests/test_with_env_vars.py::test_environment_based_behavior -v -s

# Production environment (same code, different behavior)
export ENVIRONMENT="production"
pytest tests/test_with_env_vars.py::test_environment_based_behavior -v -s
```

---

## D. Common Stumbling Blocks

### Mistake #1: Forgetting that env vars are always strings

**The Problem:**

```python
# ‚ùå WRONG: Comparison doesn't work as expected
timeout = os.getenv("TIMEOUT", 30)  # Default is int 30
if timeout > 20:  # ‚ö†Ô∏è Error if TIMEOUT env var is set!
    print("Long timeout")

# When TIMEOUT="10" is set, this fails:
# TypeError: '>' not supported between instances of 'str' and 'int'
```

**The Fix:**

```python
# ‚úÖ RIGHT: Always convert to the type you need
timeout = int(os.getenv("TIMEOUT", "30"))  # Default is also string
if timeout > 20:
    print("Long timeout")
```

---

### Mistake #2: Environment variables don't persist

**The Problem:**

```bash
# Terminal 1
export API_KEY="my_key"
python my_script.py  # Works!

# Terminal 2 (different session)
python my_script.py  # Fails! API_KEY not set

# Even in same terminal
export API_KEY="my_key"
./run_tests.sh  # Script doesn't see API_KEY if it starts a new shell
```

**Why It Happens:**

Environment variables are per-process. They don't automatically propagate to:
- New terminal windows/tabs
- New shell sessions
- Subprocesses that explicitly start fresh environments

**The Fix:**

```bash
# Option 1: Export in each terminal session
export API_KEY="my_key"

# Option 2: Add to shell profile (~/.bashrc, ~/.zshrc)
echo 'export API_KEY="my_key"' >> ~/.bashrc
source ~/.bashrc

# Option 3: Use .env files (next lesson!)
# Create .env file and load automatically with python-dotenv
```

---

### Mistake #3: Inline environment vars don't persist

**The Problem:**

```bash
API_KEY="test_key" echo $API_KEY
# Output: (nothing) - API_KEY not set in the shell where echo runs

API_KEY="test_key" python script.py
# Script sees API_KEY, but...

echo $API_KEY
# Output: (nothing) - API_KEY is not in current shell
```

**Why It Happens:**

`VAR=value command` sets the variable only for that command's environment, not your shell.

**The Fix:**

```bash
# For single command:
API_KEY="test_key" pytest tests/  # pytest sees it

# For multiple commands:
export API_KEY="test_key"  # Now it persists
pytest tests/
python script.py  # Both see API_KEY
```

---

### Mistake #4: Overwriting instead of appending

**The Problem:**

```bash
export PATH="/my/custom/path"
# ‚ùå Oops! Just destroyed the entire PATH
# Now `python`, `ls`, `cd`, etc. don't work
```

**The Fix:**

```bash
# ‚úÖ Append to existing PATH
export PATH="/my/custom/path:$PATH"

# ‚úÖ Prepend to existing PATH
export PATH="$PATH:/my/custom/path"
```

---

### Mistake #5: Spaces in values

**The Problem:**

```bash
export API_MESSAGE=Hello World
# Only sets API_MESSAGE="Hello", then tries to run "World" as command

export API_URL=http://localhost:8000?key=value&other=value2
# Shell interprets & as background operator
```

**Error You'll See:**
```
bash: World: command not found
```

**The Fix:**

```bash
# ‚úÖ Use quotes for values with spaces or special characters
export API_MESSAGE="Hello World"
export API_URL="http://localhost:8000?key=value&other=value2"
export JSON_CONFIG='{"key": "value", "nested": {"data": "here"}}'
```

---

## üéØ Key Takeaways

‚úÖ **Environment variables** are key-value pairs in your operating system  
‚úÖ **Always strings** - must convert to int, bool, float, etc.  
‚úÖ **Access with** `os.environ["VAR"]` (required) or `os.getenv("VAR", "default")` (optional)  
‚úÖ **Set with** `export VAR=value` (bash/zsh) or `SET VAR=value` (Windows cmd)  
‚úÖ **Per-session** - don't persist across terminals unless in shell profile  
‚úÖ **Validate early** - check required vars exist and have valid values  
‚úÖ **Use quotes** for values with spaces or special characters  

---

## What's Next?

Environment variables are powerful but tedious to set manually. In the next lesson, we'll introduce **python-dotenv**, which lets you store environment variables in `.env` files for automatic loading. This is the secret to effortless local development configuration!

**Ready to continue?** üöÄ
