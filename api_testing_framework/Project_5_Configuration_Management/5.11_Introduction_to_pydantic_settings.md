# Lesson 5.11: Introduction to pydantic-settings

## A. Concept Overview

### What & Why
**Pydantic-settings** is a library that extends Pydantic to provide type-safe, validated configuration management from environment variables and .env files. It's essential for professional test frameworks because it automatically validates configuration at startup, provides helpful error messages, and ensures type safety without manual conversion code.

### Analogy
Think of pydantic-settings like a smart form with built-in validation. Instead of accepting any input and hoping it's valid (raw environment variables), it's like a form that checks: "Is this an integer? Is this URL valid? Is this field required?" before letting your application start. Errors are caught immediately, not during test execution.

---

## B. Code Implementation

### Installing pydantic-settings

**File Path:** `requirements.txt`

```txt
# Configuration Management
pydantic>=2.0.0
pydantic-settings>=2.0.0
python-dotenv>=1.0.0

# Testing
pytest>=7.4.0
httpx>=0.24.0
```

Install:

```bash
pip install pydantic-settings python-dotenv
```

---

### Basic Settings Class

**File Path:** `config/settings.py`

```python
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """
    Application configuration loaded from environment variables.
    
    Pydantic automatically:
    - Loads from environment variables
    - Validates types
    - Provides helpful error messages
    - Converts strings to appropriate types
    """
    
    # API Configuration
    api_base_url: str                    # Required field (no default)
    api_key: str                         # Required field
    api_timeout: int = 30                # Optional with default
    
    # Application Settings
    environment: str = "development"
    debug: bool = False
    log_level: str = "INFO"
    
    class Config:
        # Load from .env file automatically
        env_file = ".env"
        env_file_encoding = "utf-8"
        
        # Case-insensitive environment variable names
        case_sensitive = False


# Create singleton instance
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()
```

---

### Comparing With and Without pydantic-settings

**Without pydantic-settings (manual):**

```python
import os

# âŒ Lots of manual work:
api_base_url = os.getenv("API_BASE_URL")
if not api_base_url:
    raise ValueError("API_BASE_URL is required")

api_timeout_str = os.getenv("API_TIMEOUT", "30")
try:
    api_timeout = int(api_timeout_str)
except ValueError:
    raise ValueError(f"API_TIMEOUT must be an integer, got: {api_timeout_str}")

debug_str = os.getenv("DEBUG", "False")
debug = debug_str.lower() in ("true", "1", "yes")

# Repeat for every configuration variable...
```

**With pydantic-settings (automatic):**

```python
from config.settings import get_settings

# âœ… Clean and type-safe:
settings = get_settings()

# All validation happens automatically
api_url = settings.api_base_url    # str, validated as present
timeout = settings.api_timeout      # int, automatically converted
debug = settings.debug              # bool, automatically converted
```

---

### Type Validation Examples

**File Path:** `examples/pydantic_validation.py`

```python
from pydantic_settings import BaseSettings
from pydantic import ValidationError


class ExampleSettings(BaseSettings):
    """Examples of automatic type validation."""
    
    # String - must be present
    api_key: str
    
    # Integer - auto-converted from env var string
    timeout: int = 30
    
    # Boolean - auto-converted ("true", "1", "yes" â†’ True)
    debug: bool = False
    
    # Float - auto-converted
    retry_delay: float = 1.5
    
    # List - comma-separated string converted to list
    allowed_hosts: list[str] = ["localhost"]
    
    class Config:
        env_file = ".env"
        case_sensitive = False


def demo_validation():
    """Demonstrate pydantic validation."""
    
    # âœ… Valid configuration
    import os
    os.environ["API_KEY"] = "test123"
    os.environ["TIMEOUT"] = "45"
    os.environ["DEBUG"] = "true"
    os.environ["RETRY_DELAY"] = "2.5"
    os.environ["ALLOWED_HOSTS"] = "localhost,example.com,api.test.com"
    
    settings = ExampleSettings()
    
    print(f"API Key: {settings.api_key}")           # str: "test123"
    print(f"Timeout: {settings.timeout}")            # int: 45
    print(f"Debug: {settings.debug}")                # bool: True
    print(f"Retry Delay: {settings.retry_delay}")    # float: 2.5
    print(f"Allowed Hosts: {settings.allowed_hosts}") # list: ["localhost", "example.com", "api.test.com"]
    print(f"Types: {type(settings.timeout)}, {type(settings.debug)}")
    
    # âŒ Invalid configuration - automatic validation error
    os.environ["TIMEOUT"] = "not_a_number"
    
    try:
        bad_settings = ExampleSettings()
    except ValidationError as e:
        print("\nValidation Error:")
        print(e)
        # Pydantic provides detailed error about what's wrong


if __name__ == "__main__":
    demo_validation()
```

---

### Helpful Error Messages

When configuration is invalid, pydantic-settings provides clear error messages:

```python
from pydantic_settings import BaseSettings
from pydantic import ValidationError


class Settings(BaseSettings):
    api_base_url: str        # Required
    api_timeout: int = 30    # Must be integer
    max_retries: int = 3


# Missing required field
try:
    settings = Settings()
except ValidationError as e:
    print(e)
    """
    1 validation error for Settings
    api_base_url
      Field required [type=missing, input_value={}, input_type=dict]
    """

# Wrong type
import os
os.environ["API_TIMEOUT"] = "thirty"
os.environ["API_BASE_URL"] = "http://localhost"

try:
    settings = Settings()
except ValidationError as e:
    print(e)
    """
    1 validation error for Settings
    api_timeout
      Input should be a valid integer, unable to parse string as an integer
      [type=int_parsing, input_value='thirty', input_type=str]
    """
```

---

### Using Settings in Tests

**File Path:** `tests/conftest.py`

```python
import pytest
from config.settings import get_settings


@pytest.fixture(scope="session")
def settings():
    """
    Provide settings to all tests.
    
    Settings are validated once at the start of the test session.
    If configuration is invalid, tests fail fast with clear error.
    """
    return get_settings()


@pytest.fixture(scope="session")
def api_client(settings):
    """
    Create httpx client from validated settings.
    """
    import httpx
    
    client = httpx.Client(
        base_url=settings.api_base_url,
        headers={"Authorization": f"Bearer {settings.api_key}"},
        timeout=settings.api_timeout
    )
    
    yield client
    client.close()
```

**File Path:** `tests/test_with_settings.py`

```python
import pytest


def test_settings_available(settings):
    """Verify settings are loaded and valid."""
    assert settings.api_base_url is not None
    assert len(settings.api_key) > 0
    assert settings.api_timeout > 0


def test_api_with_configured_client(api_client, settings):
    """Test using configured client."""
    response = api_client.get("/health")
    
    print(f"Tested against: {settings.api_base_url}")
    print(f"Environment: {settings.environment}")
    
    assert response.status_code == 200
```

---

## C. Connect & Apply

### How to Test It

1. **Install pydantic-settings:**

```bash
pip install pydantic-settings python-dotenv
```

2. **Create settings.py:**

```python
# config/settings.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    api_base_url: str
    api_key: str
    api_timeout: int = 30
    debug: bool = False
    
    class Config:
        env_file = ".env"
        case_sensitive = False

def get_settings():
    return Settings()
```

3. **Create .env file:**

```bash
cat > .env << 'EOF'
API_BASE_URL=http://localhost:8000
API_KEY=test_key_123
API_TIMEOUT=10
DEBUG=true
EOF
```

4. **Test it:**

```python
python -c "
from config.settings import get_settings
s = get_settings()
print(f'URL: {s.api_base_url}')
print(f'Timeout: {s.api_timeout} (type: {type(s.api_timeout).__name__})')
print(f'Debug: {s.debug} (type: {type(s.debug).__name__})')
"
```

### Expected Result

```
URL: http://localhost:8000
Timeout: 10 (type: int)
Debug: True (type: bool)
```

**With missing required field:**

```bash
# Remove API_KEY from .env
python -c "from config.settings import get_settings; get_settings()"

# Output:
pydantic_core._pydantic_core.ValidationError: 1 validation error for Settings
api_key
  Field required [type=missing]
```

---

## D. Common Stumbling Blocks

### Mistake #1: Forgetting Config class

**The Problem:**

```python
class Settings(BaseSettings):
    api_key: str
    
    # âŒ Missing Config class
    # Pydantic won't load from .env file!
```

**The Fix:**

```python
class Settings(BaseSettings):
    api_key: str
    
    class Config:
        env_file = ".env"  # âœ… Now loads from .env
```

---

### Mistake #2: Wrong pydantic version

**The Problem:**

```python
# Using Pydantic v1 syntax with v2
from pydantic import BaseSettings  # âŒ Wrong import

class Settings(BaseSettings):
    pass
```

**Error:**

```
ImportError: cannot import name 'BaseSettings' from 'pydantic'
```

**The Fix:**

```python
# âœ… Pydantic v2 uses separate package
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    pass
```

---

### Mistake #3: Not understanding field requirements

**The Problem:**

```python
class Settings(BaseSettings):
    api_key: str  # Required - no default
    
# If API_KEY not set â†’ ValidationError
```

**The Fix:**

```python
# Option 1: Make it optional with default
api_key: str = "default_key"

# Option 2: Make it truly optional
from typing import Optional
api_key: Optional[str] = None

# Option 3: Keep required (fail fast if missing)
api_key: str  # This is usually best!
```

---

## ðŸŽ¯ Key Takeaways

âœ… **pydantic-settings** provides type-safe configuration management  
âœ… **Automatic validation** - errors at startup, not during tests  
âœ… **Type conversion** - strings automatically converted to int, bool, list, etc.  
âœ… **Clear errors** - helpful messages when configuration is wrong  
âœ… **BaseSettings** from pydantic_settings (v2), not pydantic  
âœ… **Config class** required to load from .env files  
âœ… **Fail fast** - invalid configuration prevents app/tests from starting  

---

## What's Next?

Next lesson: **BaseSettings Configuration Class** - deep dive into creating robust Settings classes!

**Ready to continue?** ðŸš€
