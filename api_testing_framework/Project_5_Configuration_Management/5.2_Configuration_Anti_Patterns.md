# Lesson 5.2: Configuration Anti-Patterns

## A. Concept Overview

### What & Why
**Configuration anti-patterns** are common but harmful approaches to managing settings in your test framework that lead to security vulnerabilities, maintenance nightmares, and broken tests. Understanding what NOT to do is just as important as learning best practices because you'll encounter these patterns in legacy codebases.

### Analogy
Think of configuration anti-patterns like storing your house keys under the doormat, writing your bank PIN on your debit card, or using "password123" for everything. Sure, it's convenient and "works," but you're one mistake away from disaster. Anti-patterns are the "works for now, disaster later" approaches to configuration.

---

## B. Code Implementation

### Anti-Pattern #1: Configuration in Test Files (The Scattered Config)

**File Path:** `tests/test_api_antipattern1.py`

```python
import httpx
import pytest

# ‚ùå ANTI-PATTERN: Configuration scattered across multiple files
def test_users_endpoint():
    client = httpx.Client(base_url="https://api.example.com", timeout=30)
    response = client.get("/users")
    assert response.status_code == 200

def test_orders_endpoint():
    # Slightly different URL - inconsistency!
    client = httpx.Client(base_url="https://api.example.com/v2", timeout=30)
    response = client.get("/orders")
    assert response.status_code == 200
```

**File Path:** `tests/test_auth_antipattern1.py`

```python
import httpx

# ‚ùå Same configuration duplicated in another file
def test_login():
    client = httpx.Client(base_url="https://api.example.com", timeout=30)
    response = client.post("/login", json={"user": "test"})
    assert response.status_code == 200
```

**Why This Is Bad:**
- Configuration is duplicated across 10+ test files
- Changing the base URL requires editing every single test file
- Inconsistencies creep in (notice the `/v2` version in one test)
- No single source of truth

---

### Anti-Pattern #2: Config File with Hardcoded Secrets

**File Path:** `config.py`

```python
# ‚ùå ANTI-PATTERN: Secrets committed to version control
class Config:
    BASE_URL = "https://api.production.com"
    API_KEY = "sk_live_abc123xyz789"  # ‚ö†Ô∏è PRODUCTION KEY IN GIT!
    DB_PASSWORD = "SuperSecret123!"   # ‚ö†Ô∏è DATABASE PASSWORD IN GIT!
    TIMEOUT = 30
    
    # Even worse - multiple environments in one file
    STAGING_URL = "https://api.staging.com"
    STAGING_KEY = "sk_test_staging123"
    
    DEV_URL = "http://localhost:3000"
    DEV_KEY = "dev_key_123"
```

**Why This Is Bad:**
- All secrets are visible in git history forever
- Production credentials mixed with dev credentials
- No way to have different secrets per developer
- GitHub bots will find and exploit these keys within minutes
- Violates principle of least privilege (devs don't need prod credentials)

---

### Anti-Pattern #3: Environment Detection Hell

**File Path:** `config_detection.py`

```python
import os
import socket

# ‚ùå ANTI-PATTERN: Trying to "auto-detect" the environment
class SmartConfig:
    def __init__(self):
        # Fragile environment detection
        hostname = socket.gethostname()
        
        if "prod" in hostname or "production" in hostname:
            self.env = "production"
            self.base_url = "https://api.production.com"
            self.api_key = self._get_prod_key()
        elif "staging" in hostname:
            self.env = "staging"
            self.base_url = "https://api.staging.com"
            self.api_key = self._get_staging_key()
        elif "jenkins" in hostname or "ci" in hostname:
            self.env = "ci"
            self.base_url = os.getenv("CI_API_URL", "http://localhost")
            self.api_key = os.getenv("CI_API_KEY")
        else:
            # Hope for the best!
            self.env = "development"
            self.base_url = "http://localhost:3000"
            self.api_key = "dev"
    
    def _get_prod_key(self):
        # Even more fragility
        try:
            with open("/etc/secrets/api_key") as f:
                return f.read().strip()
        except FileNotFoundError:
            return "fallback_key"  # ‚ö†Ô∏è Silent failure!
```

**Why This Is Bad:**
- Fragile assumptions based on hostname
- Silent fallbacks hide configuration errors
- Impossible to test locally with different environments
- Breaks when infrastructure changes
- Magic behavior that's hard to debug
- What if your machine hostname contains "prod"?

---

### Anti-Pattern #4: Global Variables Everywhere

**File Path:** `globals_config.py`

```python
# ‚ùå ANTI-PATTERN: Global mutable state
BASE_URL = "https://api.example.com"
API_KEY = "default_key"
TIMEOUT = 30
RETRY_COUNT = 3

def set_environment(env: str):
    """Change configuration at runtime - seems flexible, actually chaos"""
    global BASE_URL, API_KEY
    
    if env == "prod":
        BASE_URL = "https://api.production.com"
        API_KEY = "prod_key"
    elif env == "staging":
        BASE_URL = "https://api.staging.com"
        API_KEY = "staging_key"
```

**File Path:** `tests/test_with_globals.py`

```python
import globals_config

def test_prod_api():
    # ‚ùå Tests affect each other through global state
    globals_config.set_environment("prod")
    # ... test code ...

def test_staging_api():
    # ‚ö†Ô∏è Depends on test execution order!
    globals_config.set_environment("staging")
    # ... test code ...
```

**Why This Is Bad:**
- Tests can interfere with each other
- Race conditions in parallel test execution
- Impossible to test multiple environments simultaneously
- Hard to track where configuration changes happen
- Global state is the enemy of testability

---

### Anti-Pattern #5: JSON/YAML with Secrets

**File Path:** `config.json`

```json
{
  "environments": {
    "production": {
      "base_url": "https://api.production.com",
      "api_key": "sk_live_REAL_PRODUCTION_KEY",
      "database": {
        "host": "prod-db.example.com",
        "password": "ProductionDBPassword123!"
      }
    },
    "staging": {
      "base_url": "https://api.staging.com",
      "api_key": "sk_test_staging_key",
      "database": {
        "host": "staging-db.example.com",
        "password": "StagingDBPassword456!"
      }
    }
  }
}
```

**Why This Is Bad:**
- JSON/YAML files with secrets get committed to git
- All secrets for all environments in one file
- Developers need access to production secrets just to run local tests
- No encryption, no access control
- Configuration changes require code commits

---

### Anti-Pattern #6: The "Config Class Hierarchy Nightmare"

**File Path:** `complex_config.py`

```python
# ‚ùå ANTI-PATTERN: Over-engineered inheritance hell
class BaseConfig:
    DEBUG = False
    TESTING = False
    
class DevelopmentConfig(BaseConfig):
    DEBUG = True
    API_URL = "http://localhost"
    
class TestingConfig(BaseConfig):
    TESTING = True
    API_URL = "http://localhost"
    
class StagingConfig(BaseConfig):
    API_URL = "https://staging.example.com"
    # Wait, where's the API key?
    
class ProductionConfig(BaseConfig):
    API_URL = "https://api.example.com"
    # Is this using the staging key or prod key?
    
class ProductionDebugConfig(ProductionConfig):
    DEBUG = True  # ‚ö†Ô∏è Debug mode in production?!

# The selection logic
import os
config_name = os.getenv("CONFIG_CLASS", "DevelopmentConfig")
config = globals()[config_name]()  # ‚ö†Ô∏è Dangerous eval-like behavior
```

**Why This Is Bad:**
- Over-complicated for no benefit
- Class names hardcoded in environment variables
- Inheritance makes it unclear what values are actually used
- Still doesn't solve the secrets problem
- Easy to accidentally use wrong config (ProductionDebugConfig?!)

---

### The Right Way (Preview)

**File Path:** `.env.dev` (not committed)

```bash
BASE_URL=https://api.dev.example.com
API_KEY=dev_safe_key
TIMEOUT=10
```

**File Path:** `config/settings.py`

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    base_url: str
    api_key: str
    timeout: int = 30
    
    class Config:
        env_file = ".env"
        case_sensitive = False

# Clean, type-safe, environment-aware
settings = Settings()
```

**Why This Is Right:**
‚úÖ Secrets never in version control  
‚úÖ Type validation automatically  
‚úÖ One clear way to configure  
‚úÖ Works in all environments  
‚úÖ Easy to test and mock  

---

## C. Connect & Apply

### How to Recognize Anti-Patterns

When reviewing code (yours or others), look for these red flags:

1. **Search your codebase:**
```bash
# Find hardcoded URLs
grep -r "https://" tests/

# Find potential API keys
grep -r "api_key\s*=\s*['\"]" .

# Check what's in git
git log --all --full-history -- "*config*"
```

2. **Check your .gitignore:**
```bash
cat .gitignore | grep env
# Should see: .env, .env.*, etc.
```

3. **Look for scattered config:**
```bash
# How many files mention your API URL?
grep -r "api.example.com" . | wc -l
# If more than 1-2 files, you have scattered config
```

### Expected Result

**Identifying Anti-Patterns in a Real Project:**

```bash
$ grep -r "api_key.*=" tests/
tests/test_auth.py:    api_key = "sk_test_12345"
tests/test_users.py:    api_key = "sk_test_12345"
tests/test_orders.py:    api_key = "sk_prod_REAL_KEY"  # ‚ö†Ô∏è DANGER!

# This output tells you:
# - Config is scattered across 3 files
# - There's a production key in test_orders.py
# - Time to refactor!
```

---

## D. Common Stumbling Blocks

### Mistake #1: "But this anti-pattern works fine in my project"

**The Problem:**
Many anti-patterns work perfectly fine... until they don't. They fail when:
- A new team member joins
- You need to run tests in CI/CD
- You accidentally use prod credentials
- Your credentials get leaked in git
- You need to test against multiple environments

**The Reality:**
```
Week 1: "Hardcoding the API key is fine, it's just me"
Week 4: "I'll move it to a config file when I have time"
Month 2: "The whole team is using my API key now..."
Month 3: GitHub Alert: "Secret detected in repository"
Month 3.5: Production database deleted by leaked credentials
```

**The Fix:**
Don't wait for the disaster. Set up proper configuration management from day one. It takes 20 minutes and prevents catastrophes.

---

### Mistake #2: "I'll just obfuscate the secrets"

**The Problem:**
Developers think they can outsmart git by:
- Base64 encoding secrets (not encryption!)
- ROT13 or simple ciphers
- Splitting the key across multiple lines
- Adding comments like "# This is not the real key"

**Error You'll See:**
```python
# ‚ùå This provides ZERO security
import base64
API_KEY = base64.b64decode("c2tfbGl2ZV9zZWNyZXRfa2V5").decode()
# Anyone with access to the repo can decode this in 1 second
```

**The Fix:**
Obfuscation ‚â† Security. Use proper secrets management:
- Environment variables for local development
- .env files (gitignored) for local configuration
- Secret managers (AWS Secrets Manager, HashiCorp Vault) for production
- CI/CD encrypted secrets for automation

---

### Mistake #3: "I'll delete the commit with secrets"

**The Problem:**
After committing secrets, developers try to "fix" it by:
- Deleting the file and committing again (secret still in history)
- Using `git commit --amend` (only fixes local, not remote)
- Deleting the repository and creating a new one (maybe, but complicated)

**What Actually Happens:**
```bash
git log --all --full-history -S "sk_live_" -- "*.py"
# Your secret is still there in git history
# Even if you deleted it from the latest commit

# GitHub still sees it
# Google cache might have indexed it
# Anyone who cloned before your "fix" still has it
```

**The Fix:**
- **Immediately rotate the compromised credentials** (get new ones)
- Use `git filter-branch` or BFG Repo Cleaner to remove from history
- Force push (with team coordination)
- Better: Never commit secrets in the first place (use .gitignore from day 1)

---

### Mistake #4: "One config file for all environments is cleaner"

**The Problem:**
Keeping all environment configs in one file seems organized:

```python
# config.py - seems tidy!
CONFIGS = {
    "dev": {"url": "http://localhost", "key": "dev_key"},
    "staging": {"url": "https://staging.example.com", "key": "staging_key"},
    "prod": {"url": "https://api.example.com", "key": "prod_key_REAL"},
}
```

**Why It Fails:**
- All secrets in one place means more exposure
- Developers need prod credentials just to read the file
- One leak exposes all environments
- Hard to manage different secret access levels
- Violates principle of least privilege

**The Fix:**
Separate configuration per environment:
- `.env.dev` - only dev credentials
- `.env.staging` - only staging credentials  
- `.env.prod` - only in CI/CD secrets, not in repository
- Developers only have access to what they need

---

## üéØ Key Takeaways

‚úÖ **Recognize anti-patterns** so you can avoid them and fix them in legacy code  
‚úÖ **Hardcoded secrets** in any form (plain text, encoded, in comments) are unacceptable  
‚úÖ **Scattered configuration** makes maintenance impossible  
‚úÖ **Global mutable state** breaks parallel testing  
‚úÖ **Over-engineering** config doesn't solve the fundamental secrets problem  
‚úÖ **The right approach** is simple: environment variables + pydantic-settings + .gitignore  

---

## What's Next?

In the next lesson, we'll learn about **The 12-Factor App Configuration** methodology - the industry standard that guides all modern configuration management.

**Ready to continue?** üöÄ
