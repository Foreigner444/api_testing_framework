# Lesson 5.22: Dynamic Configuration Loading

## A. Concept Overview

### What & Why
**Dynamic configuration loading** allows loading or reloading configuration at runtime based on conditions, enabling scenarios like hot-reloading config without restarting tests, or switching environments mid-execution. Important for advanced testing scenarios and development workflows.

### Analogy
Dynamic configuration is like a GPS that can recalculate your route while you're driving. Instead of having to stop, restart your trip with a new destination (restart your app with new config), you can change destinations on the fly.

---

## B. Code Implementation

```python
from typing import Optional
from pathlib import Path
from pydantic_settings import BaseSettings, SettingsConfigDict


class DynamicSettings(BaseSettings):
    """Settings that can be reloaded at runtime."""
    
    api_key: str
    api_base_url: str
    timeout: int = 30
    
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False
    )
    
    @classmethod
    def load_for_environment(cls, environment: str):
        """Load settings for specific environment."""
        env_file = Path(f".env.{environment}")
        
        if not env_file.exists():
            raise FileNotFoundError(
                f"Configuration for '{environment}' not found: {env_file}"
            )
        
        return cls(_env_file=str(env_file))
    
    @classmethod
    def reload(cls):
        """Reload settings from files."""
        return cls()


class ConfigManager:
    """Manages dynamic configuration loading and caching."""
    
    def __init__(self):
        self._settings: Optional[DynamicSettings] = None
        self._current_env: str = "development"
    
    def load(self, environment: str = "development") -> DynamicSettings:
        """Load configuration for specified environment."""
        self._current_env = environment
        self._settings = DynamicSettings.load_for_environment(environment)
        return self._settings
    
    def reload(self) -> DynamicSettings:
        """Reload current environment configuration."""
        return self.load(self._current_env)
    
    def switch_environment(self, new_environment: str) -> DynamicSettings:
        """Switch to different environment dynamically."""
        print(f"Switching from {self._current_env} to {new_environment}")
        return self.load(new_environment)
    
    @property
    def current(self) -> DynamicSettings:
        """Get current settings (load if not loaded)."""
        if self._settings is None:
            self._settings = self.load()
        return self._settings


# Global config manager
config_manager = ConfigManager()


# Usage in tests
def get_settings() -> DynamicSettings:
    """Get current settings."""
    return config_manager.current


def switch_to_environment(env: str) -> DynamicSettings:
    """Switch to different environment during test execution."""
    return config_manager.switch_environment(env)
```

---

### Dynamic Environment Switching in Tests

```python
import pytest
import httpx
from config.dynamic_settings import switch_to_environment, get_settings


def test_api_across_environments():
    """Test API behavior across different environments."""
    
    # Start with development
    dev_settings = switch_to_environment("development")
    dev_client = httpx.Client(base_url=dev_settings.api_base_url)
    
    print(f"Testing development: {dev_settings.api_base_url}")
    dev_response = dev_client.get("/health")
    assert dev_response.status_code == 200
    
    # Switch to staging mid-test
    staging_settings = switch_to_environment("staging")
    staging_client = httpx.Client(base_url=staging_settings.api_base_url)
    
    print(f"Testing staging: {staging_settings.api_base_url}")
    staging_response = staging_client.get("/health")
    assert staging_response.status_code == 200
    
    # Compare environments
    assert dev_settings.api_base_url != staging_settings.api_base_url
    print("âœ“ Successfully tested both environments")


@pytest.fixture
def dynamic_client():
    """Fixture that provides client for current environment."""
    settings = get_settings()
    client = httpx.Client(
        base_url=settings.api_base_url,
        headers={"Authorization": f"Bearer {settings.api_key}"}
    )
    yield client
    client.close()


def test_with_dynamic_client(dynamic_client):
    """Test using dynamically configured client."""
    response = dynamic_client.get("/health")
    assert response.status_code == 200
```

---

## C. Connect & Apply

### How to Test It

```bash
# Create environment files
cat > .env.development << 'EOF'
API_KEY=dev_key
API_BASE_URL=http://localhost:8000
TIMEOUT=10
EOF

cat > .env.staging << 'EOF'
API_KEY=staging_key
API_BASE_URL=https://api.staging.example.com
TIMEOUT=30
EOF

# Test dynamic switching
python -c "
from config.dynamic_settings import ConfigManager

manager = ConfigManager()

# Load development
dev = manager.load('development')
print(f'Dev URL: {dev.api_base_url}')

# Switch to staging
staging = manager.switch_environment('staging')
print(f'Staging URL: {staging.api_base_url}')

# Switch back to development
dev2 = manager.switch_environment('development')
print(f'Back to Dev: {dev2.api_base_url}')
"
```

### Expected Result

```
Dev URL: http://localhost:8000
Switching from development to staging
Staging URL: https://api.staging.example.com
Switching from staging to development
Back to Dev: http://localhost:8000
```

---

## D. Common Stumbling Blocks

### Mistake #1: Cached settings not updating

**The Problem:**

```python
# Global singleton
settings = Settings()

# Later try to reload
settings = Settings()  # Same cached instance!
```

**The Fix:**

```python
# Use config manager pattern
class ConfigManager:
    _instance = None
    
    def reload(self):
        self._instance = Settings()
        return self._instance
```

---

### Mistake #2: System env vars don't change

**The Problem:**

```python
# Set system env var
import os
os.environ["API_KEY"] = "key1"

# Load settings
settings1 = Settings()

# Change system env var
os.environ["API_KEY"] = "key2"

# Reload settings
settings2 = Settings()  # Still uses key1 if cached!
```

**The Fix:** Force new instance:

```python
settings2 = Settings()  # Don't use cached singleton
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Dynamic loading** enables runtime configuration changes  
âœ… **ConfigManager pattern** for controlled reloading  
âœ… **Environment switching** during test execution  
âœ… **Avoid caching issues** with proper reload logic  
âœ… **Useful for development** and complex test scenarios  

---

## What's Next?

Next: **Configuration Validation on Startup** - ensuring config is correct before running!

**Ready to continue?** ðŸš€
