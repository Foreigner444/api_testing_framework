# Lesson 5.15: Nested Settings Models

## A. Concept Overview

### What & Why
**Nested settings models** allow organizing complex configuration into logical groups using nested Pydantic classes. Essential for large frameworks where flat configuration becomes unwieldy and grouping related settings (database, API, Redis) improves maintainability and clarity.

### Analogy
Think of nested settings like organizing files in folders. Instead of dumping all files on your desktop (flat configuration), you create folders for Documents, Photos, Music (nested models). Each folder contains related items, making everything easier to find and manage.

---

## B. Code Implementation

```python
from typing import Optional
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class DatabaseSettings(BaseSettings):
    """Database configuration group."""
    host: str = "localhost"
    port: int = 5432
    name: str = "testdb"
    user: str = "postgres"
    password: str
    pool_size: int = 10
    
    model_config = SettingsConfigDict(env_prefix="DB_")
    
    @property
    def url(self) -> str:
        return f"postgresql://{self.user}:{self.password}@{self.host}:{self.port}/{self.name}"


class APISettings(BaseSettings):
    """API configuration group."""
    base_url: str
    key: str
    timeout: int = 30
    max_retries: int = 3
    
    model_config = SettingsConfigDict(env_prefix="API_")


class RedisSettings(BaseSettings):
    """Redis configuration group."""
    host: str = "localhost"
    port: int = 6379
    db: int = 0
    password: Optional[str] = None
    
    model_config = SettingsConfigDict(env_prefix="REDIS_")
    
    @property
    def url(self) -> str:
        if self.password:
            return f"redis://:{self.password}@{self.host}:{self.port}/{self.db}"
        return f"redis://{self.host}:{self.port}/{self.db}"


class Settings(BaseSettings):
    """Main settings with nested configuration groups."""
    environment: str = "development"
    debug: bool = False
    
    # Nested models
    database: DatabaseSettings = Field(default_factory=DatabaseSettings)
    api: APISettings = Field(default_factory=APISettings)
    redis: RedisSettings = Field(default_factory=RedisSettings)
    
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False
    )


# .env file:
# ENVIRONMENT=development
# DEBUG=true
# DB_HOST=localhost
# DB_PORT=5432
# DB_NAME=testdb
# DB_USER=admin
# DB_PASSWORD=secret
# API_BASE_URL=http://localhost:8000
# API_KEY=test_key
# REDIS_HOST=localhost
# REDIS_PORT=6379

settings = Settings()
print(f"Database URL: {settings.database.url}")
print(f"API URL: {settings.api.base_url}")
print(f"Redis URL: {settings.redis.url}")
```

---

## C. Connect & Apply

### How to Test It

```bash
cat > .env << 'EOF'
DB_HOST=db.example.com
DB_PASSWORD=secret_pass
API_BASE_URL=https://api.example.com
API_KEY=test_key_12345
REDIS_HOST=cache.example.com
EOF

python -c "
from config.settings import Settings
s = Settings()
print(f'DB: {s.database.url}')
print(f'API: {s.api.base_url}')
print(f'Redis: {s.redis.url}')
"
```

### Expected Result

```
DB: postgresql://postgres:secret_pass@db.example.com:5432/testdb
API: https://api.example.com
Redis: redis://cache.example.com:6379/0
```

---

## D. Common Stumbling Blocks

### Mistake #1: Not using env_prefix for nested models

**Problem:** All nested models share same env var names
**Fix:** Use `env_prefix` to namespace each nested model

---

## ðŸŽ¯ Key Takeaways

âœ… **Nested models** organize complex configuration  
âœ… **env_prefix** namespaces environment variables  
âœ… **default_factory** for nested model instantiation  
âœ… **Properties** for computed values (URLs, etc.)  

---

## What's Next?

Next: **Settings with Multiple Sources** - loading from multiple configuration sources!

**Ready to continue?** ðŸš€
