# Lesson 5.10: .gitignore for Secret Management

## A. Concept Overview

### What & Why
**Proper .gitignore configuration** is a critical security practice that prevents committing sensitive configuration files (with passwords, API keys, tokens) to version control. Once secrets are committed to git, they remain in history forever and can be exploited, even if you delete them in a later commit.

### Analogy
Think of .gitignore like a security checkpoint at an airport. Just as TSA prevents dangerous items from getting on a plane, .gitignore prevents dangerous secrets from getting into your git repository. Once something gets through (gets committed), it's extremely hard to remove completely from history.

---

## B. Code Implementation

### Comprehensive .gitignore for Configuration

**File Path:** `.gitignore`

```bash
# ============================================
# Environment Files & Secrets
# ============================================

# Never commit actual credentials
.env
.env.local
.env.*.local

# Environment-specific files with real credentials
.env.development
.env.staging
.env.production
.env.test

# IMPORTANT: Allow example/template files
!.env.example
!.env.development.example
!.env.staging.example
!.env.production.example

# ============================================
# Python
# ============================================

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
*.so

# Testing
.pytest_cache/
.coverage
htmlcov/
*.cover
.hypothesis/

# Virtual environments
venv/
env/
ENV/
.venv

# ============================================
# IDE / Editor
# ============================================

# VSCode
.vscode/
*.code-workspace

# PyCharm
.idea/
*.iml

# Vim
*.swp
*.swo
*~

# ============================================
# OS
# ============================================

# macOS
.DS_Store
.AppleDouble
.LSOverride

# Windows
Thumbs.db
ehthumbs.db
Desktop.ini

# Linux
*~
.directory

# ============================================
# Logs & Reports
# ============================================

*.log
logs/
*.log.*

# Allure reports (may contain sensitive data)
allure-results/
allure-report/

# ============================================
# Secrets & Credentials
# ============================================

# Certificate files
*.pem
*.key
*.crt
*.p12
*.pfx

# Secret management files
secrets/
credentials/
.secrets/

# Service account keys
*-key.json
service-account*.json

# SSH keys
id_rsa
id_rsa.pub
*.ppk

# ============================================
# Configuration Files That May Contain Secrets
# ============================================

# Database dumps
*.sql
*.dump

# Config files that might have secrets
config.local.yml
config.local.yaml
config.local.json
config.local.toml

# Backup files
*.bak
*.backup
*.old

# ============================================
# Dependency Directories
# ============================================

node_modules/
.npm/
bower_components/

# ============================================
# Build & Distribution
# ============================================

build/
dist/
*.egg-info/
```

---

### Pre-commit Hook to Prevent Secret Commits

**File Path:** `.git/hooks/pre-commit`

```bash
#!/bin/bash
# Pre-commit hook to prevent committing secrets

echo "Running pre-commit secret check..."

# Check for common secret patterns
secrets_found=false

# Patterns that might indicate secrets
patterns=(
    "password\s*=\s*['\"][^'\"]+['\"]"
    "api_key\s*=\s*['\"][^'\"]+['\"]"
    "secret\s*=\s*['\"][^'\"]+['\"]"
    "token\s*=\s*['\"][^'\"]+['\"]"
    "BEGIN.*PRIVATE KEY"
)

for pattern in "${patterns[@]}"; do
    if git diff --cached | grep -iE "$pattern" > /dev/null; then
        echo "‚ùå WARNING: Possible secret detected in staged files!"
        echo "   Pattern: $pattern"
        secrets_found=true
    fi
done

# Check if .env files are being committed
if git diff --cached --name-only | grep -E "^\.env$|^\.env\..*" | grep -v "\.env\.example$" > /dev/null; then
    echo "‚ùå ERROR: Attempting to commit .env file with potential secrets!"
    echo ""
    echo "Files about to be committed:"
    git diff --cached --name-only | grep -E "^\.env"
    echo ""
    echo "If this is intentional (committing .env.example), rename it to *.example"
    secrets_found=true
fi

if [ "$secrets_found" = true ]; then
    echo ""
    echo "Commit blocked to prevent secret leakage."
    echo "If you're sure these aren't secrets, use: git commit --no-verify"
    exit 1
fi

echo "‚úì No secrets detected"
exit 0
```

Make the hook executable:

```bash
chmod +x .git/hooks/pre-commit
```

---

### Checking for Accidentally Committed Secrets

**File Path:** `scripts/check_secrets.sh`

```bash
#!/bin/bash
# Check if secrets were accidentally committed to git history

echo "Scanning git history for potential secrets..."
echo "This may take a while for large repositories"
echo ""

# Patterns to search for
patterns=(
    "password"
    "api_key"
    "api-key"
    "apikey"
    "secret"
    "token"
    "auth"
    "credentials"
    "BEGIN.*PRIVATE KEY"
)

found=false

for pattern in "${patterns[@]}"; do
    echo "Searching for: $pattern"
    
    # Search all commits for pattern
    results=$(git log -S "$pattern" --all --oneline)
    
    if [ -n "$results" ]; then
        echo "  ‚ö†Ô∏è  Found in commits:"
        echo "$results" | head -5
        echo ""
        found=true
    fi
done

# Check for .env files in history
echo "Checking for .env files in git history..."
env_files=$(git log --all --full-history --oneline -- ".env" ".env.*" | grep -v ".env.example")

if [ -n "$env_files" ]; then
    echo "‚ùå Found .env files in git history:"
    echo "$env_files"
    echo ""
    echo "These files may contain secrets and should be removed from history!"
    found=true
fi

if [ "$found" = true ]; then
    echo ""
    echo "========================================="
    echo "ACTION REQUIRED:"
    echo "1. Rotate any exposed credentials immediately"
    echo "2. Remove secrets from git history using:"
    echo "   - BFG Repo Cleaner: https://rtyley.github.io/bfg-repo-cleaner/"
    echo "   - git filter-branch (advanced)"
    echo "3. Force push the cleaned history"
    echo "4. Notify team members to re-clone"
    echo "========================================="
else
    echo "‚úì No obvious secrets found in git history"
fi
```

---

### .env.example Template

**File Path:** `.env.example`

```bash
# ============================================
# Environment Configuration Template
# ============================================
# This file is SAFE to commit to version control
# Copy to .env and fill in real values
# ============================================

# API Configuration
API_BASE_URL=http://localhost:8000
API_KEY=your_api_key_here
API_TIMEOUT=30

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
DATABASE_POOL_SIZE=10

# Redis
REDIS_URL=redis://localhost:6379/0

# Application Settings
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG

# External Services
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/YOUR/WEBHOOK/HERE
SMTP_HOST=localhost
SMTP_PORT=1025

# Security
SECRET_KEY=generate-with-openssl-rand-hex-32
JWT_SECRET=generate-with-openssl-rand-hex-32

# ============================================
# Setup Instructions:
# ============================================
# 1. Copy this file: cp .env.example .env
# 2. Replace placeholder values with real credentials
# 3. NEVER commit .env to version control
# ============================================
```

---

## C. Connect & Apply

### How to Test It

1. **Set up .gitignore:**

```bash
# Create comprehensive .gitignore
# (use the complete .gitignore above)

# Verify .env is ignored
echo "API_KEY=secret" > .env
git status  # Should not show .env
```

2. **Create .env.example:**

```bash
# Create safe template
cat > .env.example << 'EOF'
API_KEY=your_key_here
DATABASE_URL=postgresql://localhost/db
EOF

# This should be allowed
git add .env.example
git commit -m "Add environment template"
```

3. **Install pre-commit hook:**

```bash
# Copy pre-commit hook to .git/hooks/
chmod +x .git/hooks/pre-commit

# Test it
echo "API_KEY=real_secret" >> somefile.py
git add somefile.py
git commit -m "test"  # Should be blocked!
```

### Expected Result

```
$ git status
On branch main
Untracked files:
  .env.example    # ‚úì Shown (should be committed)

# .env is NOT shown (properly ignored)

$ git add .env.example
$ git commit -m "Add template"
Running pre-commit secret check...
‚úì No secrets detected
[main abc1234] Add template

$ git add .env
$ git commit -m "Add credentials"
Running pre-commit secret check...
‚ùå ERROR: Attempting to commit .env file with potential secrets!

Files about to be committed:
.env

Commit blocked to prevent secret leakage.
```

---

## D. Common Stumbling Blocks

### Mistake #1: Adding .env to git before .gitignore

**The Problem:**

```bash
git add .                    # Accidentally adds .env
git commit -m "Initial commit"  # .env is now in history!
# Later adding .gitignore doesn't remove it from history
```

**The Fix:**

```bash
# Remove from git but keep local file
git rm --cached .env

# Add to .gitignore
echo ".env" >> .gitignore

# Commit the fix
git add .gitignore
git commit -m "Remove .env from tracking"

# Rotate any exposed credentials!
```

---

### Mistake #2: Using .gitignore comments incorrectly

**The Problem:**

```bash
# ‚ùå WRONG: This doesn't work
.env  # Don't commit this

# The comment after filename breaks the rule
```

**The Fix:**

```bash
# ‚úÖ RIGHT: Comment on separate line
# Don't commit .env files
.env
```

---

### Mistake #3: Thinking "deleted" means "gone from history"

**The Problem:**

```bash
# Committed .env with secrets
git add .env
git commit -m "Add config"

# Delete it
git rm .env
git commit -m "Remove secrets"

# Secret is still in git history!
git show HEAD~1:.env  # Still shows the secrets
```

**The Fix:**

```bash
# Must remove from ALL history
# Option 1: BFG Repo Cleaner (recommended)
bfg --delete-files .env
git reflog expire --expire=now --all
git gc --prune=now --aggressive

# Option 2: git filter-branch (advanced)
git filter-branch --force --index-filter \
  "git rm --cached --ignore-unmatch .env" \
  --prune-empty --tag-name-filter cat -- --all

# Force push
git push origin --force --all

# Rotate exposed credentials immediately!
```

---

### Mistake #4: Negation rules not working

**The Problem:**

```bash
# .gitignore
.env*          # Ignore all .env files
!.env.example  # But allow .env.example

# .env.example still ignored!
```

**The Fix:**

```bash
# ‚úÖ Order matters: specific rules before general
!.env.example     # Allow .env.example first
.env*             # Then ignore all .env files

# Or be more specific:
.env
.env.local
.env.development
.env.staging
.env.production
!.env.example
!.env.*.example
```

---

## üéØ Key Takeaways

‚úÖ **Add .gitignore FIRST** - before any commits  
‚úÖ **Never commit .env files** - only commit .example files  
‚úÖ **.env.example is safe** - use dummy values as template  
‚úÖ **Use pre-commit hooks** - prevent accidental commits  
‚úÖ **Secrets in history** - must be removed with BFG or filter-branch  
‚úÖ **Rotate exposed credentials** immediately if committed  
‚úÖ **Check git history** - scan for accidentally committed secrets  

---

## What's Next?

Next lesson: **Introduction to pydantic-settings** - type-safe, validated configuration management!

**Ready to continue?** üöÄ
