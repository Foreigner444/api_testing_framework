# Lesson 5.6: Creating .env Files

## A. Concept Overview

### What & Why
**`.env` files** are plain text files containing key-value pairs that define environment variables for your application. They're important because they provide a simple, standardized way to configure your test framework locally without cluttering your shell with export commands or hardcoding values in code.

### Analogy
Think of a `.env` file like a settings panel for your application. Just as your phone has a settings app where you can configure WiFi, notifications, and display preferences in one place, a `.env` file is where you configure all your application's settings (URLs, credentials, timeouts) in one clean, organized file.

---

## B. Code Implementation

### Basic .env File Structure

**File Path:** `.env`

```bash
# ============================================
# Development Environment Configuration
# ============================================
# This file is for local development only
# NEVER commit this file to version control
# ============================================

# --- API Configuration ---
API_BASE_URL=http://localhost:8000
API_KEY=dev_key_abc123
API_TIMEOUT=30
API_RETRY_COUNT=3

# --- Database Configuration ---
DATABASE_URL=postgresql://dev_user:dev_password@localhost:5432/test_db
DATABASE_POOL_SIZE=10
DATABASE_POOL_TIMEOUT=30

# --- Redis/Cache Configuration ---
REDIS_URL=redis://localhost:6379/0
CACHE_TTL=300

# --- Application Settings ---
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG
FEATURE_FLAG_NEW_UI=false

# --- External Services ---
SLACK_WEBHOOK_URL=
EMAIL_SMTP_HOST=localhost
EMAIL_SMTP_PORT=1025

# --- Security ---
SECRET_KEY=dev-secret-key-not-for-production
JWT_SECRET=dev-jwt-secret-12345
```

---

### .env File Best Practices

**File Path:** `.env.example` (Template - SAFE to commit)

```bash
# ============================================
# Environment Configuration Template
# ============================================
# Copy this file to .env and fill in your values
# Command: cp .env.example .env
# ============================================

# --- API Configuration ---
# The base URL for the API you're testing
API_BASE_URL=http://localhost:8000

# Your API key (get one from: https://example.com/api-keys)
API_KEY=your_api_key_here

# Request timeout in seconds
API_TIMEOUT=30

# Number of retry attempts for failed requests
API_RETRY_COUNT=3

# --- Database Configuration ---
# PostgreSQL connection string
# Format: postgresql://user:password@host:port/database
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# Connection pool settings
DATABASE_POOL_SIZE=10
DATABASE_POOL_TIMEOUT=30

# --- Redis/Cache Configuration ---
# Redis connection URL (optional)
REDIS_URL=redis://localhost:6379/0

# Cache time-to-live in seconds
CACHE_TTL=300

# --- Application Settings ---
# Environment name: development, staging, production
ENVIRONMENT=development

# Enable debug mode (true/false)
DEBUG=true

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=DEBUG

# Feature flags
FEATURE_FLAG_NEW_UI=false

# --- External Services ---
# Slack webhook for notifications (optional)
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/YOUR/WEBHOOK/URL

# Email SMTP configuration (for local testing)
EMAIL_SMTP_HOST=localhost
EMAIL_SMTP_PORT=1025

# --- Security ---
# Secret key for encryption (generate with: openssl rand -hex 32)
SECRET_KEY=your_secret_key_here

# JWT secret for token signing
JWT_SECRET=your_jwt_secret_here
```

---

### Comments and Documentation

**File Path:** `.env.development` (Well-documented)

```bash
# ============================================
# Local Development Environment
# ============================================

# API Configuration
# -----------------
# We use localhost for local development
API_BASE_URL=http://localhost:8000

# Safe development API key - okay to share in team
# This key only works with local development server
API_KEY=dev_key_abc123

# Short timeout for faster feedback during development
API_TIMEOUT=10

# Database Configuration
# ----------------------
# Local PostgreSQL instance running in Docker
# Start with: docker-compose up -d postgres
DATABASE_URL=postgresql://dev_user:dev_password@localhost:5432/test_db

# Smaller pool for local development (save resources)
DATABASE_POOL_SIZE=5

# Application Settings
# --------------------
ENVIRONMENT=development

# Enable debug mode for detailed error messages
DEBUG=true

# Verbose logging for troubleshooting
LOG_LEVEL=DEBUG

# Feature Flags
# -------------
# Enable new UI in development for testing
FEATURE_FLAG_NEW_UI=true

# Disable rate limiting in development
FEATURE_FLAG_RATE_LIMITING=false

# External Services
# -----------------
# Use MailHog for email testing (docker-compose up mailhog)
EMAIL_SMTP_HOST=localhost
EMAIL_SMTP_PORT=1025

# No Slack notifications in development (empty value)
SLACK_WEBHOOK_URL=

# Security
# --------
# Development-only secret keys (NOT for production)
SECRET_KEY=dev-secret-key-12345-not-secure
JWT_SECRET=dev-jwt-secret-67890-not-secure
```

---

### Multiple Environment Files

**File Path:** `.env.test` (Test/CI environment)

```bash
# ============================================
# Test/CI Environment Configuration
# ============================================

# API Configuration
API_BASE_URL=http://test-api:8000
API_KEY=test_key_for_ci
API_TIMEOUT=15

# In-memory SQLite for fast tests
DATABASE_URL=sqlite:///:memory:

# Mock external services in tests
SLACK_WEBHOOK_URL=
EMAIL_SMTP_HOST=localhost

# Test environment settings
ENVIRONMENT=test
DEBUG=false
LOG_LEVEL=INFO

# Enable all features for comprehensive testing
FEATURE_FLAG_NEW_UI=true
FEATURE_FLAG_RATE_LIMITING=true
```

**File Path:** `.env.staging`

```bash
# ============================================
# Staging Environment Configuration
# ============================================
# Production-like environment for final testing
# ============================================

# API Configuration
API_BASE_URL=https://api.staging.example.com
API_KEY=staging_key_abc123def456
API_TIMEOUT=30
API_RETRY_COUNT=3

# Staging database
DATABASE_URL=postgresql://staging_user:staging_pass@staging-db.example.com:5432/staging_db
DATABASE_POOL_SIZE=20

# Staging Redis
REDIS_URL=redis://staging-redis.example.com:6379/0

# Staging settings
ENVIRONMENT=staging
DEBUG=false
LOG_LEVEL=INFO

# Test features before production
FEATURE_FLAG_NEW_UI=true
FEATURE_FLAG_RATE_LIMITING=true

# Staging Slack notifications
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/STAGING/WEBHOOK/URL
```

---

### Advanced .env Patterns

**File Path:** `.env` (with variable interpolation)

```bash
# Variable interpolation (supported by python-dotenv)
PROJECT_ROOT=/home/user/projects/my_framework
DATA_DIR=${PROJECT_ROOT}/data
LOGS_DIR=${PROJECT_ROOT}/logs
REPORTS_DIR=${PROJECT_ROOT}/reports

# Construct URLs from parts
API_PROTOCOL=https
API_HOST=api.example.com
API_PORT=443
API_BASE_URL=${API_PROTOCOL}://${API_HOST}:${API_PORT}

# Database connection from parts
DB_HOST=localhost
DB_PORT=5432
DB_NAME=testdb
DB_USER=dev_user
DB_PASSWORD=dev_password
DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}
```

**File Path:** `.env` (multiline values)

```bash
# Multiline values (use quotes)
DATABASE_SSL_CERT="-----BEGIN CERTIFICATE-----
MIIDBTCCAe2gAwIBAgIJAJZQ3t1NLjxGMA0GCSqGSIb3DQEBCwUAMBkxFzAVBgNV
BAMMDmxvY2FsaG9zdDo1NDMyMB4XDTE5MDUxNjE3MjQwNFoXDTI5MDUxMzE3MjQw
NFowGTEXMBUGA1UEAwwObG9jYWxob3N0OjU0MzIwggEiMA0GCSqGSIb3DQEBAQUA
-----END CERTIFICATE-----"

# JSON configuration
FEATURE_FLAGS={"new_ui": true, "dark_mode": false, "beta_features": true}

# List values (comma-separated)
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8000,https://app.example.com
```

---

### Creating .env Files Programmatically

**File Path:** `scripts/create_env_file.py`

```python
#!/usr/bin/env python3
"""
Script to create .env file interactively.
Run this to help new team members set up their environment.
"""

from pathlib import Path


def create_env_file():
    """
    Interactive script to create .env file from .env.example.
    """
    env_example = Path(".env.example")
    env_file = Path(".env")
    
    # Check if .env already exists
    if env_file.exists():
        response = input(".env file already exists. Overwrite? (y/N): ")
        if response.lower() != 'y':
            print("Aborting. Existing .env file preserved.")
            return
    
    # Check if .env.example exists
    if not env_example.exists():
        print("Error: .env.example not found!")
        print("Create .env.example first as a template.")
        return
    
    print("Creating .env file from .env.example...")
    print("=" * 50)
    
    # Read .env.example
    with open(env_example) as f:
        lines = f.readlines()
    
    # Process each line
    new_lines = []
    for line in lines:
        stripped = line.strip()
        
        # Keep comments and empty lines as-is
        if not stripped or stripped.startswith('#'):
            new_lines.append(line)
            continue
        
        # Parse key=value
        if '=' in stripped:
            key, default_value = stripped.split('=', 1)
            
            # Prompt user for value
            print(f"\n{key}")
            print(f"  Default: {default_value}")
            user_value = input(f"  Enter value (or press Enter for default): ").strip()
            
            # Use user value or default
            final_value = user_value if user_value else default_value
            new_lines.append(f"{key}={final_value}\n")
        else:
            # Malformed line, keep as-is
            new_lines.append(line)
    
    # Write .env file
    with open(env_file, 'w') as f:
        f.writelines(new_lines)
    
    print("\n" + "=" * 50)
    print(f"âœ… Created {env_file}")
    print("\nNext steps:")
    print("1. Review your .env file")
    print("2. Run: pytest tests/ -v")


if __name__ == "__main__":
    create_env_file()
```

---

### Line-by-Line Explanation

**In basic `.env` file:**

- `# Comments`: Lines starting with `#` are ignored
- `KEY=value`: Basic key-value assignment (no spaces around `=`)
- `KEY=`: Empty value (variable is set but empty)
- Group related settings with comment headers for organization
- Use UPPERCASE for environment variables (convention)

**In `.env.example`:**

- Contains all required variables with placeholder values
- Safe to commit to git (no real secrets)
- Acts as documentation for team members
- Shows format and expected values

**In environment-specific files:**

- `.env.development`: Local development settings
- `.env.test`: CI/CD test settings
- `.env.staging`: Pre-production testing
- `.env.production`: Never in git, only in secure storage

**In interpolation example:**

- `${VARIABLE}`: Reference another variable's value
- Build complex values from simple parts
- Keep configuration DRY (Don't Repeat Yourself)

---

### The "Why" Behind the Code

**Why separate .env files per environment?**

1. **Security**: Development credentials separate from production
2. **Safety**: Can't accidentally test against production
3. **Clarity**: Clear which values are for which environment
4. **Access Control**: Developers only need dev credentials
5. **Simplicity**: One file per context, easy to understand

**Why .env.example?**

1. **Onboarding**: New team members know what to configure
2. **Documentation**: Shows all required variables
3. **Validation**: Can check if .env has all required keys
4. **Git-Safe**: No secrets, but shows structure

**Why comments in .env?**

`.env` files are configuration and documentation. Good comments help:
- Explain purpose of each variable
- Show expected format or valid values
- Link to where to get credentials
- Describe dependencies (e.g., "Start Docker first")

---

## C. Connect & Apply

### How to Test It

1. **Create .env.example (safe to commit):**

```bash
cat > .env.example << 'EOF'
# API Configuration
API_BASE_URL=http://localhost:8000
API_KEY=your_api_key_here
API_TIMEOUT=30

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# Application
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG
EOF
```

2. **Create your personal .env:**

```bash
cp .env.example .env

# Edit .env with your actual values
cat > .env << 'EOF'
API_BASE_URL=http://localhost:8000
API_KEY=dev_key_abc123
API_TIMEOUT=10

DATABASE_URL=postgresql://myuser:mypass@localhost:5432/testdb

ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG
EOF
```

3. **Update .gitignore:**

```bash
cat >> .gitignore << 'EOF'
# Environment files
.env
.env.local
.env.*.local
.env.development
.env.staging
.env.production

# Keep .env.example in git
!.env.example
EOF
```

4. **Test loading .env:**

```python
# test_env.py
from dotenv import load_dotenv
import os

load_dotenv()

print("Loaded configuration:")
print(f"  API_BASE_URL: {os.getenv('API_BASE_URL')}")
print(f"  ENVIRONMENT: {os.getenv('ENVIRONMENT')}")
print(f"  DEBUG: {os.getenv('DEBUG')}")
```

### Expected Result

```
$ python test_env.py
Loaded configuration:
  API_BASE_URL: http://localhost:8000
  ENVIRONMENT: development
  DEBUG: true
```

---

## D. Common Stumbling Blocks

### Mistake #1: Spaces around equals sign

**The Problem:**

```bash
# âŒ WRONG: Spaces around =
API_KEY = dev_key_123
API_URL = http://localhost

# This creates variables with spaces in the name!
# "API_KEY " and " dev_key_123" (with spaces)
```

**The Fix:**

```bash
# âœ… RIGHT: No spaces around =
API_KEY=dev_key_123
API_URL=http://localhost
```

---

### Mistake #2: Quotes when not needed

**The Problem:**

```bash
# These are different!
API_KEY=dev_key_123        # Value: dev_key_123
API_KEY="dev_key_123"      # Value: "dev_key_123" (includes quotes!)
API_KEY='dev_key_123'      # Value: 'dev_key_123' (includes quotes!)
```

**When to use quotes:**

```bash
# âœ… Use quotes for values with spaces
MESSAGE="Hello World"

# âœ… Use quotes for multiline values
CERT="line1
line2
line3"

# âŒ Don't use quotes for simple values
API_KEY=abc123          # Good
API_KEY="abc123"        # Unnecessary, value includes quotes
```

---

### Mistake #3: Committing .env to git

**The Problem:**

```bash
$ git add .
$ git commit -m "Add config"
$ git push
# âš ï¸ Just committed your API keys to public GitHub!
```

**How to check:**

```bash
# Check if .env is tracked by git
git ls-files | grep "\.env$"

# If it shows .env, you need to fix it
```

**The Fix:**

```bash
# 1. Add to .gitignore
echo ".env" >> .gitignore

# 2. Remove from git (but keep local file)
git rm --cached .env

# 3. Commit the fix
git commit -m "Remove .env from version control"

# 4. Rotate any exposed credentials immediately
# (Change API keys, passwords, etc.)
```

---

### Mistake #4: Missing .env file

**The Problem:**

```python
from dotenv import load_dotenv
import os

load_dotenv()  # Silently does nothing if .env doesn't exist
api_key = os.environ["API_KEY"]  # KeyError!
```

**The Fix:**

```python
# Check if .env was loaded
from dotenv import load_dotenv
from pathlib import Path
import os

env_file = Path(".env")
if not env_file.exists():
    print("Warning: .env file not found!")
    print("Create one with: cp .env.example .env")
else:
    load_dotenv()

# Use get() with helpful error message
api_key = os.getenv("API_KEY")
if not api_key:
    raise ValueError(
        "API_KEY not found. "
        "Set it in .env or export API_KEY=your_key"
    )
```

---

## ðŸŽ¯ Key Takeaways

âœ… **`.env` files** store configuration as KEY=value pairs  
âœ… **No spaces** around the equals sign  
âœ… **Use .env.example** as a template (commit this one)  
âœ… **Never commit** actual .env files (add to .gitignore)  
âœ… **Add comments** to explain configuration options  
âœ… **One file per environment** (.env.development, .env.staging, etc.)  
âœ… **Quotes only needed** for values with spaces or special characters  

---

## What's Next?

Now that you know how to create `.env` files, the next lesson will cover **Loading Environment Variables** with python-dotenv and ensuring your configuration is loaded correctly every time!

**Ready to continue?** ðŸš€
