# Lesson 5.13: Automatic .env Loading

## A. Concept Overview

### What & Why
**Automatic .env loading** in pydantic-settings means the library automatically searches for and loads environment files without requiring explicit python-dotenv calls. This is important because it eliminates boilerplate code, reduces errors from forgetting to call load_dotenv(), and provides consistent configuration loading behavior across your framework.

### Analogy
Think of automatic .env loading like a smart TV that automatically connects to your WiFi network. You don't have to manually enter connection commands every timeâ€”it remembers the network and connects automatically. Similarly, pydantic-settings automatically finds and loads your .env file without explicit loading code.

---

## B. Code Implementation

### Basic Automatic Loading

**File Path:** `config/settings.py`

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """
    Settings with automatic .env loading.
    
    When Settings() is instantiated, pydantic-settings automatically:
    1. Looks for .env file in current directory
    2. Loads variables from it
    3. Merges with system environment variables
    4. System env vars take precedence over .env
    """
    
    api_base_url: str
    api_key: str
    api_timeout: int = 30
    
    model_config = SettingsConfigDict(
        # Automatically load from .env file
        env_file=".env",
        env_file_encoding="utf-8",
        
        # Case-insensitive variable names
        # API_KEY, api_key, Api_Key all match
        case_sensitive=False
    )


# No need for load_dotenv()! Just instantiate:
settings = Settings()
```

---

### Specifying Custom .env File Paths

**File Path:** `config/advanced_settings.py`

```python
from pathlib import Path
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Settings with custom .env file path."""
    
    api_key: str
    database_url: str
    
    model_config = SettingsConfigDict(
        # Absolute path
        env_file="/path/to/project/.env",
        
        # Or relative to current working directory
        env_file=".env",
        
        # Or build path dynamically
        env_file=str(Path(__file__).parent.parent / ".env"),
    )


# Alternative: Pass env_file at instantiation
class FlexibleSettings(BaseSettings):
    """Settings where .env file can be specified at runtime."""
    
    api_key: str
    
    model_config = SettingsConfigDict(
        # Default, can be overridden
        env_file=".env"
    )


# Override at instantiation
settings_dev = FlexibleSettings(_env_file=".env.development")
settings_prod = FlexibleSettings(_env_file=".env.production")
```

---

### Environment Variable Prefix

**File Path:** `config/prefixed_settings.py`

```python
from pydantic_settings import BaseSettings, SettingsConfigDict


class AppSettings(BaseSettings):
    """
    Settings with environment variable prefix.
    
    With env_prefix="APP_", pydantic looks for:
    - APP_API_KEY (not just API_KEY)
    - APP_DATABASE_URL (not just DATABASE_URL)
    
    Useful when multiple applications share the same environment.
    """
    
    api_key: str          # Looks for APP_API_KEY
    database_url: str      # Looks for APP_DATABASE_URL
    timeout: int = 30      # Looks for APP_TIMEOUT
    
    model_config = SettingsConfigDict(
        env_file=".env",
        env_prefix="APP_",
        case_sensitive=False
    )


# .env file would contain:
# APP_API_KEY=abc123
# APP_DATABASE_URL=postgresql://localhost/db
# APP_TIMEOUT=60
```

---

### Nested .env Configuration

**File Path:** `config/nested_env.py`

```python
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class DatabaseSettings(BaseSettings):
    """Nested database configuration."""
    
    host: str = "localhost"
    port: int = 5432
    name: str = "testdb"
    user: str = "postgres"
    password: str = "password"
    
    model_config = SettingsConfigDict(
        env_prefix="DB_",  # DB_HOST, DB_PORT, DB_NAME, etc.
    )


class Settings(BaseSettings):
    """Main settings with nested database config."""
    
    api_key: str
    database: DatabaseSettings = Field(default_factory=DatabaseSettings)
    
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False,
        # Nested models automatically use their own env_prefix
    )


# .env file:
# API_KEY=abc123
# DB_HOST=db.example.com
# DB_PORT=5432
# DB_NAME=production_db
# DB_USER=admin
# DB_PASSWORD=secret

settings = Settings()
print(f"Database host: {settings.database.host}")
```

---

### Multiple .env Files

**File Path:** `config/multi_env.py`

```python
from typing import Tuple
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """
    Load from multiple .env files.
    
    Files are loaded in order, later files override earlier ones.
    """
    
    api_key: str
    database_url: str
    debug: bool = False
    
    model_config = SettingsConfigDict(
        # Load from multiple files
        env_file=(
            ".env",              # Base configuration
            ".env.local",        # Local overrides
        ),
        env_file_encoding="utf-8",
        case_sensitive=False
    )


# Even more flexible: pass tuple at instantiation
class DynamicSettings(BaseSettings):
    """Allow specifying multiple env files at runtime."""
    
    api_key: str
    
    model_config = SettingsConfigDict()


# Load from multiple files
settings = DynamicSettings(
    _env_file=(".env", ".env.development", ".env.development.local")
)
```

---

## C. Connect & Apply

### How to Test It

1. **Test automatic loading:**

```python
# config/settings.py
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    api_key: str
    debug: bool = False
    
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False
    )

# NO load_dotenv() needed!
```

2. **Create .env:**

```bash
cat > .env << 'EOF'
API_KEY=test_key_123
DEBUG=true
EOF
```

3. **Test it:**

```python
python -c "
from config.settings import Settings

# Automatically loads from .env
settings = Settings()

print(f'API Key: {settings.api_key}')
print(f'Debug: {settings.debug}')
print(f'Debug type: {type(settings.debug)}')
"
```

4. **Test prefix:**

```python
# Create settings with prefix
cat > .env << 'EOF'
APP_API_KEY=prefixed_key
APP_DEBUG=true
EOF

python -c "
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    api_key: str
    debug: bool = False
    
    model_config = SettingsConfigDict(
        env_file='.env',
        env_prefix='APP_'
    )

s = Settings()
print(f'API Key: {s.api_key}')
"
```

### Expected Result

```
# Automatic loading:
API Key: test_key_123
Debug: True
Debug type: <class 'bool'>

# With prefix:
API Key: prefixed_key
```

---

## D. Common Stumbling Blocks

### Mistake #1: .env file in wrong location

**The Problem:**

```python
# config/settings.py
class Settings(BaseSettings):
    api_key: str
    
    model_config = SettingsConfigDict(
        env_file=".env"  # Relative to CWD, not this file!
    )

# .env is in project root, but you run:
cd tests/
pytest .  # CWD is tests/, can't find .env
```

**The Fix:**

```python
from pathlib import Path

# Make path relative to this file
BASE_DIR = Path(__file__).parent.parent

class Settings(BaseSettings):
    api_key: str
    
    model_config = SettingsConfigDict(
        env_file=str(BASE_DIR / ".env")  # Always finds it
    )
```

---

### Mistake #2: Forgetting env_file doesn't override system env vars

**The Problem:**

```bash
export API_KEY="from_system"
# .env has: API_KEY=from_file

python -c "from config.settings import Settings; print(Settings().api_key)"
# Output: from_system (not from_file!)
```

**Why:** System environment variables ALWAYS take precedence over .env files (security feature).

**The Fix:** This is intended behavior. To override system vars, use:

```python
model_config = SettingsConfigDict(
    env_file=".env",
    # This is dangerous - only use in specific test scenarios
    env_file_override=True  # NOT recommended for production
)
```

---

### Mistake #3: Expecting error when .env missing

**The Problem:**

```python
class Settings(BaseSettings):
    api_key: str
    
    model_config = SettingsConfigDict(
        env_file=".env"  # File doesn't exist
    )

# No error! Just looks for system env vars
settings = Settings()  # Only fails if API_KEY not in system env either
```

**The Fix:**

```python
from pathlib import Path

env_file = Path(".env")
if not env_file.exists():
    raise FileNotFoundError(f".env file not found at {env_file.absolute()}")

class Settings(BaseSettings):
    api_key: str
    
    model_config = SettingsConfigDict(
        env_file=str(env_file)
    )
```

---

## ðŸŽ¯ Key Takeaways

âœ… **pydantic-settings** automatically loads .env files via env_file config  
âœ… **No load_dotenv() needed** - automatic loading is built-in  
âœ… **env_prefix** allows prefixing all environment variable names  
âœ… **Multiple files** can be loaded with tuple of paths  
âœ… **System env vars** always take precedence over .env files  
âœ… **Relative paths** are relative to current working directory, not the settings file  
âœ… **Missing .env** doesn't cause error - falls back to system env vars  

---

## What's Next?

Next lesson: **Field Validation in Settings** - custom validation logic for configuration fields!

**Ready to continue?** ðŸš€
