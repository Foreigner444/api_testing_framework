# Lesson 5.23: Configuration Validation on Startup

## A. Concept Overview

### What & Why
**Configuration validation on startup** ensures all required settings are present and valid before any tests or application code runs. Critical for fail-fast behaviorâ€”finding configuration errors immediately rather than discovering them mid-test execution.

### Analogy
Validation on startup is like a pilot's pre-flight checklist. Before takeoff (before running tests), verify fuel levels (required configs), check instruments (validate formats), and test controls (validate constraints). Catch problems on the ground, not in the air.

---

## B. Code Implementation

```python
from typing import List
from pydantic import field_validator, model_validator
from pydantic_settings import BaseSettings, SettingsConfigDict
import sys


class ValidatedSettings(BaseSettings):
    """Settings with comprehensive startup validation."""
    
    # Required fields
    api_key: str
    api_base_url: str
    database_url: str
    
    # Optional with defaults
    timeout: int = 30
    max_retries: int = 3
    environment: str = "development"
    
    # Field-level validation
    @field_validator("api_key")
    @classmethod
    def validate_api_key(cls, v: str) -> str:
        if len(v) < 10:
            raise ValueError("API key must be at least 10 characters")
        return v
    
    @field_validator("api_base_url")
    @classmethod
    def validate_url(cls, v: str) -> str:
        if not v.startswith(("http://", "https://")):
            raise ValueError(f"Invalid URL format: {v}")
        return v.rstrip("/")
    
    @field_validator("database_url")
    @classmethod
    def validate_database_url(cls, v: str) -> str:
        if not v.startswith(("postgresql://", "mysql://", "sqlite://")):
            raise ValueError(f"Unsupported database URL: {v}")
        return v
    
    @field_validator("environment")
    @classmethod
    def validate_environment(cls, v: str) -> str:
        allowed = ["development", "staging", "production", "test"]
        if v not in allowed:
            raise ValueError(f"Environment must be one of {allowed}")
        return v
    
    # Model-level validation
    @model_validator(mode='after')
    def validate_production_settings(self):
        """Additional validation for production environment."""
        if self.environment == "production":
            if "localhost" in self.api_base_url:
                raise ValueError(
                    "Production cannot use localhost URLs"
                )
            if self.api_key == "dev_key" or "test" in self.api_key:
                raise ValueError(
                    "Production requires secure API key"
                )
        return self
    
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False,
        validate_default=True  # Validate even default values
    )


def validate_and_load_settings() -> ValidatedSettings:
    """
    Load and validate settings with detailed error reporting.
    
    This function should be called at application/test startup.
    """
    print("Validating configuration...")
    
    try:
        settings = ValidatedSettings()
        
        print("âœ“ Configuration valid")
        print(f"  Environment: {settings.environment}")
        print(f"  API URL: {settings.api_base_url}")
        print(f"  Database: {settings.database_url.split('@')[0]}@...")
        
        return settings
        
    except Exception as e:
        print("\n" + "=" * 60)
        print("âŒ CONFIGURATION ERROR")
        print("=" * 60)
        print(f"\n{str(e)}\n")
        print("Please fix your configuration before running tests.")
        print("=" * 60)
        
        # Exit immediately - don't run tests with bad config
        sys.exit(1)
```

---

### Startup Validation in conftest.py

```python
"""
conftest.py - pytest configuration with startup validation
"""

from config.settings import validate_and_load_settings


# Validate configuration before ANY tests run
print("\n" + "=" * 60)
print("STARTUP VALIDATION")
print("=" * 60)

settings = validate_and_load_settings()

print("=" * 60 + "\n")


def pytest_configure(config):
    """Hook called after command line options are parsed."""
    # Configuration already validated above
    pass


def pytest_sessionstart(session):
    """
    Called after Session object created, before test collection.
    
    Configuration is already validated, so we can safely
    proceed with test execution.
    """
    print(f"Running tests in {settings.environment} environment\n")
```

---

### Custom Validation Rules

```python
from pydantic import field_validator
from pydantic_settings import BaseSettings
import re


class AdvancedValidation(BaseSettings):
    """Settings with advanced validation rules."""
    
    # Email validation
    admin_email: str
    
    @field_validator("admin_email")
    @classmethod
    def validate_email(cls, v: str) -> str:
        pattern = r"^[\w\.-]+@[\w\.-]+\.\w+$"
        if not re.match(pattern, v):
            raise ValueError(f"Invalid email format: {v}")
        return v
    
    # Port range validation
    api_port: int
    
    @field_validator("api_port")
    @classmethod
    def validate_port(cls, v: int) -> int:
        if not (1 <= v <= 65535):
            raise ValueError(f"Port must be 1-65535, got: {v}")
        return v
    
    # List validation
    allowed_hosts: List[str]
    
    @field_validator("allowed_hosts")
    @classmethod
    def validate_hosts(cls, v: List[str]) -> List[str]:
        if not v:
            raise ValueError("At least one allowed host required")
        for host in v:
            if not host or host.isspace():
                raise ValueError(f"Invalid host: '{host}'")
        return v
```

---

## C. Connect & Apply

### How to Test It

```bash
# Test with INVALID config
cat > .env << 'EOF'
API_KEY=short
API_BASE_URL=not-a-url
DATABASE_URL=invalid://db
ENVIRONMENT=production
EOF

python -c "
from config.settings import validate_and_load_settings
validate_and_load_settings()
"

# Should fail with clear error messages
```

```bash
# Test with VALID config
cat > .env << 'EOF'
API_KEY=valid_key_1234567890
API_BASE_URL=https://api.example.com
DATABASE_URL=postgresql://localhost/testdb
ENVIRONMENT=development
EOF

python -c "
from config.settings import validate_and_load_settings
settings = validate_and_load_settings()
print('âœ“ Configuration validated successfully')
"
```

### Expected Result

```
# With invalid config:
============================================================
âŒ CONFIGURATION ERROR
============================================================

API key must be at least 10 characters

Please fix your configuration before running tests.
============================================================

# With valid config:
Validating configuration...
âœ“ Configuration valid
  Environment: development
  API URL: https://api.example.com
  Database: postgresql://localhost...
```

---

## D. Common Stumbling Blocks

### Mistake #1: Validation happens too late

**The Problem:**

```python
# Tests start running
def test_api():
    settings = Settings()  # Validation error here!
    # Already wasted time collecting tests
```

**The Fix:**

```python
# conftest.py - validate BEFORE test collection
settings = validate_and_load_settings()
```

---

### Mistake #2: Validation errors are unclear

**The Problem:**

```
ValidationError: 1 validation error for Settings
api_key
  field required
```

User thinks: "What's an api_key? Where do I set it?"

**The Fix:**

```python
try:
    settings = Settings()
except ValidationError as e:
    print("\nConfiguration Error:")
    print("API_KEY environment variable is required")
    print("Set it with: export API_KEY=your_key")
    print("Or add to .env file: API_KEY=your_key")
    sys.exit(1)
```

---

## ðŸŽ¯ Key Takeaways

âœ… **Validate at startup** before running any tests  
âœ… **Fail fast** with clear error messages  
âœ… **Use field_validator** for field-level validation  
âœ… **Use model_validator** for cross-field validation  
âœ… **Provide helpful errors** that guide users to fix issues  
âœ… **Exit with sys.exit(1)** on validation failure  

---

## What's Next?

Next: **Creating Config Fixtures** - pytest fixtures for configuration management!

**Ready to continue?** ðŸš€
