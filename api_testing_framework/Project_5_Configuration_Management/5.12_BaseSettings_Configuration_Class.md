# Lesson 5.12: BaseSettings Configuration Class

## A. Concept Overview

### What & Why
**BaseSettings** is the foundational class from pydantic-settings for creating type-safe configuration classes. It provides automatic environment variable loading, type conversion, validation, and helpful error messagesâ€”essential for building robust, production-ready test frameworks where configuration errors must be caught early.

### Analogy
Think of BaseSettings like a blueprint for a house with built-in inspections. Just as a house blueprint specifies room types, dimensions, and required features, and inspectors verify everything meets code before occupancy, BaseSettings defines your configuration structure with types and requirements, then validates everything is correct before your application runs.

---

## B. Code Implementation

### Complete Settings Class Example

**File Path:** `config/settings.py`

```python
from typing import Optional, List
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """
    Complete application configuration with validation.
    
    This class demonstrates all key BaseSettings features:
    - Required and optional fields
    - Default values
    - Type conversion
    - Field aliases
    - Validation
    - Documentation
    """
    
    # === API Configuration ===
    api_base_url: str = Field(
        ...,  # Required field
        description="Base URL for API endpoints",
        examples=["http://localhost:8000", "https://api.example.com"]
    )
    
    api_key: str = Field(
        ...,
        description="API authentication key",
        min_length=10
    )
    
    api_timeout: int = Field(
        default=30,
        description="Request timeout in seconds",
        ge=1,  # Greater than or equal to 1
        le=300  # Less than or equal to 300
    )
    
    api_max_retries: int = Field(
        default=3,
        description="Maximum number of retry attempts",
        ge=0,
        le=10
    )
    
    # === Database Configuration ===
    database_url: str = Field(
        default="sqlite:///./test.db",
        description="Database connection string"
    )
    
    database_pool_size: int = Field(
        default=10,
        description="Database connection pool size",
        ge=1,
        le=100
    )
    
    # === Application Settings ===
    environment: str = Field(
        default="development",
        description="Application environment"
    )
    
    debug: bool = Field(
        default=False,
        description="Enable debug mode"
    )
    
    log_level: str = Field(
        default="INFO",
        description="Logging level",
    )
    
    # === Optional Features ===
    redis_url: Optional[str] = Field(
        default=None,
        description="Redis connection URL (optional)"
    )
    
    slack_webhook_url: Optional[str] = Field(
        default=None,
        description="Slack webhook for notifications (optional)"
    )
    
    allowed_hosts: List[str] = Field(
        default=["localhost"],
        description="List of allowed hosts"
    )
    
    # === Field Validation ===
    @field_validator("environment")
    @classmethod
    def validate_environment(cls, v: str) -> str:
        """Ensure environment is one of the allowed values."""
        allowed = ["development", "staging", "production", "test"]
        if v not in allowed:
            raise ValueError(f"Environment must be one of {allowed}, got: {v}")
        return v
    
    @field_validator("log_level")
    @classmethod
    def validate_log_level(cls, v: str) -> str:
        """Ensure log level is valid."""
        allowed = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        v_upper = v.upper()
        if v_upper not in allowed:
            raise ValueError(f"Log level must be one of {allowed}, got: {v}")
        return v_upper
    
    # === Pydantic Settings Configuration ===
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="ignore",  # Ignore extra fields in env
    )
    
    def summary(self) -> str:
        """Return a summary of current configuration."""
        return f"""
Configuration Summary:
  Environment: {self.environment}
  API Base URL: {self.api_base_url}
  API Timeout: {self.api_timeout}s
  Debug Mode: {self.debug}
  Log Level: {self.log_level}
  Database: {self.database_url}
  Redis: {'Configured' if self.redis_url else 'Not configured'}
"""


# Singleton pattern
_settings: Optional[Settings] = None


def get_settings() -> Settings:
    """Get cached settings instance."""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings


def reset_settings() -> None:
    """Reset settings (useful for testing)."""
    global _settings
    _settings = None
```

---

### Field Options and Constraints

**File Path:** `examples/field_examples.py`

```python
from typing import Optional
from pydantic import Field
from pydantic_settings import BaseSettings


class FieldExamples(BaseSettings):
    """Examples of different field types and constraints."""
    
    # String fields
    required_string: str                                    # Required, no default
    optional_string: Optional[str] = None                   # Truly optional
    string_with_default: str = "default_value"              # Optional with default
    
    # Numeric fields with constraints
    positive_int: int = Field(ge=1)                         # >= 1
    percentage: int = Field(ge=0, le=100)                   # 0-100
    port_number: int = Field(ge=1, le=65535)                # Valid port range
    
    # String constraints
    api_key: str = Field(min_length=10, max_length=100)     # Length constraints
    email: str = Field(pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$") # Regex pattern
    
    # Boolean fields
    debug: bool = False                                     # Auto-converts "true"/"1"/"yes"
    
    # Lists
    tags: List[str] = Field(default_factory=list)           # Empty list default
    hosts: List[str] = ["localhost"]                        # List with default items
    
    # Field aliases (alternative env var names)
    api_url: str = Field(alias="BASE_URL")                  # Can use BASE_URL env var
    
    # Field documentation
    timeout: int = Field(
        default=30,
        description="Request timeout in seconds",
        examples=[10, 30, 60]
    )
```

---

## C. Connect & Apply

### How to Test It

1. **Create settings class:**

```python
# config/settings.py (use complete example above)
```

2. **Create .env file:**

```bash
cat > .env << 'EOF'
API_BASE_URL=http://localhost:8000
API_KEY=test_key_1234567890
API_TIMEOUT=15
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=debug
DATABASE_URL=postgresql://localhost/testdb
ALLOWED_HOSTS=localhost,127.0.0.1,example.com
EOF
```

3. **Test loading:**

```python
python -c "
from config.settings import get_settings

settings = get_settings()
print(settings.summary())
print(f'\\nTypes:')
print(f'  api_timeout: {type(settings.api_timeout).__name__}')
print(f'  debug: {type(settings.debug).__name__}')
print(f'  allowed_hosts: {type(settings.allowed_hosts).__name__}')
"
```

4. **Test validation:**

```python
# Test invalid environment
python -c "
import os
os.environ['ENVIRONMENT'] = 'invalid_env'
os.environ['API_BASE_URL'] = 'http://localhost'
os.environ['API_KEY'] = 'test_key_1234567890'

from config.settings import Settings
try:
    settings = Settings()
except Exception as e:
    print(f'Validation error (expected): {e}')
"
```

### Expected Result

```
Configuration Summary:
  Environment: development
  API Base URL: http://localhost:8000
  API Timeout: 15s
  Debug Mode: True
  Log Level: DEBUG
  Database: postgresql://localhost/testdb
  Redis: Not configured

Types:
  api_timeout: int
  debug: bool
  allowed_hosts: list

# With invalid environment:
Validation error (expected): 1 validation error for Settings
environment
  Value error, Environment must be one of ['development', 'staging', 'production', 'test'], got: invalid_env
```

---

## D. Common Stumbling Blocks

### Mistake #1: Forgetting model_config in Pydantic v2

**The Problem:**

```python
# âŒ Pydantic v1 syntax (doesn't work in v2)
class Settings(BaseSettings):
    api_key: str
    
    class Config:
        env_file = ".env"
```

**The Fix:**

```python
# âœ… Pydantic v2 syntax
from pydantic_settings import SettingsConfigDict

class Settings(BaseSettings):
    api_key: str
    
    model_config = SettingsConfigDict(
        env_file=".env"
    )
```

---

### Mistake #2: Using ... incorrectly

**The Problem:**

```python
# âŒ Confusing syntax
api_key: str = Field(...)  # What does ... mean?
```

**Explanation:**

```python
# ... means "required field" in Pydantic
api_key: str                     # Also required
api_key: str = Field(...)        # Required (explicit)
api_key: str = Field(default=...) # Also required

# These are optional:
api_key: str = "default"         # Optional with default
api_key: Optional[str] = None    # Optional, can be None
```

---

### Mistake #3: Field constraints not validating

**The Problem:**

```python
class Settings(BaseSettings):
    timeout: int = Field(ge=1, le=300)

# Set invalid value
import os
os.environ["TIMEOUT"] = "500"

settings = Settings()
print(settings.timeout)  # Why is this 500? Should fail!
```

**Root Cause:**

This actually WILL fail. But if you're not seeing validation, check:

```python
# Make sure you're using Field correctly:
from pydantic import Field  # âœ“ Correct import

# Not:
from pydantic_settings import Field  # âœ— Wrong (doesn't exist)
```

---

## ðŸŽ¯ Key Takeaways

âœ… **BaseSettings** is the foundation for type-safe configuration  
âœ… **Field()** provides constraints, validation, and documentation  
âœ… **model_config** (v2) replaces Config class (v1)  
âœ… **Required fields** have no default or use Field(...)  
âœ… **Validation happens automatically** at instantiation  
âœ… **Use validators** for complex validation logic  
âœ… **Singleton pattern** ensures one settings instance  

---

## What's Next?

Next lesson: **Automatic .env Loading** - how pydantic-settings finds and loads environment files automatically!

**Ready to continue?** ðŸš€
