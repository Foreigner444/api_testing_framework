# Lesson 5.25: Environment Switching in Tests

## A. Concept Overview

### What & Why
**Environment switching in tests** allows running the same test suite against multiple environments (dev, staging, production) to verify consistent behavior across deployments. Essential for comprehensive testing strategies and catching environment-specific issues.

### Analogy
Environment switching is like a car safety test that runs the same crash test on summer tires, winter tires, and all-season tires. Same test, different conditions, ensuring the car performs safely regardless of environment.

---

## B. Code Implementation

### Environment-Aware Test Suite

**File Path:** `conftest.py`

```python
import pytest
import os
from config.settings import Settings


def pytest_addoption(parser):
    """Add command-line option for environment selection."""
    parser.addoption(
        "--env",
        action="store",
        default="development",
        help="Environment to test against: development, staging, production"
    )


@pytest.fixture(scope="session")
def target_environment(request):
    """Get target environment from command line."""
    return request.config.getoption("--env")


@pytest.fixture(scope="session")
def settings(target_environment):
    """Load settings for target environment."""
    env_file = f".env.{target_environment}"
    print(f"\nLoading configuration: {env_file}")
    
    return Settings(_env_file=env_file)


@pytest.fixture(scope="session")
def api_client(settings):
    """Create API client for target environment."""
    import httpx
    
    client = httpx.Client(
        base_url=settings.api_base_url,
        headers={"Authorization": f"Bearer {settings.api_key}"},
        timeout=settings.api_timeout
    )
    
    print(f"API Client configured for: {settings.api_base_url}")
    
    yield client
    client.close()
```

---

### Environment-Specific Test Markers

**File Path:** `conftest.py` (continued)

```python
def pytest_configure(config):
    """Register custom markers."""
    config.addinivalue_line(
        "markers", "dev_only: mark test to run only in development"
    )
    config.addinivalue_line(
        "markers", "staging_only: mark test to run only in staging"
    )
    config.addinivalue_line(
        "markers", "prod_safe: mark test as safe to run in production"
    )
    config.addinivalue_line(
        "markers", "destructive: mark test as destructive (not for production)"
    )


def pytest_runtest_setup(item):
    """Skip tests based on environment and markers."""
    target_env = item.config.getoption("--env")
    
    # Skip dev-only tests in other environments
    if list(item.iter_markers(name="dev_only")):
        if target_env != "development":
            pytest.skip(f"Test only runs in development, current: {target_env}")
    
    # Skip staging-only tests in other environments
    if list(item.iter_markers(name="staging_only")):
        if target_env != "staging":
            pytest.skip(f"Test only runs in staging, current: {target_env}")
    
    # Skip destructive tests in production
    if list(item.iter_markers(name="destructive")):
        if target_env == "production":
            pytest.skip("Destructive test skipped in production")
    
    # Only run prod_safe tests in production
    if target_env == "production":
        if not list(item.iter_markers(name="prod_safe")):
            pytest.skip("Only prod_safe tests run in production")
```

---

### Writing Environment-Aware Tests

**File Path:** `tests/test_multi_env.py`

```python
import pytest


@pytest.mark.prod_safe
def test_api_health(api_client):
    """Safe to run in all environments including production."""
    response = api_client.get("/health")
    assert response.status_code == 200


@pytest.mark.destructive
def test_delete_all_users(api_client):
    """Destructive test - never runs in production."""
    response = api_client.delete("/users/all")
    assert response.status_code == 200


@pytest.mark.dev_only
def test_debug_endpoints(api_client):
    """Development-only test for debug endpoints."""
    response = api_client.get("/debug/info")
    assert response.status_code == 200


@pytest.mark.staging_only
def test_staging_specific_feature(api_client):
    """Test feature only available in staging."""
    response = api_client.get("/beta/feature")
    assert response.status_code == 200


def test_environment_specific_behavior(settings):
    """Test that adapts behavior based on environment."""
    if settings.environment == "production":
        # Stricter validation in production
        assert settings.debug == False
        assert settings.log_level == "WARNING"
    elif settings.environment == "development":
        # Relaxed in development
        assert settings.debug == True
```

---

### Running Tests Against Different Environments

**File Path:** `scripts/test_all_environments.sh`

```bash
#!/bin/bash
# Test suite across all environments

echo "==========================================="
echo "Running Tests Across All Environments"
echo "==========================================="

# Test development
echo "\n--- Testing DEVELOPMENT ---"
pytest --env=development -v

# Test staging
echo "\n--- Testing STAGING ---"
pytest --env=staging -v

# Test production (only safe tests)
echo "\n--- Testing PRODUCTION (safe tests only) ---"
pytest --env=production -v -m prod_safe

echo "\n==========================================="
echo "Multi-Environment Testing Complete"
echo "==========================================="
```

---

## C. Connect & Apply

### How to Test It

```bash
# Run against development (default)
pytest tests/ -v

# Run against staging
pytest tests/ --env=staging -v

# Run against production (only safe tests)
pytest tests/ --env=production -v

# Run specific environment with markers
pytest tests/ --env=staging -m "not destructive" -v
```

### Expected Result

```
# Development:
Loading configuration: .env.development
API Client configured for: http://localhost:8000
tests/test_multi_env.py::test_api_health PASSED
tests/test_multi_env.py::test_delete_all_users PASSED
tests/test_multi_env.py::test_debug_endpoints PASSED

# Production:
Loading configuration: .env.production
API Client configured for: https://api.example.com
tests/test_multi_env.py::test_api_health PASSED
tests/test_multi_env.py::test_delete_all_users SKIPPED (Destructive test skipped in production)
tests/test_multi_env.py::test_debug_endpoints SKIPPED (Only runs in development)
```

---

## D. Common Stumbling Blocks

### Mistake #1: Forgetting to mark production-safe tests

**The Problem:**

```python
def test_important_check(api_client):
    # No marker - won't run in production!
    pass
```

**The Fix:**

```python
@pytest.mark.prod_safe
def test_important_check(api_client):
    pass
```

---

### Mistake #2: Destructive tests without markers

**The Problem:**

```python
def test_delete_everything(api_client):
    # Runs in production by mistake!
    api_client.delete("/users/all")
```

**The Fix:**

```python
@pytest.mark.destructive
def test_delete_everything(api_client):
    # Automatically skipped in production
    pass
```

---

## ðŸŽ¯ Key Takeaways

âœ… **--env flag** for command-line environment selection  
âœ… **Markers** (@pytest.mark) for environment-specific tests  
âœ… **prod_safe marker** required for production tests  
âœ… **destructive marker** auto-skips in production  
âœ… **pytest_runtest_setup hook** for automatic skipping  
âœ… **Test all environments** in CI/CD pipeline  

---

## What's Next?

Next: **httpx Client Configuration per Environment** - environment-specific client settings!

**Ready to continue?** ðŸš€
